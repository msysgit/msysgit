Index: configure.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/configure.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure.in
--- configure.in	2003/02/16 21:33:17	1.1.1.1
+++ configure.in	2003/02/16 22:03:19
@@ -752,10 +752,10 @@ case "${target}" in
     target_configdirs="$target_configdirs target-mingw"
     noconfigdirs="$noconfigdirs expect target-libgloss ${libgcj}"
 
-    # Can't build gdb for mingw32 if not native.
+    # Can't build some things for mingw32 if not native.
     case "${host}" in
-      i[3456]86-*-mingw32) ;; # keep gdb tcl tk expect etc.
-      *) noconfigdirs="$noconfigdirs gdb tcl tk expect itcl tix db snavigator gnuserv"
+      i[3456]86-*-mingw32) ;; # keep tcl tk expect etc.
+      *) noconfigdirs="$noconfigdirs tcl tk expect itcl tix db snavigator gnuserv"
          ;;
     esac
     ;;    
Index: bfd/opncls.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/bfd/opncls.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 opncls.c
--- bfd/opncls.c	2003/02/16 21:33:43	1.1.1.1
+++ bfd/opncls.c	2003/02/16 22:03:19
@@ -218,7 +218,18 @@ bfd_fdopenr (filename, target, fd)
 
   bfd_set_error (bfd_error_system_call);
 #if ! defined(HAVE_FCNTL) || ! defined(F_GETFL)
+#ifdef __MINGW32__
+  /* If we wrongly guess the access type on mingw, later in bfd_open_file
+     fopen will fail trying to open currently executing file in +r mode. */
+     
+  /* I can't find a better way to determine which way fd was opened. */
+  if ( _commit( fd) < 0)
+    fdflags = O_RDONLY;
+  else
+    fdflags = O_RDWR;
+#else
   fdflags = O_RDWR;			/* Assume full access */
+#endif
 #else
   fdflags = fcntl (fd, F_GETFL, NULL);
 #endif
Index: gdb/Makefile.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/Makefile.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 Makefile.in
--- gdb/Makefile.in	2003/02/16 21:34:20	1.1.1.1
+++ gdb/Makefile.in	2003/02/16 22:03:17
@@ -1204,7 +1204,7 @@ ALLDEPFILES = 29k-share/udi/udip2soc.c 2
 	remote-udi.c remote-vx.c remote-vx29k.c \
 	rs6000-nat.c rs6000-tdep.c \
 	s390-tdep.c s390-nat.c \
-	ser-go32.c ser-pipe.c ser-tcp.c \
+	ser-go32.c ser-pipe.c ser-tcp.c ser-dummy.c \
 	sh-tdep.c solib.c solib-svr4.c solib-sunos.c sparc-linux-nat.c \
 	sparc-nat.c \
 	sparc-tdep.c sparcl-tdep.c sun3-nat.c \
@@ -2000,6 +2000,8 @@ ser-pipe.o: ser-pipe.c $(defs_h) $(seria
 ser-tcp.o: ser-tcp.c $(defs_h) $(serial_h) $(gdb_string_h) $(ser_unix_h)
 
 ser-unix.o: ser-unix.c $(defs_h) $(serial_h) $(ser_unix_h) 
+
+ser-dummy.o: ser-dummy.c $(defs_h) $(serial_h)
 
 serial.o: serial.c $(defs_h) $(serial_h) $(gdb_string_h)
 
Index: gdb/configure
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/configure,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure
--- gdb/configure	2003/02/16 21:34:02	1.1.1.1
+++ gdb/configure	2003/02/16 22:03:17
@@ -6836,10 +6836,40 @@ fi
 echo "$ac_t""$gdb_cv_os_cygwin" 1>&6
 
 
+# In the MinGW environment, we need some additional flags.
+echo $ac_n "checking for mingw""... $ac_c" 1>&6
+echo "configure:6813: checking for mingw" >&5
+if eval "test \"`echo '$''{'gdb_cv_os_mingw'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftest.$ac_ext <<EOF
+#line 6818 "configure"
+#include "confdefs.h"
+
+#if defined (__MINGW__) || defined (__MINGW32__)
+lose
+#endif
+EOF
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "lose" >/dev/null 2>&1; then
+  rm -rf conftest*
+  gdb_cv_os_mingw=yes
+else
+  rm -rf conftest*
+  gdb_cv_os_mingw=no
+fi
+rm -f conftest*
+
+fi
+
+echo "$ac_t""$gdb_cv_os_mingw" 1>&6
+
+
 SER_HARDWIRE="ser-unix.o ser-pipe.o ser-tcp.o"
 case ${host} in
   *go32* ) SER_HARDWIRE=ser-go32.o ;;
   *djgpp* ) SER_HARDWIRE=ser-go32.o ;;
+  *mingw* ) SER_HARDWIRE=ser-dummy.o ;;
 esac
 
 
@@ -7102,7 +7132,7 @@ fi
 
 # libreadline needs libuser32.a in a cygwin environment
 WIN32LIBS=
-if test x$gdb_cv_os_cygwin = xyes; then
+if test x$gdb_cv_os_cygwin = xyes || test x$gdb_cv_os_mingw = xyes; then
     WIN32LIBS="-luser32"
     case "${target}" in
 	*cygwin*) WIN32LIBS="$WIN32LIBS -limagehlp"
@@ -7181,7 +7211,7 @@ else
   
 # Default is on for everything but go32 and Cygwin
 case "$host" in
-    *go32* | *windows*)
+    *go32* | *windows* | *mingw* )
 	;;
     *)
  	if test -d "${srcdir}/gdbtk" ; then
@@ -8119,7 +8149,7 @@ fi
 	   CONFIG_INSTALL="${CONFIG_INSTALL} \$(SUBDIR_GDBTK_INSTALL)"
 	   CONFIG_UNINSTALL="${CONFIG_UNINSTALL} \$(SUBDIR_GDBTK_UNINSTALL)"
 
-	   if test x$gdb_cv_os_cygwin = xyes; then
+	   if test x$gdb_cv_os_cygwin = xyes || test x$gdb_cv_os_mingw = xyes; then
 	      WIN32LIBS="${WIN32LIBS} -lshell32 -lgdi32 -lcomdlg32 -ladvapi32"
 	      WIN32LDAPP="-Wl,--subsystem,console"
 	      CONFIG_OBS="${CONFIG_OBS} gdbres.o"
Index: gdb/configure.host
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/configure.host,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure.host
--- gdb/configure.host	2003/02/16 21:34:03	1.1.1.1
+++ gdb/configure.host	2003/02/16 22:03:17
@@ -81,6 +81,7 @@ i[3456]86-*-unixware*)	gdb_host=i386v4 ;
 i[3456]86-*-sysv*)	gdb_host=i386v ;;
 i[3456]86-*-isc*)	gdb_host=i386v32 ;;
 i[3456]86-*-cygwin*)	gdb_host=cygwin ;;
+i[3456]86-*-mingw32*)	gdb_host=mingw32 ;;
 
 ia64-*-aix*)		gdb_host=aix ;;
 ia64-*-linux*)		gdb_host=linux ;;
Index: gdb/configure.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/configure.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure.in
--- gdb/configure.in	2003/02/16 21:34:03	1.1.1.1
+++ gdb/configure.in	2003/02/16 22:03:17
@@ -847,12 +847,20 @@ AC_CACHE_CHECK([for cygwin], gdb_cv_os_c
 lose
 #endif],[gdb_cv_os_cygwin=yes],[gdb_cv_os_cygwin=no])])
 
+# Ditto for MinGW
+AC_CACHE_CHECK([for mingw], gdb_cv_os_mingw,
+[AC_EGREP_CPP(lose, [
+#if defined (__MINGW__) || defined (__MINGW32__)
+lose
+#endif],[gdb_cv_os_mingw=yes],[gdb_cv_os_mingw=no])])
 
+
 dnl Figure out which of the many generic ser-*.c files the _host_ supports.
 SER_HARDWIRE="ser-unix.o ser-pipe.o ser-tcp.o"
 case ${host} in
   *go32* ) SER_HARDWIRE=ser-go32.o ;;
   *djgpp* ) SER_HARDWIRE=ser-go32.o ;;
+  *mingw* ) SER_HARDWIRE=ser-dummy.o ;;
 esac
 AC_SUBST(SER_HARDWIRE)
 
@@ -882,7 +890,7 @@ AC_SUBST(TERM_LIB)
 
 # libreadline needs libuser32.a in a cygwin environment
 WIN32LIBS=
-if test x$gdb_cv_os_cygwin = xyes; then
+if test x$gdb_cv_os_cygwin = xyes || test x$gdb_cv_os_mingw = xyes; then
     WIN32LIBS="-luser32"
     case "${target}" in
 	*cygwin*) WIN32LIBS="$WIN32LIBS -limagehlp"
@@ -951,9 +959,9 @@ AC_ARG_ENABLE(gdbtk,
 	AC_MSG_ERROR(bad value ${enableval} given for gdbtk option) ;;
 esac],
 [
-# Default is on for everything but go32 and Cygwin
+# Default is on for everything but go32, MinGW and Cygwin
 case "$host" in
-    *go32* | *windows*)
+    *go32* | *windows* | *mingw* )
 	;;
     *)
  	if test -d "${srcdir}/gdbtk" ; then
@@ -1078,7 +1086,7 @@ if test "${enable_gdbtk}" = "yes"; then
 	   CONFIG_INSTALL="${CONFIG_INSTALL} \$(SUBDIR_GDBTK_INSTALL)"
 	   CONFIG_UNINSTALL="${CONFIG_UNINSTALL} \$(SUBDIR_GDBTK_UNINSTALL)"
 
-	   if test x$gdb_cv_os_cygwin = xyes; then
+	   if test x$gdb_cv_os_cygwin = xyes || test x$gdb_cv_os_mingw = xyes; then
 	      WIN32LIBS="${WIN32LIBS} -lshell32 -lgdi32 -lcomdlg32 -ladvapi32"
 	      WIN32LDAPP="-Wl,--subsystem,console"
 	      CONFIG_OBS="${CONFIG_OBS} gdbres.o"
Index: gdb/configure.tgt
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/configure.tgt,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure.tgt
--- gdb/configure.tgt	2003/02/16 21:34:03	1.1.1.1
+++ gdb/configure.tgt	2003/02/16 22:03:17
@@ -126,6 +126,7 @@ i[3456]86-*-netware*)	gdb_target=i386nw
 		configdirs="${configdirs} nlm" ;;
 i[3456]86-*-osf1mk*)	gdb_target=i386mk ;;
 i[3456]86-*-cygwin*)	gdb_target=cygwin  ;;
+i[3456]86-*-mingw32*)	gdb_target=mingw32  ;;
 i[3456]86-*-pe*)	gdb_target=embed  ;;
 i[3456]86-*-vxworks*)	gdb_target=vxworks ;;
 
Index: gdb/defs.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/defs.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 defs.h
--- gdb/defs.h	2003/02/16 21:34:05	1.1.1.1
+++ gdb/defs.h	2003/02/16 22:03:19
@@ -810,9 +810,13 @@ enum lval_type
 
 struct frame_info;
 
-/* From readline (but not in any readline .h files).  */
+#ifndef __MINGW32__
+  /* From readline (but not in any readline .h files).  */
 
-extern char *tilde_expand (char *);
+  extern char *tilde_expand (char *);
+#else
+  /* readline 4.2 ported to MinGW does have this. */
+#endif
 
 /* Control types for commands */
 
@@ -1363,7 +1367,7 @@ extern int use_windows;
 #define SLASH_STRING "/"
 #endif
 
-#ifdef __MSDOS__
+#if defined(__MSDOS__) || defined(__MINGW32__)
 # define CANT_FORK
 # define GLOBAL_CURDIR
 #endif
Index: gdb/environ.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/environ.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 environ.c
--- gdb/environ.c	2003/02/16 21:34:07	1.1.1.1
+++ gdb/environ.c	2003/02/16 22:03:18
@@ -27,12 +27,12 @@
 
 /* Return a new environment object.  */
 
-struct environ *
+struct gdb_environ *
 make_environ (void)
 {
-  register struct environ *e;
+  register struct gdb_environ *e;
 
-  e = (struct environ *) xmalloc (sizeof (struct environ));
+  e = (struct gdb_environ *) xmalloc (sizeof (struct gdb_environ));
 
   e->allocated = 10;
   e->vector = (char **) xmalloc ((e->allocated + 1) * sizeof (char *));
@@ -43,7 +43,7 @@ make_environ (void)
 /* Free an environment and all the strings in it.  */
 
 void
-free_environ (register struct environ *e)
+free_environ (register struct gdb_environ *e)
 {
   register char **vector = e->vector;
 
@@ -58,7 +58,7 @@ free_environ (register struct environ *e
    that all strings in these environments are safe to free.  */
 
 void
-init_environ (register struct environ *e)
+init_environ (register struct gdb_environ *e)
 {
   extern char **environ;
   register int i;
@@ -90,7 +90,7 @@ init_environ (register struct environ *e
    This is used to get something to pass to execve.  */
 
 char **
-environ_vector (struct environ *e)
+environ_vector (struct gdb_environ *e)
 {
   return e->vector;
 }
@@ -98,7 +98,7 @@ environ_vector (struct environ *e)
 /* Return the value in environment E of variable VAR.  */
 
 char *
-get_in_environ (const struct environ *e, const char *var)
+get_in_environ (const struct gdb_environ *e, const char *var)
 {
   register int len = strlen (var);
   register char **vector = e->vector;
@@ -114,7 +114,7 @@ get_in_environ (const struct environ *e,
 /* Store the value in E of VAR as VALUE.  */
 
 void
-set_in_environ (struct environ *e, const char *var, const char *value)
+set_in_environ (struct gdb_environ *e, const char *var, const char *value)
 {
   register int i;
   register int len = strlen (var);
@@ -161,7 +161,7 @@ set_in_environ (struct environ *e, const
 /* Remove the setting for variable VAR from environment E.  */
 
 void
-unset_in_environ (struct environ *e, char *var)
+unset_in_environ (struct gdb_environ *e, char *var)
 {
   register int len = strlen (var);
   register char **vector = e->vector;
Index: gdb/environ.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/environ.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 environ.h
--- gdb/environ.h	2003/02/16 21:34:07	1.1.1.1
+++ gdb/environ.h	2003/02/16 22:03:18
@@ -21,7 +21,7 @@
 
 /* We manipulate environments represented as these structures.  */
 
-struct environ
+struct gdb_environ
   {
     /* Number of usable slots allocated in VECTOR.
        VECTOR always has one slot not counted here,
@@ -34,18 +34,18 @@ struct environ
     char **vector;
   };
 
-extern struct environ *make_environ (void);
+extern struct gdb_environ *make_environ (void);
 
-extern void free_environ (struct environ *);
+extern void free_environ (struct gdb_environ *);
 
-extern void init_environ (struct environ *);
+extern void init_environ (struct gdb_environ *);
 
-extern char *get_in_environ (const struct environ *, const char *);
+extern char *get_in_environ (const struct gdb_environ *, const char *);
 
-extern void set_in_environ (struct environ *, const char *, const char *);
+extern void set_in_environ (struct gdb_environ *, const char *, const char *);
 
-extern void unset_in_environ (struct environ *, char *);
+extern void unset_in_environ (struct gdb_environ *, char *);
 
-extern char **environ_vector (struct environ *);
+extern char **environ_vector (struct gdb_environ *);
 
 #endif /* defined (ENVIRON_H) */
Index: gdb/event-loop.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/event-loop.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 event-loop.c
--- gdb/event-loop.c	2003/02/16 21:34:07	1.1.1.1
+++ gdb/event-loop.c	2003/02/16 22:03:18
@@ -36,6 +36,15 @@
 #include <errno.h>
 #include <sys/time.h>
 
+#ifdef __MINGW32__
+#include <io.h>
+#include <mingw-gettimeofday.h>
+/* Define this to avoid including winsock.h from windows.h - this is really
+   fragile! */
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#endif
+
 typedef struct gdb_event gdb_event;
 typedef void (event_handler_func) (int);
 
@@ -145,12 +154,23 @@ static struct
     int poll_timeout;
 #endif
 
+#ifdef __MINGW32__
+    /* Handles for WaitForMultipleObjects.
+
+       Space is allocated for num_fds handles, but currently only console
+       input handles are waited upon, all other handle kinds are
+       considered always ready. */
+
+    HANDLE *waitable_handles;
+    file_handler **waitable_files;
+#else
     /* Masks to be used in the next call to select.
        Bits are set in response to calls to create_file_handler. */
     fd_set check_masks[3];
 
     /* What file descriptors were found ready by select. */
     fd_set ready_masks[3];
+#endif
 
     /* Number of file descriptors to monitor. (for poll) */
     /* Number of valid bits (highest fd value + 1). (for select) */
@@ -458,7 +478,13 @@ add_file_handler (int fd, handler_func *
 #endif
     }
   else
+#ifdef __MINGW32__
+    /* For now, there is no way to specify a mask for users of
+       create_file_handler under MinGW. */
+    create_file_handler (fd, 0, proc, client_data);
+#else
     create_file_handler (fd, GDB_READABLE | GDB_EXCEPTION, proc, client_data);
+#endif
 }
 
 /* Add a file handler/descriptor to the list of descriptors we are
@@ -521,6 +547,38 @@ create_file_handler (int fd, int mask, h
     }
   else
     {
+#ifdef __MINGW32__
+      /* Count number of file_handlers, realloc space if needed */
+
+      int count_fds = 0;
+
+      for (file_ptr = gdb_notifier.first_file_handler; file_ptr != NULL;
+           file_ptr = file_ptr->next_file)
+        count_fds++;
+      
+      if( gdb_notifier.num_fds != count_fds)
+      {
+        if( gdb_notifier.num_fds == 0)
+	{
+	  gdb_notifier.waitable_handles = 
+	    (HANDLE *)xmalloc( sizeof( HANDLE));
+	  gdb_notifier.waitable_files = 
+	    (file_handler **)xmalloc( sizeof( file_handler *));
+	}
+	else
+	{
+	  gdb_notifier.waitable_handles = 
+	    (HANDLE *)xrealloc( 
+	      gdb_notifier.waitable_handles, count_fds * sizeof( HANDLE)
+	    );
+	  gdb_notifier.waitable_files = 
+	    (file_handler **)xrealloc( 
+	      gdb_notifier.waitable_files, count_fds * sizeof( file_handler *)
+	    );
+	}
+	gdb_notifier.num_fds = count_fds;
+      }
+#else
       if (mask & GDB_READABLE)
 	FD_SET (fd, &gdb_notifier.check_masks[0]);
       else
@@ -538,6 +596,7 @@ create_file_handler (int fd, int mask, h
 
       if (gdb_notifier.num_fds <= fd)
 	gdb_notifier.num_fds = fd + 1;
+#endif
     }
 }
 
@@ -594,6 +653,23 @@ delete_file_handler (int fd)
     }
   else
     {
+#ifdef __MINGW32__
+      /* Just realloc space. */
+      --gdb_notifier.num_fds;
+
+      xfree (gdb_notifier.waitable_handles);
+      xfree (gdb_notifier.waitable_files);
+
+      if (gdb_notifier.num_fds > 0)
+      {
+	gdb_notifier.waitable_handles = 
+	  (HANDLE *)xmalloc( gdb_notifier.num_fds * sizeof( HANDLE));
+	gdb_notifier.waitable_files = 
+	  (file_handler **)xmalloc( 
+	    gdb_notifier.num_fds * sizeof( file_handler *)
+	  );
+      }
+#else
       if (file_ptr->mask & GDB_READABLE)
 	FD_CLR (fd, &gdb_notifier.check_masks[0]);
       if (file_ptr->mask & GDB_WRITABLE)
@@ -615,6 +691,7 @@ delete_file_handler (int fd)
 	    }
 	  gdb_notifier.num_fds = i;
 	}
+#endif
     }
 
   /* Deactivate the file descriptor, by clearing its mask, 
@@ -696,6 +773,10 @@ handle_file_event (int event_file_desc)
 	    }
 	  else
 	    {
+#ifdef __MINGW32__
+              /* Masks match when it's ready - simple! */
+	      mask = file_ptr->ready_mask;
+#else
 	      if (file_ptr->ready_mask & GDB_EXCEPTION)
 		{
 		  printf_unfiltered ("Exception condition detected on fd %d\n", file_ptr->fd);
@@ -704,6 +785,7 @@ handle_file_event (int event_file_desc)
 	      else
 		file_ptr->error = 0;
 	      mask = file_ptr->ready_mask & file_ptr->mask;
+#endif
 	    }
 
 	  /* Clear the received events for next time around. */
@@ -758,6 +840,59 @@ gdb_wait_for_event (void)
     }
   else
     {
+#ifdef __MINGW32__
+       /* Since our users may close/dup fds without telling us, 
+          the safest (and simplest) thing is to do fd->HANDLE conversion 
+          every time just before calling WaitForMultipleObjects */
+          
+       /* NOTE: file_handler->mask is really abused here */
+       
+       int waitable_count = 0;
+       HANDLE h;
+       
+       for (file_ptr = gdb_notifier.first_file_handler;
+            file_ptr != NULL;
+            file_ptr = file_ptr->next_file)
+         {
+           file_ptr->mask = 1;
+ 	  file_ptr->error = 0;
+           h = (HANDLE)_get_osfhandle (file_ptr->fd);
+           if (GetFileType (h) == FILE_TYPE_CHAR) /* console */
+             {
+             gdb_notifier.waitable_handles[waitable_count] = h;
+             gdb_notifier.waitable_files[waitable_count] = file_ptr;
+             ++waitable_count;
+             }
+           else /* consider it ready */
+             file_ptr->mask = 1;
+         }
+       if (waitable_count > 0)
+         {
+         DWORD r = WaitForMultipleObjects (waitable_count, 
+                     gdb_notifier.waitable_handles,
+                     false,
+                     gdb_notifier.timeout_valid 
+                      ?       gdb_notifier.select_timeout.tv_sec * 1000
+                            + gdb_notifier.select_timeout.tv_usec / 1000
+                      :  INFINITE);
+                      
+         if (r == WAIT_FAILED)
+ 	  {
+ 	    int i;
+ 	    
+             printf_unfiltered( "gdb_wait_for_event: WaitForMultipleObjects failed: %x\n",
+                                   (unsigned)GetLastError() );
+ 	    for (i=0; i<waitable_count; ++i )
+ 	      gdb_notifier.waitable_files[i]->error = 1;
+ 	  }
+                                 
+         /* WaitForMultipleObjects returns only the first ready object.
+            I don't know how to get to the others */
+         if (r >= WAIT_OBJECT_0 && r < WAIT_OBJECT_0 + waitable_count)
+           gdb_notifier.waitable_files[r-WAIT_OBJECT_0]->mask = 1;
+          
+      }
+#else
       gdb_notifier.ready_masks[0] = gdb_notifier.check_masks[0];
       gdb_notifier.ready_masks[1] = gdb_notifier.check_masks[1];
       gdb_notifier.ready_masks[2] = gdb_notifier.check_masks[2];
@@ -778,6 +913,7 @@ gdb_wait_for_event (void)
 	  if (errno != EINTR)
 	    perror_with_name ("Select");
 	}
+#endif
     }
 
   /* Enqueue all detected file events. */
@@ -820,7 +956,25 @@ gdb_wait_for_event (void)
     }
   else
     {
+#ifdef __MINGW32__
+
+      /* NOTE: file_handler->mask is really abused here */
+      
       for (file_ptr = gdb_notifier.first_file_handler;
+           file_ptr != NULL;
+           file_ptr = file_ptr->next_file)
+        if (file_ptr->mask)
+          {
+            file_ptr->mask = 0;
+    	    if (file_ptr->ready_mask == 0)
+	      {
+	        file_event_ptr = create_file_event (file_ptr->fd);
+	        async_queue_event (file_event_ptr, TAIL);
+  	        file_ptr->ready_mask = 1;
+	      }
+          }
+#else
+      for (file_ptr = gdb_notifier.first_file_handler;
 	   (file_ptr != NULL) && (num_found > 0);
 	   file_ptr = file_ptr->next_file)
 	{
@@ -848,6 +1002,7 @@ gdb_wait_for_event (void)
 	    }
 	  file_ptr->ready_mask = mask;
 	}
+#endif
     }
   return 0;
 }
Index: gdb/event-top.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/event-top.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 event-top.c
--- gdb/event-top.c	2003/02/16 21:34:07	1.1.1.1
+++ gdb/event-top.c	2003/02/16 22:03:17
@@ -27,6 +27,10 @@
 #include "event-loop.h"
 #include "event-top.h"
 #include <signal.h>
+#ifdef __MINGW32__
+  /* MinGW does not yet (mingw-runtime-2.2) define SIGQUIT */
+  #define SIGQUIT 3
+#endif
 
 /* For dont_repeat() */
 #include "gdbcmd.h"
@@ -564,7 +568,9 @@ command_line_handler_continuation (struc
   extern int display_space;
 
   long time_at_cmd_start  = arg->data.longint;
+#ifdef HAVE_SBRK
   long space_at_cmd_start = arg->next->data.longint;
+#endif
 
   bpstat_do_actions (&stop_bpstat);
   /*do_cleanups (old_chain); *//*?????FIXME????? */
@@ -967,9 +973,13 @@ handle_sigint (int sig)
      processed only the next time through the event loop.  To get to
      that point, though, the command that we want to interrupt needs to
      finish first, which is unacceptable. */
+#ifndef __MINGW32__
+  /* MS docs say that you shouldn't call library routines from Ctrl+C 
+     handler */
   if (immediate_quit)
     async_request_quit (0);
   else
+#endif
     /* If immediate quit is not set, we process SIGINT the next time
        through the loop, which is fine. */
     mark_async_signal_handler_wrapper (sigint_token);
Index: gdb/infcmd.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/infcmd.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 infcmd.c
--- gdb/infcmd.c	2003/02/16 21:34:16	1.1.1.1
+++ gdb/infcmd.c	2003/02/16 22:03:17
@@ -196,7 +196,7 @@ int step_multi;
 /* Environment to use for running inferior,
    in format described in environ.h.  */
 
-struct environ *inferior_environ;
+struct gdb_environ *inferior_environ;
 
 /* Accessor routines. */
 
Index: gdb/inferior.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/inferior.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 inferior.h
--- gdb/inferior.h	2003/02/16 21:34:16	1.1.1.1
+++ gdb/inferior.h	2003/02/16 22:03:18
@@ -134,7 +134,7 @@ extern int inferior_ignoring_leading_exe
 
 /* Inferior environment. */
 
-extern struct environ *inferior_environ;
+extern struct gdb_environ *inferior_environ;
 
 extern void clear_proceed_status (void);
 
Index: gdb/remote.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/remote.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 remote.c
--- gdb/remote.c	2003/02/16 21:34:29	1.1.1.1
+++ gdb/remote.c	2003/02/16 22:03:18
@@ -5666,6 +5666,11 @@ readtty (void)
 static int
 minitelnet (void)
 {
+#ifdef __MINGW32__
+  /* Under MinGW, this code is unusable until something more sensible than
+     ser-dummy is implemented. */
+  return FATAL_ERROR; 
+#else
   fd_set input;			/* file descriptors for select */
   int tablesize;		/* max number of FDs for select */
   int status;
@@ -5744,6 +5749,7 @@ minitelnet (void)
 	  return status;	/* telnet session ended */
 	}
     }
+#endif
 }
 
 static ptid_t
Index: gdb/source.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/source.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 source.c
--- gdb/source.c	2003/02/16 21:34:33	1.1.1.1
+++ gdb/source.c	2003/02/16 22:03:18
@@ -124,6 +124,20 @@ static struct symtab *last_source_visite
 static int last_source_error = 0;
 
 
+int os_open (const char *name, int mode, int prot)
+{
+#ifdef __MINGW32__
+  /* Someone has the habit of writing absolute paths starting with two
+     slashes to the EXE debug info. Windows treats this as a UNC (network
+     machine) name, causing a LONG delay when it tries unsuccessfully to
+     open it. Eliminate that. */
+  if (name[0] == '/' && name[1] == '/')
+    name++;
+#endif
+
+  return open (name, mode, prot);
+}
+
 /* Set the source file default for the "list" command to be S.
 
    If S is NULL, and we don't have a default, find one.  This
@@ -548,7 +562,7 @@ openp (const char *path, int try_cwd_fir
       int i;
       filename = alloca (strlen (string) + 1);
       strcpy (filename, string);
-      fd = open (filename, mode, prot);
+      fd = os_open (filename, mode, prot);
       if (fd >= 0)
 	goto done;
       for (i = 0; string[i]; i++)
@@ -601,7 +615,7 @@ openp (const char *path, int try_cwd_fir
       strcat (filename + len, SLASH_STRING);
       strcat (filename, string);
 
-      fd = open (filename, mode);
+      fd = os_open (filename, mode, prot);
       if (fd >= 0)
 	break;
     }
@@ -673,7 +687,7 @@ open_source_file (struct symtab *s)
   /* Quick way out if we already know its full name */
   if (s->fullname)
     {
-      result = open (s->fullname, OPEN_MODE);
+      result = os_open (s->fullname, OPEN_MODE, S_IRWXU);
       if (result >= 0)
 	return result;
       /* Didn't work -- free old one, try again. */
Index: gdb/top.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/top.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 top.c
--- gdb/top.c	2003/02/16 21:34:35	1.1.1.1
+++ gdb/top.c	2003/02/16 22:03:19
@@ -30,6 +30,10 @@
 #include "symtab.h"
 #include "inferior.h"
 #include <signal.h>
+#ifdef __MINGW32__
+  /* MinGW does not yet (mingw-runtime-2.2) define SIGQUIT */
+  #define SIGQUIT 3
+#endif
 #include "target.h"
 #include "breakpoint.h"
 #include "gdbtypes.h"
Index: gdb/utils.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/utils.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 utils.c
--- gdb/utils.c	2003/02/16 21:34:36	1.1.1.1
+++ gdb/utils.c	2003/02/16 22:03:18
@@ -733,7 +733,10 @@ Create a core file containing the curren
     {
       if (dump_core_p)
 	{
+          /* TODO: MinGW has no fork - figure out how to continue anyway. */
+#ifndef CANT_FORK
 	  if (fork () == 0)
+#endif
 	    abort (); /* NOTE: GDB has only three calls to abort().  */
 	}
     }
Index: gdb/win32-nat.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/win32-nat.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 win32-nat.c
--- gdb/win32-nat.c	2003/02/16 21:34:37	1.1.1.1
+++ gdb/win32-nat.c	2003/02/16 22:03:19
@@ -24,8 +24,6 @@
 
 /* Originally by Steve Chamberlain, sac@cygnus.com */
 
-/* We assume we're being built with and will be used for cygwin.  */
-
 #include "defs.h"
 #include "tm.h"			/* required for SSE registers */
 #include "frame.h"		/* required by inferior.h */
@@ -43,7 +41,9 @@
 #include <stdlib.h>
 #include <windows.h>
 #include <imagehlp.h>
-#include <sys/cygwin.h>
+#ifdef __CYGWIN__
+  #include <sys/cygwin.h>
+#endif
 
 #include "buildsym.h"
 #include "symfile.h"
@@ -52,6 +52,9 @@
 #include "gdbthread.h"
 #include "gdbcmd.h"
 #include <sys/param.h>
+#ifdef __MINGW32__
+  #define MAXPATHLEN PATH_MAX
+#endif
 #include <unistd.h>
 
 /* The ui's event loop. */
@@ -66,8 +69,66 @@ enum
     FLAG_TRACE_BIT = 0x100,
     CONTEXT_DEBUGGER = (CONTEXT_FULL | CONTEXT_FLOATING_POINT)
   };
+#endif
+#ifndef __MINGW32__
+  #include <sys/procfs.h>
+#else
+  #define	NOTE_INFO_PROCESS	1
+  #define	NOTE_INFO_THREAD	2
+  #define	NOTE_INFO_MODULE	3
+
+  struct win32_core_process_info
+  {
+    DWORD pid;
+    int signal;
+    int command_line_size;
+    char command_line[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_thread_info
+  {
+    DWORD tid;
+    BOOL is_active_thread;
+    CONTEXT thread_context;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_core_module_info
+  {
+    void* base_address;
+    int module_name_size;
+    char module_name[1];
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  struct win32_pstatus
+  {
+    unsigned long data_type;
+    union
+      {
+        struct win32_core_process_info process_info;
+        struct win32_core_thread_info thread_info;
+        struct win32_core_module_info module_info;
+      } data ;
+  }
+  #ifdef __GNUC__
+    __attribute__ ((packed))
+  #endif
+  ;
+
+  typedef struct win32_pstatus win32_pstatus_t ;
+
 #endif
-#include <sys/procfs.h>
 #include <psapi.h>
 
 #ifdef HAVE_SSE_REGS
@@ -132,7 +193,7 @@ static int event_count = 0;
 static int saw_create;
 
 /* User options. */
-static int new_console = 0;
+static int new_console = 1;
 static int new_group = 1;
 static int debug_exec = 0;		/* show execution */
 static int debug_events = 0;		/* show events from kernel */
@@ -597,7 +658,12 @@ register_loaded_dll (const char *name, D
 	}
     }
 
+#ifdef __CYGWIN__
   cygwin_conv_to_posix_path (buf, ppath);
+#else
+  strcpy( ppath, buf);
+#endif
+
   so = (struct so_stuff *) xmalloc (sizeof (struct so_stuff) + strlen (ppath) + 8 + 1);
   so->loaded = 0;
   so->load_addr = load_addr;
@@ -1462,6 +1528,12 @@ child_create_inferior (char *exec_file, 
   char shell[MAX_PATH + 1]; /* Path to shell */
   const char *sh;
 
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  HANDLE hStdInput = 0;
+  HANDLE hStdOutput = 0;
+  HANDLE hStdError = 0;
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+
   if (!exec_file)
     error ("No executable specified, use `target exec'.\n");
 
@@ -1471,7 +1543,11 @@ child_create_inferior (char *exec_file, 
   if (!useshell)
     {
       flags = DEBUG_ONLY_THIS_PROCESS;
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (exec_file, real_path);
+#else
+      strcpy( real_path, exec_file);
+#endif
       toexec = real_path;
     }
   else
@@ -1480,7 +1556,11 @@ child_create_inferior (char *exec_file, 
       sh = getenv ("SHELL");
       if (!sh)
 	sh = "/bin/sh";
+#ifdef __CYGWIN__
       cygwin_conv_to_win32_path (sh, shell);
+#else
+      strcpy( shell, sh);
+#endif
       newallargs = alloca (sizeof (" -c 'exec  '") + strlen (exec_file)
 			   + strlen (allargs) + 2);
       sprintf (newallargs, " -c 'exec %s %s'", exec_file, allargs);
@@ -1529,10 +1609,12 @@ child_create_inferior (char *exec_file, 
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], env[i], len) == 0)
 	      {
+#ifdef __CYGWIN__
 		if (cygwin_posix_path_list_p (env[i] + len))
 		  envlen += len
 		    + cygwin_posix_to_win32_path_list_buf_size (env[i] + len);
 		else
+#endif
 		  envlen += strlen (env[i]) + 1;
 		break;
 	      }
@@ -1553,12 +1635,14 @@ child_create_inferior (char *exec_file, 
 	    len = strlen (conv_path_names[j]);
 	    if (strncmp (conv_path_names[j], env[i], len) == 0)
 	      {
+#ifdef __CYGWIN__
 		if (cygwin_posix_path_list_p (env[i] + len))
 		  {
 		    memcpy (temp, env[i], len);
 		    cygwin_posix_to_win32_path_list (env[i] + len, temp + len);
 		  }
 		else
+#endif
 		  strcpy (temp, env[i]);
 		break;
 	      }
@@ -1573,6 +1657,19 @@ child_create_inferior (char *exec_file, 
     *temp = 0;
   }
 
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      hStdInput = GetStdHandle( STD_INPUT_HANDLE);
+      hStdOutput = GetStdHandle( STD_OUTPUT_HANDLE);
+      hStdError = GetStdHandle( STD_ERROR_HANDLE);
+
+      SetStdHandle( STD_INPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_OUTPUT_HANDLE, INVALID_HANDLE_VALUE);
+      SetStdHandle( STD_ERROR_HANDLE, INVALID_HANDLE_VALUE);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
+
   ret = CreateProcess (0,
 		       args,	/* command line */
 		       NULL,	/* Security */
@@ -1588,6 +1685,15 @@ child_create_inferior (char *exec_file, 
 
   CloseHandle (pi.hThread);
   CloseHandle (pi.hProcess);
+
+  /* BEGIN: Fragment of Al Stevens's patch for GDB on Win9x */
+  if ( new_console)
+    {
+      SetStdHandle( STD_INPUT_HANDLE, hStdInput);
+      SetStdHandle( STD_OUTPUT_HANDLE, hStdOutput);
+      SetStdHandle( STD_ERROR_HANDLE, hStdError);
+    }
+  /* END: Fragment of Al Stevens's patch for GDB on Win9x */
 
   if (useshell && shell[0] != '\0')
     saw_create = -1;
Index: gdb/mi/mi-main.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/gdb/mi/mi-main.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 mi-main.c
--- gdb/mi/mi-main.c	2003/02/16 21:35:17	1.1.1.1
+++ gdb/mi/mi-main.c	2003/02/16 22:03:17
@@ -42,6 +42,10 @@
 #include <ctype.h>
 #include <sys/time.h>
 
+#ifdef __MINGW32__
+  #include <mingw-gettimeofday.h>
+#endif
+
 /* Convenience macro for allocting typesafe memory. */
 
 #undef XMALLOC
Index: readline/CHANGELOG
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/CHANGELOG,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 CHANGELOG
--- readline/CHANGELOG	2003/02/16 21:36:29	1.1.1.1
+++ readline/CHANGELOG	2001/04/06 19:15:12
@@ -337,3 +337,129 @@ doc/Makefile.in
 
 configure.in
 	- changed LIBVERSION to 4.1-beta5
+
+				 3/17/2000
+				 ---------
+[readline-4.1 released]
+
+				   3/23
+				   ----
+Makefile.in
+	- remove the `-t' argument to ranlib in the install recipe; some
+	  ranlibs don't have it and attempt to create a file named `-t'
+
+				   3/27
+				   ----
+support/shlib-install
+	- install shared libraries unwritable by anyone on HP-UX
+	- changed symlinks to relative pathnames on all platforms
+
+shlib/Makefile.in
+	- added missing `includedir' assignment, substituted by configure
+
+Makefile.in
+	- added missing @SET_MAKE@ so configure can set $MAKE appropriately
+
+configure.in
+	- add call to AC_PROG_MAKE_SET
+
+				   8/30
+				   ----
+shlib/Makefile.in
+	- change the soname bound into the shared libraries, so it includes
+	  only the major version number.  If it includes the minor version,
+	  programs depending on it must be rebuilt (which may or may not be
+	  a bad thing)
+
+				    9/6
+				    ---
+examples/rlfe.c
+	- add -l option to log input and output (-a option appends to logfile)
+	- add -n option to set readline application name
+	- add -v, -h options for version and help information
+	- change a few things because getopt() is now used to parse arguments
+
+				   9/12
+				   ----
+support/shlib-install
+	- fix up the libname on HPUX 11
+
+				   10/18
+				   -----
+configure.in
+	- changed library version to 4.2-alpha
+
+				   10/30
+				   -----
+configure.in
+	- add -fsigned-char to LOCAL_CFLAGS for Linux running on the IBM
+	  S/390
+
+Makefile.in
+	- added new file, rltypedefs.h, installed by default with `make install'
+
+				   11/2
+				   ----
+compat.c
+	- new file, with backwards-compatibility function definitions
+
+Makefile.in,shlib/Makefile.in
+	- make sure that compat.o/compat.so are built and linked apppropriately
+
+support/shobj-conf
+	- picked up bash version, which means that shared libs built on
+	  linux and BSD/OS 4.x will have an soname that does not include
+	  the minor version number
+
+				   11/13
+				   -----
+examples/rlfe.c
+	- rlfe can perform filename completion for relative pathnames in the
+	  inferior process's context if the OS supports /proc/PID/cwd (linux
+	  does it OK, Solaris is slightly warped, none of the BSDs have it)
+
+				11/17/2000
+				----------
+[readline-4.2-alpha released]
+
+				   11/27
+				   -----
+Makefile.in,shlib/Makefile.in
+	- added dependencies for rltypedefs.h
+
+shlib/Makefile.in
+	- changed dependencies on histlib.h to $(topdir)/histlib.h
+
+				   1/22
+				   ----
+configure.in
+	- changed release version to 4.2-beta
+
+				    2/2
+				    ---
+examples/Makefile.in
+	- build histexamp as part of the examples
+
+				    2/5
+				    ---
+doc/Makefile.in
+	- don't remove the dvi, postscript, html, info, and text `objects'
+	  on a `make distclean', only on a `make maintainer-clean'
+
+				    3/6
+				    ---
+doc/history.{0,3}, doc/history_3.ps
+	- new manual page for history library
+
+doc/Makefile.in
+	- rules to install and uninstall history.3 in ${man3dir}
+	- rules to build history.0 and history_3.ps
+
+				    4/2
+				    ---
+configure.in
+	- changed LIBVERSION to `4.2'
+
+				    4/5
+				    ---
+[readline-4.2 frozen]
Index: readline/CHANGES
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/CHANGES,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 CHANGES
--- readline/CHANGES	2003/02/16 21:36:29	1.1.1.1
+++ readline/CHANGES	2001/04/03 14:34:07
@@ -1,3 +1,156 @@
+This document details the changes between this version, readline-4.2,
+and the previous version, readline-4.1.
+
+1.  Changes to Readline
+
+a.  When setting the terminal attributes on systems using `struct termio',
+    readline waits for output to drain before changing the attributes.
+
+b.  A fix was made to the history word tokenization code to avoid attempts to
+    dereference a null pointer.
+
+c.  Readline now defaults rl_terminal_name to $TERM if the calling application
+    has left it unset, and tries to initialize with the resultant value.
+
+d.  Instead of calling (*rl_getc_function)() directly to get input in certain
+    places, readline now calls rl_read_key() consistently.
+
+e.  Fixed a bug in the completion code that allowed a backslash to quote a
+    single quote inside a single-quoted string.
+
+f.  rl_prompt is no longer assigned directly from the argument to readline(),
+    but uses memory allocated by readline.  This allows constant strings to
+    be passed to readline without problems arising when the prompt processing
+    code wants to modify the string.
+
+g.  Fixed a bug that caused non-interactive history searches to return the
+    wrong line when performing multiple searches backward for the same string.
+
+h.  Many variables, function arguments, and function return values are now
+    declared `const' where appropriate, to improve behavior when linking with
+    C++ code.
+
+i.  The control character detection code now works better on systems where
+    `char' is unsigned by default.
+
+j.  The vi-mode numeric argument is now capped at 999999, just like emacs mode.
+
+k.  The Function, CPFunction, CPPFunction, and VFunction typedefs have been
+    replaced with a set of specific prototyped typedefs, though they are
+    still in the readline header files for backwards compatibility.
+
+m.  Nearly all of the (undocumented) internal global variables in the library
+    now have an _rl_ prefix -- there were a number that did not, like
+    screenheight, screenwidth, alphabetic, etc.
+
+n.  The ding() convenience function has been renamed to rl_ding(), though the
+    old function is still defined for backwards compatibility.
+
+o.  The completion convenience functions filename_completion_function,
+    username_completion_function, and completion_matches now have an rl_
+    prefix, though the old names are still defined for backwards compatibility.
+
+p.  The functions shared by readline and bash (linkage is satisfied from bash
+    when compiling with bash, and internally otherwise) now have an sh_ prefix.
+
+q.  Changed the shared library creation procedure on Linux and BSD/OS 4.x so
+    that the `soname' contains only the major version number rather than the
+    major and minor numbers.
+
+r.  Fixed a redisplay bug that occurred when the prompt spanned more than one
+    physical line and contained invisible characters.
+
+s.  Added a missing `includedir' variable to the Makefile.
+
+t.  When installing the shared libraries, make sure symbolic links are relative.
+
+u.  Added configure test so that it can set `${MAKE}' appropriately.
+
+v.  Fixed a bug in rl_forward that could cause the point to be set to before
+    the beginning of the line in vi mode.
+
+w.  Fixed a bug in the callback read-char interface to make it work when a
+    readline function pushes some input onto the input stream with
+    rl_execute_next (like the incremental search functions).
+
+x.  Fixed a file descriptor leak in the history file manipulation code that
+    was tripped when attempting to truncate a non-regular file (like
+    /dev/null).
+
+y.  Changes to make all of the exported readline functions declared in
+    readline.h have an rl_ prefix (rltty_set_default_bindings is now
+    rl_tty_set_default_bindings, crlf is now rl_crlf, etc.)
+
+z.  The formatted documentation included in the base readline distribution
+    is no longer removed on a `make distclean'.
+
+aa. Some changes were made to avoid gcc warnings with -Wall.
+
+bb. rl_get_keymap_by_name now finds keymaps case-insensitively, so
+    `set keymap EMACS' works.
+
+cc. The history file writing and truncation functions now return a useful
+    status on error.
+
+dd. Fixed a bug that could cause applications to dereference a NULL pointer
+    if a NULL second argument was passed to history_expand().
+
+ee. If a hook function assigned to rl_event_hook sets rl_done to a non-zero
+    value, rl_read_key() now immediately returns '\n' (which is assumed to   
+    be bound to accept-line).
+
+2.  New Features in Readline
+
+a.  The blink timeout for paren matching is now settable by applications,
+    via the rl_set_paren_blink_timeout() function.
+
+b.  _rl_executing_macro has been renamed to rl_executing_macro, which means
+    it's now part of the public interface.
+
+c.  Readline has a new variable, rl_readline_state, which is a bitmap that
+    encapsulates the current state of the library; intended for use by
+    callbacks and hook functions.
+
+d.  rlfe has a new -l option to log input and output (-a appends to logfile),
+    a new -n option to set the readline application name, and -v and -h
+    options for version and help information.
+
+e.  rlfe can now perform filename completion for the inferior process if the
+    OS has a /proc/<PID>/cwd that can be read with readlink(2) to get the
+    inferior's current working directory.
+
+f.  A new file, rltypedefs.h, contains the new typedefs for function pointers
+    and is installed by `make install'.
+
+g.  New application-callable function rl_set_prompt(const char *prompt):
+    expands its prompt string argument and sets rl_prompt to the result.
+
+h.  New application-callable function rl_set_screen_size(int rows, int cols):
+    public method for applications to set readline's idea of the screen
+    dimensions.
+
+i.  The history example program (examples/histexamp.c) is now built as one
+    of the examples.
+
+j.  The documentation has been updated to cover nearly all of the public
+    functions and variables declared in readline.h.
+
+k.  New function, rl_get_screen_size (int *rows, int *columns), returns
+    readline's idea of the screen dimensions.
+
+l.  The timeout in rl_gather_tyi (readline keyboard input polling function)
+    is now settable via a function (rl_set_keyboard_input_timeout()).
+
+m.  Renamed the max_input_history variable to history_max_entries; the old
+    variable is maintained for backwards compatibility.
+
+n.  The list of characters that separate words for the history tokenizer is
+    now settable with a variable:  history_word_delimiters.  The default
+    value is as before.
+
+o.  There is a new history.3 manual page documenting the history library.
+
+-------------------------------------------------------------------------------
 This document details the changes between this version, readline-4.1,
 and the previous version, readline-4.0.
 
Index: readline/MANIFEST
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/MANIFEST,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 MANIFEST
--- readline/MANIFEST	2003/02/16 21:36:31	1.1.1.1
+++ readline/MANIFEST	2001/03/05 19:34:36
@@ -32,11 +32,13 @@ rlprivate.h	f
 rlshell.h	f
 rlstdc.h	f
 rltty.h		f
+rltypedefs.h	f
 rlwinsize.h	f
 tcap.h		f
 tilde.h		f
 xmalloc.h	f
 bind.c		f
+compat.c	f
 complete.c	f
 display.c	f
 emacs_keymap.c	f
@@ -85,6 +87,7 @@ doc/hist.texinfo	f
 doc/hstech.texinfo	f
 doc/hsuser.texinfo	f
 doc/readline.3		f
+doc/history.3		f
 doc/texi2dvi		f
 doc/texi2html		f
 examples/Makefile.in	f
@@ -111,3 +114,6 @@ doc/readline.html	f
 doc/history.html	f
 doc/rluserman.html	f
 doc/readline.0		f
+doc/history.0		f
+doc/readline_3.ps	f
+doc/history_3.ps	f
Index: readline/Makefile.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/Makefile.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 Makefile.in
--- readline/Makefile.in	2003/02/16 21:36:31	1.1.1.1
+++ readline/Makefile.in	2000/11/27 16:57:09
@@ -1,6 +1,6 @@
 ## -*- text -*- ##
 # Master Makefile for the GNU readline library.
-# Copyright (C) 1994, 1998 Free Software Foundation, Inc.
+# Copyright (C) 1994 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -19,7 +19,7 @@ RL_LIBRARY_VERSION = @LIBVERSION@
 RL_LIBRARY_NAME = readline
 
 srcdir = @srcdir@
-VPATH = @srcdir@
+VPATH = .:@srcdir@
 top_srcdir = @top_srcdir@
 BUILD_DIR = @BUILD_DIR@
 
@@ -35,6 +35,7 @@ RM = rm -f
 CP = cp
 MV = mv
 
+@SET_MAKE@
 SHELL = @MAKE_SHELL@
 
 prefix = @prefix@
@@ -65,8 +66,15 @@ TERMCAP_LIB = @TERMCAP_LIB@
 # For libraries which include headers from other libraries.
 INCLUDES = -I. -I$(srcdir) -I$(includedir)
 
-CCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES) $(LOCAL_CFLAGS) $(CFLAGS)
+XCCFLAGS = $(DEFS) $(LOCAL_DEFS) $(CPPFLAGS) $(INCLUDES)
+CCFLAGS = $(XCCFLAGS) $(LOCAL_CFLAGS) $(CFLAGS)
 
+# could add -Werror here
+GCC_LINT_FLAGS = -ansi -Wall -Wshadow -Wpointer-arith -Wcast-qual \
+		 -Wwrite-strings -Wstrict-prototypes \
+		 -Wmissing-prototypes -Wno-implicit
+GCC_LINT_CFLAGS = $(XCCFLAGS) $(GCC_LINT_FLAGS) @CFLAGS@ @LOCAL_CFLAGS@
+
 .c.o:
 	${RM} $@
 	$(CC) -c $(CCFLAGS) $<
@@ -85,19 +93,21 @@ CSOURCES = $(srcdir)/readline.c $(srcdir
 	   $(srcdir)/callback.c $(srcdir)/terminal.c $(srcdir)/xmalloc.c \
 	   $(srcdir)/history.c $(srcdir)/histsearch.c $(srcdir)/histexpand.c \
 	   $(srcdir)/histfile.c $(srcdir)/nls.c $(srcdir)/search.c \
-	   $(srcdir)/shell.c $(srcdir)/savestring.c $(srcdir)/tilde.c
+	   $(srcdir)/shell.c $(srcdir)/savestring.c $(srcdir)/tilde.c \
+	   $(srcdir)/compat.c
 
 # The header files for this library.
 HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
 	   posixstat.h posixdir.h posixjmp.h tilde.h rlconf.h rltty.h \
-	   ansi_stdlib.h tcap.h rlstdc.h xmalloc.h rlprivate.h rlshell.h
+	   ansi_stdlib.h tcap.h rlstdc.h xmalloc.h rlprivate.h rlshell.h \
+	   rltypedefs.h
 
 HISTOBJ = history.o histexpand.o histfile.o histsearch.o shell.o 
 TILDEOBJ = tilde.o
 OBJECTS = readline.o vi_mode.o funmap.o keymaps.o parens.o search.o \
 	  rltty.o complete.o bind.o isearch.o display.o signals.o \
 	  util.o kill.o undo.o macro.o input.o callback.o terminal.o \
-	  nls.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)
+	  nls.o compat.o xmalloc.o $(HISTOBJ) $(TILDEOBJ)
 
 # The texinfo files which document this library.
 DOCSOURCE = doc/rlman.texinfo doc/rltech.texinfo doc/rluser.texinfo
@@ -111,7 +121,7 @@ CREATED_CONFIGURE = config.status config
 CREATED_TAGS = TAGS tags
 
 INSTALLED_HEADERS = readline.h chardefs.h keymaps.h history.h tilde.h \
-		    rlstdc.h rlconf.h
+		    rlstdc.h rlconf.h rltypedefs.h
 
 ##########################################################################
 
@@ -134,6 +144,9 @@ libhistory.a: $(HISTOBJ) xmalloc.o
 readline: $(OBJECTS) readline.h rldefs.h chardefs.h ./libreadline.a
 	$(CC) $(CCFLAGS) -o $@ ./examples/rl.c ./libreadline.a ${TERMCAP_LIB}
 
+lint:	force
+	$(MAKE) $(MFLAGS) CCFLAGS='$(GCC_LINT_CFLAGS)' static
+
 Makefile makefile: config.status $(srcdir)/Makefile.in
 	CONFIG_FILES=Makefile CONFIG_HEADERS= $(SHELL) ./config.status
 
@@ -154,6 +167,7 @@ stamp-h: config.status $(srcdir)/config.
 #$(srcdir)/configure: $(srcdir)/configure.in	## Comment-me-out in distribution
 #	cd $(srcdir) && autoconf	## Comment-me-out in distribution
 
+
 shared:	force
 	-test -d shlib || mkdir shlib
 	-( cd shlib ; ${MAKE} ${MFLAGS} all )
@@ -179,27 +193,17 @@ uninstall-headers:
 
 maybe-uninstall-headers: uninstall-headers
 
-## CYGNUS LOCAL
-## Don't mess with people's installed readline's.
-## This tries to install this version of readline over whatever
-## version is already installed on the system (which could be a
-## newer version). There is no real reason for us to install
-## readline along with GDB. GDB links statically against readline,
-## so it doesn't depend on us installing it on the system.
-
-install:
-
-#install: installdirs $(STATIC_LIBS) install-headers
-#	-$(MV) $(libdir)/libreadline.a $(libdir)/libreadline.old
-#	$(INSTALL_DATA) libreadline.a $(libdir)/libreadline.a
-#	-test -n "$(RANLIB)" && $(RANLIB) -t $(libdir)/libreadline.a
-#	-$(MV) $(libdir)/libhistory.a $(libdir)/libhistory.old
-#	$(INSTALL_DATA) libhistory.a $(libdir)/libhistory.a
-#	-test -n "$(RANLIB)" && $(RANLIB) -t $(libdir)/libhistory.a
-#	-( if test -d doc ; then \
-#		cd doc && \
-#		${MAKE} ${MFLAGS} infodir=$(infodir) $@; \
-#	  fi )
+install: installdirs $(STATIC_LIBS) install-headers
+	-$(MV) $(libdir)/libreadline.a $(libdir)/libreadline.old
+	$(INSTALL_DATA) libreadline.a $(libdir)/libreadline.a
+	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libreadline.a
+	-$(MV) $(libdir)/libhistory.a $(libdir)/libhistory.old
+	$(INSTALL_DATA) libhistory.a $(libdir)/libhistory.a
+	-test -n "$(RANLIB)" && $(RANLIB) $(libdir)/libhistory.a
+	-( if test -d doc ; then \
+		cd doc && \
+		${MAKE} ${MFLAGS} infodir=$(infodir) $@; \
+	  fi )
 
 installdirs: $(srcdir)/support/mkdirs
 	-$(SHELL) $(srcdir)/support/mkdirs $(includedir) \
@@ -262,90 +266,91 @@ dist:   force
 # Dependencies
 bind.o: ansi_stdlib.h posixstat.h
 bind.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-bind.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+bind.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 bind.o: history.h
 callback.o: rlconf.h
 callback.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-callback.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+callback.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
+compat.o: rlstdc.h
 complete.o: ansi_stdlib.h posixdir.h posixstat.h
 complete.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-complete.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+complete.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 display.o: ansi_stdlib.h posixstat.h
 display.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 display.o: tcap.h
-display.o: readline.h keymaps.h chardefs.h tilde.h
+display.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 display.o: history.h rlstdc.h
-funmap.o: readline.h keymaps.h chardefs.h tilde.h
+funmap.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 funmap.o: rlconf.h ansi_stdlib.h rlstdc.h
 funmap.o: ${BUILD_DIR}/config.h
 histexpand.o: ansi_stdlib.h
-histexpand.o: history.h histlib.h rlstdc.h
+histexpand.o: history.h histlib.h rlstdc.h rltypedefs.h
 histexpand.o: ${BUILD_DIR}/config.h
 histfile.o: ansi_stdlib.h
-histfile.o: history.h histlib.h rlstdc.h
+histfile.o: history.h histlib.h rlstdc.h rltypedefs.h
 histfile.o: ${BUILD_DIR}/config.h
 history.o: ansi_stdlib.h
-history.o: history.h histlib.h rlstdc.h
+history.o: history.h histlib.h rlstdc.h rltypedefs.h
 history.o: ${BUILD_DIR}/config.h
 histsearch.o: ansi_stdlib.h
-histsearch.o: history.h histlib.h rlstdc.h
+histsearch.o: history.h histlib.h rlstdc.h rltypedefs.h
 histsearch.o: ${BUILD_DIR}/config.h
 input.o: ansi_stdlib.h
 input.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-input.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+input.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 isearch.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-isearch.o: readline.h keymaps.h chardefs.h tilde.h
+isearch.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 isearch.o: ansi_stdlib.h history.h rlstdc.h
 keymaps.o: emacs_keymap.c vi_keymap.c
-keymaps.o: keymaps.h chardefs.h rlconf.h ansi_stdlib.h
-keymaps.o: readline.h keymaps.h chardefs.h tilde.h
+keymaps.o: keymaps.h rltypedefs.h chardefs.h rlconf.h ansi_stdlib.h
+keymaps.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 keymaps.o: ${BUILD_DIR}/config.h rlstdc.h
 kill.o: ansi_stdlib.h
 kill.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-kill.o: readline.h keymaps.h chardefs.h tilde.h
+kill.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 kill.o: history.h rlstdc.h
 macro.o: ansi_stdlib.h
 macro.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-macro.o: readline.h keymaps.h chardefs.h tilde.h
+macro.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 macro.o: history.h rlstdc.h
 nls.o: ansi_stdlib.h
 nls.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-nls.o: readline.h keymaps.h chardefs.h tilde.h  
+nls.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h  
 nls.o: history.h rlstdc.h  
 parens.o: rlconf.h
 parens.o: ${BUILD_DIR}/config.h
-parens.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
-readline.o: readline.h keymaps.h chardefs.h tilde.h
+parens.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
+readline.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 readline.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 readline.o: history.h rlstdc.h
 readline.o: posixstat.h ansi_stdlib.h posixjmp.h
 rltty.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 rltty.o: rltty.h
-rltty.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+rltty.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 search.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-search.o: readline.h keymaps.h chardefs.h tilde.h
+search.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 search.o: ansi_stdlib.h history.h rlstdc.h
 shell.o: ${BUILD_DIR}/config.h
 shell.o: ansi_stdlib.h
 signals.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-signals.o: readline.h keymaps.h chardefs.h tilde.h
+signals.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 signals.o: history.h rlstdc.h
 terminal.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
 terminal.o: tcap.h
-terminal.o: readline.h keymaps.h chardefs.h tilde.h
+terminal.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 terminal.o: history.h rlstdc.h
 tilde.o: ansi_stdlib.h
 tilde.o: ${BUILD_DIR}/config.h
 tilde.o: tilde.h
 undo.o: ansi_stdlib.h
 undo.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-undo.o: readline.h keymaps.h chardefs.h tilde.h
+undo.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 undo.o: history.h rlstdc.h
 util.o: posixjmp.h ansi_stdlib.h
 util.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-util.o: readline.h keymaps.h chardefs.h tilde.h rlstdc.h
+util.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h rlstdc.h
 vi_mode.o: rldefs.h ${BUILD_DIR}/config.h rlconf.h
-vi_mode.o: readline.h keymaps.h chardefs.h tilde.h
+vi_mode.o: readline.h keymaps.h rltypedefs.h chardefs.h tilde.h
 vi_mode.o: history.h ansi_stdlib.h rlstdc.h
 xmalloc.o: ${BUILD_DIR}/config.h
 xmalloc.o: ansi_stdlib.h
@@ -405,6 +410,7 @@ keymaps.o: $(srcdir)/keymaps.c
 parens.o: $(srcdir)/parens.c
 search.o: $(srcdir)/search.c
 rltty.o: $(srcdir)/rltty.c
+compat.o: $(srcdir)/compat.c
 complete.o: $(srcdir)/complete.c
 bind.o: $(srcdir)/bind.c
 isearch.o: $(srcdir)/isearch.c
@@ -434,6 +440,7 @@ keymaps.o: keymaps.c
 parens.o: parens.c
 search.o: search.c
 rltty.o: rltty.c
+compat.o: compat.c
 complete.o: complete.c
 bind.o: bind.c
 isearch.o: isearch.c
Index: readline/README
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/README,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 README
--- readline/README	2003/02/16 21:36:31	1.1.1.1
+++ readline/README	2001/04/04 18:32:26
@@ -1,7 +1,7 @@
 Introduction
 ============
 
-This is the Gnu Readline library, version 4.1.
+This is the Gnu Readline library, version 4.2.
 
 The Readline library provides a set of functions for use by applications
 that allow users to edit command lines as they are typed in.  Both
@@ -37,6 +37,9 @@ to customize and control the build proce
 The file rlconf.h contains C preprocessor defines that enable and disable
 certain Readline features.
 
+The special make target `everything' will build the static and shared
+libraries (if the target platform supports them) and the examples.
+
 Examples
 ========
 
@@ -64,8 +67,8 @@ your platform.
 If you need to update support/shobj-conf, you will need to create
 a `stanza' for your operating system and compiler.  The script uses
 the value of host_os and ${CC} as determined by configure.  For
-instance, FreeBSD 2.2.5 with any version of gcc is identified as
-`freebsd2.2.5-gcc*'.
+instance, FreeBSD 4.2 using the ELF object file format  with any
+version of gcc is identified as `freebsdelf4.2-gcc*'.
 
 In the stanza for your operating system-compiler pair, you will need to
 define several variables.  They are:
@@ -144,7 +147,7 @@ Bug reports for Readline should be sent 
 
 When reporting a bug, please include the following information:
 
-        * the version number and release status of Readline (e.g., 4.0-release)
+        * the version number and release status of Readline (e.g., 4.2-release)
         * the machine and OS that it is running on
         * a list of the compilation flags or the contents of `config.h', if
           appropriate
Index: readline/aclocal.m4
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/aclocal.m4,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 aclocal.m4
--- readline/aclocal.m4	2003/02/16 21:36:28	1.1.1.1
+++ readline/aclocal.m4	2000/11/21 15:42:10
@@ -1065,17 +1065,19 @@ fi
 ])
 
 AC_DEFUN(BASH_CHECK_GETPW_FUNCS,
-[AC_MSG_CHECKING(whether programs are able to redeclare getpw functions)
-AC_CACHE_VAL(bash_cv_can_redecl_getpw,
-[AC_TRY_COMPILE([#include <sys/types.h>
+[AC_MSG_CHECKING(whether getpw functions are declared in pwd.h)
+AC_CACHE_VAL(bash_cv_getpw_declared,
+[AC_EGREP_CPP(getpwuid,
+[
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
 #include <pwd.h>
-extern struct passwd *getpwent();
-extern struct passwd *getpwuid();
-extern struct passwd *getpwnam();],
-[struct passwd *z; z = getpwent(); z = getpwuid(0); z = getpwnam("root");],
-  bash_cv_can_redecl_getpw=yes,bash_cv_can_redecl_getpw=no)])
-AC_MSG_RESULT($bash_cv_can_redecl_getpw)
-if test $bash_cv_can_redecl_getpw = no; then
+],
+bash_cv_getpw_declared=yes,bash_cv_getpw_declared=no)])
+AC_MSG_RESULT($bash_cv_getpw_declared)
+if test $bash_cv_getpw_declared = yes; then
 AC_DEFINE(HAVE_GETPW_DECLS)
 fi
 ])
@@ -1350,12 +1352,15 @@ dnl causes system calls to be restarted 
 dnl
 AC_DEFUN(BASH_SYS_RESTARTABLE_SYSCALLS,
 [AC_REQUIRE([BASH_SIGNAL_CHECK])
-AC_CACHE_CHECK(for restartable system calls with posix sigaction,
+AC_CACHE_CHECK(whether posix sigaction restarts system calls by default,
 bash_cv_sys_restartable_syscalls,
 [AC_TRY_RUN(
 [/* Exit 0 (true) if wait returns something other than -1,
    i.e. the pid of the child, which means that wait was restarted
    after getting the signal.  */
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
 #include <sys/types.h>
 #include <signal.h>
 static int caught = 0;
@@ -1423,5 +1428,36 @@ AC_EGREP_HEADER(struct timeval, sys/time
 AC_MSG_RESULT($bash_cv_struct_timeval)
 if test $bash_cv_struct_timeval = yes; then
   AC_DEFINE(HAVE_TIMEVAL)
+fi
+])
+
+AC_DEFUN(BASH_CHECK_RTSIGS,
+[AC_MSG_CHECKING(for unusable real-time signals due to large values)
+AC_CACHE_VAL(bash_cv_unusable_rtsigs,
+[AC_TRY_RUN([
+#include <sys/types.h>
+#include <signal.h>
+
+#ifndef NSIG
+#  define NSIG 64
+#endif
+
+main ()
+{
+  int n_sigs = 2 * NSIG;
+#ifdef SIGRTMIN
+  int rtmin = SIGRTMIN;
+#else
+  int rtmin = 0;
+#endif
+
+  exit(rtmin < n_sigs);
+}], bash_cv_unusable_rtsigs=yes, bash_cv_unusable_rtsigs=no,
+    [AC_MSG_WARN(cannot check real-time signals if cross compiling -- defaulting to yes)
+     bash_cv_unusable_rtsigs=yes]
+)])
+AC_MSG_RESULT($bash_cv_unusable_rtsigs)
+if test $bash_cv_unusable_rtsigs = yes; then
+AC_DEFINE(UNUSABLE_RT_SIGNALS)
 fi
 ])
Index: readline/ansi_stdlib.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/ansi_stdlib.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 ansi_stdlib.h
--- readline/ansi_stdlib.h	2003/02/16 21:36:28	1.1.1.1
+++ readline/ansi_stdlib.h	2000/09/07 16:07:49
@@ -27,6 +27,9 @@
 extern int atoi ();
 extern long int atol ();
 
+extern double atof ();
+extern double strtod ();
+
 /* Memory allocation functions. */
 extern char *malloc ();
 extern char *realloc ();
Index: readline/bind.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/bind.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 bind.c
--- readline/bind.c	2003/02/16 21:36:28	1.1.1.1
+++ readline/bind.c	2003/02/17 12:47:09
@@ -48,6 +48,11 @@
 extern int errno;
 #endif /* !errno */
 
+#ifdef __MINGW32__
+#include <sys/stat.h>
+#include <io.h>
+#endif
+
 #include "posixstat.h"
 
 /* System-specific feature definitions and include files. */
@@ -68,9 +73,9 @@ extern char *strchr (), *strrchr ();
 /* Variables exported by this file. */
 Keymap rl_binding_keymap;
 
-static int _rl_read_init_file __P((char *, int));
+static int _rl_read_init_file __P((const char *, int));
 static int glean_key_from_name __P((char *));
-static int substring_member_of_array __P((char *, char **));
+static int substring_member_of_array __P((char *, const char **));
 
 static int currently_reading_init_file;
 
@@ -83,13 +88,13 @@ static int _rl_prefer_visible_bell = 1;
 /*								    */
 /* **************************************************************** */
 
-/* rl_add_defun (char *name, Function *function, int key)
+/* rl_add_defun (char *name, rl_command_func_t *function, int key)
    Add NAME to the list of named functions.  Make FUNCTION be the function
    that gets called.  If KEY is not -1, then bind it. */
 int
 rl_add_defun (name, function, key)
-     char *name;
-     Function *function;
+     const char *name;
+     rl_command_func_t *function;
      int key;
 {
   if (key != -1)
@@ -102,7 +107,7 @@ rl_add_defun (name, function, key)
 int
 rl_bind_key (key, function)
      int key;
-     Function *function;
+     rl_command_func_t *function;
 {
   if (key < 0)
     return (key);
@@ -133,7 +138,7 @@ rl_bind_key (key, function)
 int
 rl_bind_key_in_map (key, function, map)
      int key;
-     Function *function;
+     rl_command_func_t *function;
      Keymap map;
 {
   int result;
@@ -152,7 +157,7 @@ int
 rl_unbind_key (key)
      int key;
 {
-  return (rl_bind_key (key, (Function *)NULL));
+  return (rl_bind_key (key, (rl_command_func_t *)NULL));
 }
 
 /* Make KEY do nothing in MAP.
@@ -162,13 +167,13 @@ rl_unbind_key_in_map (key, map)
      int key;
      Keymap map;
 {
-  return (rl_bind_key_in_map (key, (Function *)NULL, map));
+  return (rl_bind_key_in_map (key, (rl_command_func_t *)NULL, map));
 }
 
 /* Unbind all keys bound to FUNCTION in MAP. */
 int
 rl_unbind_function_in_map (func, map)
-     Function *func;
+     rl_command_func_t *func;
      Keymap map;
 {
   register int i, rval;
@@ -177,7 +182,7 @@ rl_unbind_function_in_map (func, map)
     {
       if (map[i].type == ISFUNC && map[i].function == func)
 	{
-	  map[i].function = (Function *)NULL;
+	  map[i].function = (rl_command_func_t *)NULL;
 	  rval = 1;
 	}
     }
@@ -186,10 +191,10 @@ rl_unbind_function_in_map (func, map)
 
 int
 rl_unbind_command_in_map (command, map)
-     char *command;
+     const char *command;
      Keymap map;
 {
-  Function *func;
+  rl_command_func_t *func;
 
   func = rl_named_function (command);
   if (func == 0)
@@ -202,8 +207,8 @@ rl_unbind_command_in_map (command, map)
    place to do bindings is in MAP. */
 int
 rl_set_key (keyseq, function, map)
-     char *keyseq;
-     Function *function;
+     const char *keyseq;
+     rl_command_func_t *function;
      Keymap map;
 {
   return (rl_generic_bind (ISFUNC, keyseq, (char *)function, map));
@@ -214,7 +219,7 @@ rl_set_key (keyseq, function, map)
    necessary.  The initial place to do bindings is in MAP. */
 int
 rl_macro_bind (keyseq, macro, map)
-     char *keyseq, *macro;
+     const char *keyseq, *macro;
      Keymap map;
 {
   char *macro_keys;
@@ -239,7 +244,8 @@ rl_macro_bind (keyseq, macro, map)
 int
 rl_generic_bind (type, keyseq, data, map)
      int type;
-     char *keyseq, *data;
+     const char *keyseq;
+     char *data;
      Keymap map;
 {
   char *keys;
@@ -309,7 +315,8 @@ rl_generic_bind (type, keyseq, data, map
    non-zero if there was an error parsing SEQ. */
 int
 rl_translate_keyseq (seq, array, len)
-     char *seq, *array;
+     const char *seq;
+     char *array;
      int *len;
 {
   register int i, c, l, temp;
@@ -513,9 +520,9 @@ _rl_untranslate_macro_value (seq)
 /* Return a pointer to the function that STRING represents.
    If STRING doesn't have a matching function, then a NULL pointer
    is returned. */
-Function *
+rl_command_func_t *
 rl_named_function (string)
-     char *string;
+     const char *string;
 {
   register int i;
 
@@ -524,7 +531,7 @@ rl_named_function (string)
   for (i = 0; funmap[i]; i++)
     if (_rl_stricmp (funmap[i]->name, string) == 0)
       return (funmap[i]->function);
-  return ((Function *)NULL);
+  return ((rl_command_func_t *)NULL);
 }
 
 /* Return the function (or macro) definition which would be invoked via
@@ -532,9 +539,9 @@ rl_named_function (string)
    used.  TYPE, if non-NULL, is a pointer to an int which will receive the
    type of the object pointed to.  One of ISFUNC (function), ISKMAP (keymap),
    or ISMACR (macro). */
-Function *
+rl_command_func_t *
 rl_function_of_keyseq (keyseq, map, type)
-     char *keyseq;
+     const char *keyseq;
      Keymap map;
      int *type;
 {
@@ -585,14 +592,14 @@ rl_function_of_keyseq (keyseq, map, type
 	  return (map[ic].function);
 	}
     }
-  return ((Function *) NULL);
+  return ((rl_command_func_t *) NULL);
 }
 
 /* The last key bindings file read. */
 static char *last_readline_init_file = (char *)NULL;
 
 /* The file we're currently reading key bindings from. */
-static char *current_readline_init_file;
+static const char *current_readline_init_file;
 static int current_readline_init_include_level;
 static int current_readline_init_lineno;
 
@@ -659,7 +666,7 @@ rl_re_read_init_file (count, ignore)
      int count, ignore;
 {
   int r;
-  r = rl_read_init_file ((char *)NULL);
+  r = rl_read_init_file ((const char *)NULL);
   rl_set_keymap_from_edit_mode ();
   return r;
 }
@@ -673,14 +680,14 @@ rl_re_read_init_file (count, ignore)
    otherwise errno is returned. */
 int
 rl_read_init_file (filename)
-     char *filename;
+     const char *filename;
 {
   /* Default the filename. */
   if (filename == 0)
     {
       filename = last_readline_init_file;
       if (filename == 0)
-        filename = get_env_value ("INPUTRC");
+        filename = sh_get_env_value ("INPUTRC");
       if (filename == 0)
 	filename = DEFAULT_INPUTRC;
     }
@@ -696,9 +703,13 @@ rl_read_init_file (filename)
   return (_rl_read_init_file (filename, 0));
 }
 
+#ifdef __MINGW32__
+extern char *get_user_registry_string(char *keyName, char* valName);
+#endif
+
 static int
 _rl_read_init_file (filename, include_level)
-     char *filename;
+     const char *filename;
      int include_level;
 {
   register int i;
@@ -712,6 +723,18 @@ _rl_read_init_file (filename, include_le
   buffer = _rl_read_file (openname, &file_size);
   free (openname);
 
+#if defined (__MINGW32__) && defined (INITFILES_IN_REGISTRY)
+  if (buffer == 0)
+    {
+      openname = get_user_registry_string(READLINE_REGKEY, INPUTRC_REGVAL);
+      if (openname)
+        {
+          buffer = _rl_read_file (openname, &file_size);
+          free (openname);
+        }
+    }
+#endif	/* __MINGW32__ */
+
   if (buffer == 0)
     return (errno);
   
@@ -733,7 +756,7 @@ _rl_read_init_file (filename, include_le
       /* Find the end of this line. */
       for (i = 0; line + i != end && line[i] != '\n'; i++);
 
-#if defined (__CYGWIN32__)
+#if defined (__CYGWIN__)
       /* ``Be liberal in what you accept.'' */
       if (line[i] == '\n' && line[i-1] == '\r')
 	line[i - 1] = '\0';
@@ -780,10 +803,21 @@ _rl_init_file_error (msg)
 /*								    */
 /* **************************************************************** */
 
+typedef int _rl_parser_func_t __P((char *));
+
+/* Things that mean `Control'. */
+const char *_rl_possible_control_prefixes[] = {
+  "Control-", "C-", "CTRL-", (const char *)NULL
+};
+
+const char *_rl_possible_meta_prefixes[] = {
+  "Meta", "M-", (const char *)NULL
+};
+
 /* Conditionals. */
 
 /* Calling programs set this to have their argv[0]. */
-char *rl_readline_name = "other";
+const char *rl_readline_name = "other";
 
 /* Stack of previous values of parsing_conditionalized_out. */
 static unsigned char *if_stack = (unsigned char *)NULL;
@@ -905,7 +939,8 @@ static int
 parser_include (args)
      char *args;
 {
-  char *old_init_file, *e;
+  const char *old_init_file;
+  char *e;
   int old_line_number, old_include_level, r;
 
   if (_rl_parsing_conditionalized_out)
@@ -918,7 +953,7 @@ parser_include (args)
   e = strchr (args, '\n');
   if (e)
     *e = '\0';
-  r = _rl_read_init_file (args, old_include_level + 1);
+  r = _rl_read_init_file ((const char *)args, old_include_level + 1);
 
   current_readline_init_file = old_init_file;
   current_readline_init_lineno = old_line_number;
@@ -929,14 +964,14 @@ parser_include (args)
   
 /* Associate textual names with actual functions. */
 static struct {
-  char *name;
-  Function *function;
+  const char *name;
+  _rl_parser_func_t *function;
 } parser_directives [] = {
   { "if", parser_if },
   { "endif", parser_endif },
   { "else", parser_else },
   { "include", parser_include },
-  { (char *)0x0, (Function *)0x0 }
+  { (char *)0x0, (_rl_parser_func_t *)0x0 }
 };
 
 /* Handle a parser directive.  STATEMENT is the line of the directive
@@ -1180,10 +1215,10 @@ rl_parse_and_bind (string)
   key = glean_key_from_name (kname);
 
   /* Add in control and meta bits. */
-  if (substring_member_of_array (string, possible_control_prefixes))
+  if (substring_member_of_array (string, _rl_possible_control_prefixes))
     key = CTRL (_rl_to_upper (key));
 
-  if (substring_member_of_array (string, possible_meta_prefixes))
+  if (substring_member_of_array (string, _rl_possible_meta_prefixes))
     key = META (key);
 
   /* Temporary.  Handle old-style keyname with macro-binding. */
@@ -1221,7 +1256,7 @@ rl_parse_and_bind (string)
 #define V_SPECIAL	0x1
 
 static struct {
-  char *name;
+  const char *name;
   int *value;
   int flags;
 } boolean_varlist [] = {
@@ -1265,7 +1300,7 @@ static void
 hack_special_boolean_var (i)
      int i;
 {
-  char *name;
+  const char *name;
 
   name = boolean_varlist[i].name;
 
@@ -1280,6 +1315,8 @@ hack_special_boolean_var (i)
     }
 }
 
+typedef int _rl_sv_func_t __P((const char *));
+
 /* These *must* correspond to the array indices for the appropriate
    string variable.  (Though they're not used right now.) */
 #define V_BELLSTYLE	0
@@ -1292,17 +1329,17 @@ hack_special_boolean_var (i)
 #define V_INT		2
 
 /* Forward declarations */
-static int sv_bell_style __P((char *));
-static int sv_combegin __P((char *));
-static int sv_compquery __P((char *));
-static int sv_editmode __P((char *));
-static int sv_isrchterm __P((char *));
-static int sv_keymap __P((char *));
+static int sv_bell_style __P((const char *));
+static int sv_combegin __P((const char *));
+static int sv_compquery __P((const char *));
+static int sv_editmode __P((const char *));
+static int sv_isrchterm __P((const char *));
+static int sv_keymap __P((const char *));
 
 static struct {
-  char *name;
+  const char *name;
   int flags;
-  Function *set_func;
+  _rl_sv_func_t *set_func;
 } string_varlist[] = {
   { "bell-style",	V_STRING,	sv_bell_style },
   { "comment-begin",	V_STRING,	sv_combegin },
@@ -1339,7 +1376,7 @@ bool_to_int (value)
 
 int
 rl_variable_bind (name, value)
-     char *name, *value;
+     const char *name, *value;
 {
   register int i;
   int	v;
@@ -1367,7 +1404,7 @@ rl_variable_bind (name, value)
 
 static int
 sv_editmode (value)
-     char *value;
+     const char *value;
 {
   if (_rl_strnicmp (value, "vi", 2) == 0)
     {
@@ -1388,7 +1425,7 @@ sv_editmode (value)
 
 static int
 sv_combegin (value)
-     char *value;
+     const char *value;
 {
   if (value && *value)
     {
@@ -1401,7 +1438,7 @@ sv_combegin (value)
 
 static int
 sv_compquery (value)
-     char *value;
+     const char *value;
 {
   int nval = 100;
 
@@ -1417,7 +1454,7 @@ sv_compquery (value)
 
 static int
 sv_keymap (value)
-     char *value;
+     const char *value;
 {
   Keymap kmap;
 
@@ -1434,7 +1471,7 @@ sv_keymap (value)
 
 static int
 sv_bell_style (value)
-     char *value;
+     const char *value;
 {
   if (value == 0 || *value == '\0')
     _SET_BELL (AUDIBLE_BELL);
@@ -1451,7 +1488,7 @@ sv_bell_style (value)
 
 static int
 sv_isrchterm (value)
-     char *value;
+     const char *value;
 {
   int beg, end, delim;
   char *v;
@@ -1489,7 +1526,7 @@ sv_isrchterm (value)
    For example, `Space' returns ' '. */
 
 typedef struct {
-  char *name;
+  const char *name;
   int value;
 } assoc_list;
 
@@ -1523,7 +1560,7 @@ glean_key_from_name (name)
 
 /* Auxiliary functions to manage keymaps. */
 static struct {
-  char *name;
+  const char *name;
   Keymap map;
 } keymap_names[] = {
   { "emacs", emacs_standard_keymap },
@@ -1541,12 +1578,12 @@ static struct {
 
 Keymap
 rl_get_keymap_by_name (name)
-     char *name;
+     const char *name;
 {
   register int i;
 
   for (i = 0; keymap_names[i].name; i++)
-    if (strcmp (name, keymap_names[i].name) == 0)
+    if (_rl_stricmp (name, keymap_names[i].name) == 0)
       return (keymap_names[i].map);
   return ((Keymap) NULL);
 }
@@ -1558,7 +1595,7 @@ rl_get_keymap_name (map)
   register int i;
   for (i = 0; keymap_names[i].name; i++)
     if (map == keymap_names[i].map)
-      return (keymap_names[i].name);
+      return ((char *)keymap_names[i].name);
   return ((char *)NULL);
 }
   
@@ -1616,7 +1653,7 @@ void
 rl_list_funmap_names ()
 {
   register int i;
-  char **funmap_names;
+  const char **funmap_names;
 
   funmap_names = rl_funmap_names ();
 
@@ -1706,7 +1743,7 @@ _rl_get_keyname (key)
    sequences that are used to invoke FUNCTION in MAP. */
 char **
 rl_invoking_keyseqs_in_map (function, map)
-     Function *function;
+     rl_command_func_t *function;
      Keymap map;
 {
   register int key;
@@ -1806,7 +1843,7 @@ rl_invoking_keyseqs_in_map (function, ma
    sequences that can be used to invoke FUNCTION using the current keymap. */
 char **
 rl_invoking_keyseqs (function)
-     Function *function;
+     rl_command_func_t *function;
 {
   return (rl_invoking_keyseqs_in_map (function, _rl_keymap));
 }
@@ -1819,8 +1856,8 @@ rl_function_dumper (print_readably)
      int print_readably;
 {
   register int i;
-  char **names;
-  char *name;
+  const char **names;
+  const char *name;
 
   names = rl_funmap_names ();
 
@@ -1828,7 +1865,7 @@ rl_function_dumper (print_readably)
 
   for (i = 0; name = names[i]; i++)
     {
-      Function *function;
+      rl_command_func_t *function;
       char **invokers;
 
       function = rl_named_function (name);
@@ -1985,7 +2022,7 @@ rl_variable_dumper (print_readably)
      int print_readably;
 {
   int i;
-  char *kname;
+  const char *kname;
 
   for (i = 0; boolean_varlist[i].name; i++)
     {
@@ -2073,10 +2110,10 @@ rl_dump_variables (count, key)
 /* Bind key sequence KEYSEQ to DEFAULT_FUNC if KEYSEQ is unbound. */
 void
 _rl_bind_if_unbound (keyseq, default_func)
-     char *keyseq;
-     Function *default_func;
+     const char *keyseq;
+     rl_command_func_t *default_func;
 {
-  Function *func;
+  rl_command_func_t *func;
 
   if (keyseq)
     {
@@ -2089,7 +2126,8 @@ _rl_bind_if_unbound (keyseq, default_fun
 /* Return non-zero if any members of ARRAY are a substring in STRING. */
 static int
 substring_member_of_array (string, array)
-     char *string, **array;
+     char *string;
+     const char **array;
 {
   while (*array)
     {
Index: readline/callback.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/callback.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 callback.c
--- readline/callback.c	2003/02/16 21:36:29	1.1.1.1
+++ readline/callback.c	2003/02/17 12:47:09
@@ -31,6 +31,7 @@
 
 #include <sys/types.h>
 #include <stdio.h>
+#include <stdlib.h>
 
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
@@ -52,7 +53,7 @@
    text read in at each end of line.  The terminal is kept prepped and
    signals handled all the time, except during calls to the user's function. */
 
-VFunction *rl_linefunc;		/* user callback function */
+rl_vcpfunc_t *rl_linefunc;		/* user callback function */
 static int in_handler;		/* terminal_prepped and signals set? */
 
 /* Make sure the terminal is set up, initialize readline, and prompt. */
@@ -78,11 +79,10 @@ _rl_callback_newline ()
 /* Install a readline handler, set up the terminal, and issue the prompt. */
 void
 rl_callback_handler_install (prompt, linefunc)
-     char *prompt;
-     VFunction *linefunc;
+     const char *prompt;
+     rl_vcpfunc_t *linefunc;
 {
-  rl_prompt = prompt;
-  rl_visible_prompt_length = rl_prompt ? rl_expand_prompt (rl_prompt) : 0;
+  rl_set_prompt (prompt);
   rl_linefunc = linefunc;
   _rl_callback_newline ();
 }
@@ -102,24 +102,33 @@ rl_callback_read_char ()
 
   eof = readline_internal_char ();
 
-  if (rl_done)
+  /* We loop in case some function has pushed input back with rl_execute_next. */
+  for (;;)
     {
-      line = readline_internal_teardown (eof);
+      if (rl_done)
+	{
+	  line = readline_internal_teardown (eof);
 
-      (*rl_deprep_term_function) ();
+	  (*rl_deprep_term_function) ();
 #if defined (HANDLE_SIGNALS)
-      rl_clear_signals ();
+	  rl_clear_signals ();
 #endif
-      in_handler = 0;
-      (*rl_linefunc) (line);
+	  in_handler = 0;
+	  (*rl_linefunc) (line);
 
-    /* If the user did not clear out the line, do it for him. */
-    if (rl_line_buffer[0])
-      _rl_init_line_state ();
-
-    /* Redisplay the prompt if readline_handler_{install,remove} not called. */
-      if (in_handler == 0 && rl_linefunc)
-	_rl_callback_newline ();
+	  /* If the user did not clear out the line, do it for him. */
+	  if (rl_line_buffer[0])
+	    _rl_init_line_state ();
+
+	  /* Redisplay the prompt if readline_handler_{install,remove}
+	     not called. */
+	  if (in_handler == 0 && rl_linefunc)
+	    _rl_callback_newline ();
+	}
+      if (rl_pending_input)
+	eof = readline_internal_char ();
+      else
+        break;
     }
 }
 
Index: readline/chardefs.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/chardefs.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 chardefs.h
--- readline/chardefs.h	2003/02/16 21:36:29	1.1.1.1
+++ readline/chardefs.h	2003/02/17 12:47:09
@@ -46,12 +46,19 @@
 /* Some character stuff. */
 #define control_character_threshold 0x020   /* Smaller than this is control. */
 #define control_character_mask 0x1f	    /* 0x20 - 1 */
-#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
 #define control_character_bit 0x40	    /* 0x000000, must be off. */
+
+#ifndef __MINGW32__
+#define meta_character_threshold 0x07f	    /* Larger than this is Meta. */
 #define meta_character_bit 0x080	    /* x0000000, must be on. */
 #define largest_char 255		    /* Largest character value. */
+#else
+#define meta_character_threshold 0x0ff	    /* Larger than this is Meta. */
+#define meta_character_bit 0x100	    /* x0000000, must be on. */
+#define largest_char 0x1ff		    /* Largest character value. */
+#endif
 
-#define CTRL_CHAR(c) ((c) < control_character_threshold && (c) >= 0)
+#define CTRL_CHAR(c) ((c) < control_character_threshold && (((c) & 0x80) == 0))
 #define META_CHAR(c) ((c) > meta_character_threshold && (c) <= largest_char)
 
 #define CTRL(c) ((c) & control_character_mask)
Index: readline/complete.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/complete.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 complete.c
--- readline/complete.c	2003/02/16 21:36:29	1.1.1.1
+++ readline/complete.c	2003/02/17 12:47:09
@@ -42,25 +42,19 @@
 #endif /* HAVE_STDLIB_H */
 
 #include <stdio.h>
+#ifdef __MINGW32__
+# include <windows.h>
+# include <io.h>
+#endif
 
 #include <errno.h>
 #if !defined (errno)
 extern int errno;
 #endif /* !errno */
 
+#ifndef __MINGW32__
 #include <pwd.h>
-#if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwent ();
-#endif /* USG && !HAVE_GETPW_DECLS */
-
-/* ISC systems don't define getpwent() if _POSIX_SOURCE is defined. */
-#if defined (isc386) && defined (_POSIX_SOURCE)
-#  if defined (__STDC__)
-extern struct passwd *getpwent (void);
-#  else
-extern struct passwd *getpwent ();
-#  endif /* !__STDC__ */
-#endif /* isc386 && _POSIX_SOURCE */
+#endif
 
 #include "posixdir.h"
 #include "posixstat.h"
@@ -79,6 +73,12 @@ typedef int QSFUNC (const void *, const 
 typedef int QSFUNC ();
 #endif
 
+/* Most systems don't declare getpwent in <pwd.h> if _POSIX_SOURCE is
+   defined. */
+#if !defined (HAVE_GETPW_DECLS) || defined (_POSIX_SOURCE)
+extern struct passwd *getpwent __P((void));
+#endif /* !HAVE_GETPW_DECLS || _POSIX_SOURCE */
+
 /* If non-zero, then this is the address of a function to call when
    completing a word would normally display the list of possible matches.
    This function is called instead of actually doing the display.
@@ -86,11 +86,7 @@ typedef int QSFUNC ();
    where MATCHES is the array of strings that matched, NUM_MATCHES is the
    number of strings in that array, and MAX_LENGTH is the length of the
    longest string in that array. */
-VFunction *rl_completion_display_matches_hook = (VFunction *)NULL;
-
-/* Forward declarations for functions defined and used in this file. */
-char *filename_completion_function __P((char *, int));
-char **completion_matches __P((char *, CPFunction *));
+rl_compdisp_func_t *rl_completion_display_matches_hook = (rl_compdisp_func_t *)NULL;
 
 #if defined (VISIBLE_STATS)
 #  if !defined (X_OK)
@@ -100,14 +96,13 @@ static int stat_char __P((char *));
 #endif
 
 static char *rl_quote_filename __P((char *, int, char *));
-static char *rl_strpbrk __P((char *, char *));
 
 static char **remove_duplicate_matches __P((char **));
 static void insert_match __P((char *, int, int, char *));
 static int append_to_match __P((char *, int, int));
 static void insert_all_matches __P((char **, int, char *));
 static void display_matches __P((char **));
-static int compute_lcd_of_matches __P((char **, int, char *));
+static int compute_lcd_of_matches __P((char **, int, const char *));
 
 /* **************************************************************** */
 /*								    */
@@ -146,15 +141,17 @@ int rl_visible_stats = 0;
 /* If non-zero, then this is the address of a function to call when
    completing on a directory name.  The function is called with
    the address of a string (the current directory name) as an arg. */
-Function *rl_directory_completion_hook = (Function *)NULL;
+rl_icppfunc_t *rl_directory_completion_hook = (rl_icppfunc_t *)NULL;
 
+rl_icppfunc_t *rl_directory_rewrite_hook = (rl_icppfunc_t *)NULL;
+
 /* Non-zero means readline completion functions perform tilde expansion. */
 int rl_complete_with_tilde_expansion = 0;
 
 /* Pointer to the generator function for completion_matches ().
-   NULL means to use filename_completion_function (), the default filename
+   NULL means to use rl_filename_completion_function (), the default filename
    completer. */
-Function *rl_completion_entry_function = (Function *)NULL;
+rl_compentry_func_t *rl_completion_entry_function = (rl_compentry_func_t *)NULL;
 
 /* Pointer to alternative function to create matches.
    Function is called with TEXT, START, and END.
@@ -163,7 +160,7 @@ Function *rl_completion_entry_function =
    If this function exists and returns NULL then call the value of
    rl_completion_entry_function to try to match, otherwise use the
    array of strings returned. */
-CPPFunction *rl_attempted_completion_function = (CPPFunction *)NULL;
+rl_completion_func_t *rl_attempted_completion_function = (rl_completion_func_t *)NULL;
 
 /* Non-zero means to suppress normal filename completion after the
    user-specified completion function has been called. */
@@ -182,29 +179,29 @@ int rl_completion_query_items = 100;
 /* The basic list of characters that signal a break between words for the
    completer routine.  The contents of this variable is what breaks words
    in the shell, i.e. " \t\n\"\\'`@$><=" */
-char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
+const char *rl_basic_word_break_characters = " \t\n\"\\'`@$><=;|&{(";
 
 /* List of basic quoting characters. */
-char *rl_basic_quote_characters = "\"'";
+const char *rl_basic_quote_characters = "\"'";
 
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-char *rl_completer_word_break_characters = (char *)NULL;
+const char *rl_completer_word_break_characters = (const char *)NULL;
 
 /* List of characters which can be used to quote a substring of the line.
    Completion occurs on the entire substring, and within the substring
    rl_completer_word_break_characters are treated as any other character,
    unless they also appear within this list. */
-char *rl_completer_quote_characters = (char *)NULL;
+const char *rl_completer_quote_characters = (const char *)NULL;
 
 /* List of characters that should be quoted in filenames by the completer. */
-char *rl_filename_quote_characters = (char *)NULL;
+const char *rl_filename_quote_characters = (const char *)NULL;
 
 /* List of characters that are word break characters, but should be left
    in TEXT when it is passed to the completion function.  The shell uses
    this to help determine what kind of completing to do. */
-char *rl_special_prefixes = (char *)NULL;
+const char *rl_special_prefixes = (const char *)NULL;
 
 /* If non-zero, then disallow duplicates in the matches. */
 int rl_ignore_completion_duplicates = 1;
@@ -230,24 +227,24 @@ int rl_filename_quoting_desired = 1;
    the list of matches as required, but all elements of the array must be
    free()'d if they are deleted. The main intent of this function is
    to implement FIGNORE a la SunOS csh. */
-Function *rl_ignore_some_completions_function = (Function *)NULL;
+rl_compignore_func_t *rl_ignore_some_completions_function = (rl_compignore_func_t *)NULL;
 
 /* Set to a function to quote a filename in an application-specific fashion.
    Called with the text to quote, the type of match found (single or multiple)
    and a pointer to the quoting character to be used, which the function can
    reset if desired. */
-CPFunction *rl_filename_quoting_function = rl_quote_filename;
+rl_quote_func_t *rl_filename_quoting_function = rl_quote_filename;
          
 /* Function to call to remove quoting characters from a filename.  Called
    before completion is attempted, so the embedded quotes do not interfere
    with matching names in the file system.  Readline doesn't do anything
    with this; it's set only by applications. */
-CPFunction *rl_filename_dequoting_function = (CPFunction *)NULL;
+rl_dequote_func_t *rl_filename_dequoting_function = (rl_dequote_func_t *)NULL;
 
 /* Function to call to decide whether or not a word break character is
    quoted.  If a character is quoted, it does not break words for the
    completer. */
-Function *rl_char_is_quoted_p = (Function *)NULL;
+rl_linebuf_func_t *rl_char_is_quoted_p = (rl_linebuf_func_t *)NULL;
 
 /* Character appended to completed words when at the end of the line.  The
    default is a space. */
@@ -269,7 +266,7 @@ static int completion_changed_buffer;
 
 /* Complete the word at or before point.  You have supplied the function
    that does the initial simple matching selection algorithm (see
-   completion_matches ()).  The default is to do filename completion. */
+   rl_completion_matches ()).  The default is to do filename completion. */
 int
 rl_complete (ignore, invoking_key)
      int ignore, invoking_key;
@@ -305,27 +302,6 @@ rl_insert_completions (ignore, invoking_
 /*				    */
 /************************************/
 
-/* Find the first occurrence in STRING1 of any character from STRING2.
-   Return a pointer to the character in STRING1. */
-static char *
-rl_strpbrk (string1, string2)
-     char *string1, *string2;
-{
-  register char *scan;
-
-  for (; *string1; string1++)
-    {
-      for (scan = string2; *scan; scan++)
-	{
-	  if (*string1 == *scan)
-	    {
-	      return (string1);
-	    }
-	}
-    }
-  return ((char *)NULL);
-}
-
 /* The user must press "y" or "n". Non-zero return means "y" pressed. */
 static int
 get_y_or_n ()
@@ -334,14 +310,17 @@ get_y_or_n ()
 
   for (;;)
     {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
       if (c == 'y' || c == 'Y' || c == ' ')
 	return (1);
       if (c == 'n' || c == 'N' || c == RUBOUT)
 	return (0);
       if (c == ABORT_CHAR)
 	_rl_abort_internal ();
-      ding ();
+      rl_ding ();
     }
 }
 
@@ -571,7 +550,11 @@ find_completion_word (fp, dp)
 	      continue;
 	    }
 
-	  if (rl_line_buffer[scan] == '\\')
+	  /* Shell-like semantics for single quotes -- don't allow backslash
+	     to quote anything in single quotes, especially not the closing
+	     quote.  If you don't like this, take out the check on the value
+	     of quote_char. */
+	  if (quote_char != '\'' && rl_line_buffer[scan] == '\\')
 	    {
 	      pass_next = 1;
 	      found_quote |= RL_QF_BACKSLASH;
@@ -671,7 +654,7 @@ static char **
 gen_completion_matches (text, start, end, our_func, found_quote, quote_char)
      char *text;
      int start, end;
-     Function *our_func;
+     rl_compentry_func_t *our_func;
      int found_quote, quote_char;
 {
   char **matches, *temp;
@@ -695,7 +678,7 @@ gen_completion_matches (text, start, end
      filename dequoting function. */
   temp = (char *)NULL;
 
-  if (found_quote && our_func == (Function *)filename_completion_function &&
+  if (found_quote && our_func == rl_filename_completion_function &&
       rl_filename_dequoting_function)
     {
       /* delete single and double quotes */
@@ -703,7 +686,7 @@ gen_completion_matches (text, start, end
       text = temp;	/* not freeing text is not a memory leak */
     }
 
-  matches = completion_matches (text, (CPFunction *)our_func);
+  matches = rl_completion_matches (text, our_func);
   FREE (temp);
   return matches;  
 }
@@ -775,7 +758,7 @@ static int
 compute_lcd_of_matches (match_list, matches, text)
      char **match_list;
      int matches;
-     char *text;
+     const char *text;
 {
   register int i, c1, c2, si;
   int low;		/* Count of max-matched characters. */
@@ -901,11 +884,11 @@ rl_display_match_list (matches, len, max
 
   /* How many items of MAX length can we fit in the screen window? */
   max += 2;
-  limit = screenwidth / max;
-  if (limit != 1 && (limit * max == screenwidth))
+  limit = _rl_screenwidth / max;
+  if (limit != 1 && (limit * max == _rl_screenwidth))
     limit--;
 
-  /* Avoid a possible floating exception.  If max > screenwidth,
+  /* Avoid a possible floating exception.  If max > _rl_screenwidth,
      limit will be 0 and a divide-by-zero fault will result. */
   if (limit == 0)
     limit = 1;
@@ -921,7 +904,7 @@ rl_display_match_list (matches, len, max
   if (rl_ignore_completion_duplicates == 0)
     qsort (matches + 1, len, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
 
-  crlf ();
+  rl_crlf ();
 
   if (_rl_print_completions_horizontally == 0)
     {
@@ -943,7 +926,7 @@ rl_display_match_list (matches, len, max
 		}
 	      l += count;
 	    }
-	  crlf ();
+	  rl_crlf ();
 	}
     }
   else
@@ -957,13 +940,13 @@ rl_display_match_list (matches, len, max
 	  if (matches[i+1])
 	    {
 	      if (i && (limit > 1) && (i % limit) == 0)
-		crlf ();
+		rl_crlf ();
 	      else
 		for (k = 0; k < max - printed_len; k++)
 		  putc (' ', rl_outstream);
 	    }
 	}
-      crlf ();
+      rl_crlf ();
     }
 }
 
@@ -992,9 +975,9 @@ display_matches (matches)
   if (matches[1] == 0)
     {
       temp = printable_part (matches[0]);
-      crlf ();
+      rl_crlf ();
       print_filename (temp, matches[0]);
-      crlf ();
+      rl_crlf ();
 
       rl_forced_update_display ();
       rl_display_fixed = 1;
@@ -1026,12 +1009,12 @@ display_matches (matches)
      see them all. */
   if (len >= rl_completion_query_items)
     {
-      crlf ();
+      rl_crlf ();
       fprintf (rl_outstream, "Display all %d possibilities? (y or n)", len);
       fflush (rl_outstream);
       if (get_y_or_n () == 0)
 	{
-	  crlf ();
+	  rl_crlf ();
 
 	  rl_forced_update_display ();
 	  rl_display_fixed = 1;
@@ -1079,7 +1062,7 @@ make_quoted_replacement (match, mtype, q
          This also checks whether the common prefix of several
 	 matches needs to be quoted. */
       should_quote = rl_filename_quote_characters
-			? (rl_strpbrk (match, rl_filename_quote_characters) != 0)
+			? (_rl_strpbrk (match, rl_filename_quote_characters) != 0)
 			: 0;
 
       do_replace = should_quote ? mtype : NO_MATCH;
@@ -1232,11 +1215,12 @@ rl_complete_internal (what_to_do)
      int what_to_do;
 {
   char **matches;
-  Function *our_func;
+  rl_compentry_func_t *our_func;
   int start, end, delimiter, found_quote, i;
   char *text, *saved_line_buffer;
   char quote_char;
 
+  RL_SETSTATE(RL_STATE_COMPLETING);
   /* Only the completion entry function can change these. */
   rl_filename_completion_desired = 0;
   rl_filename_quoting_desired = 1;
@@ -1245,7 +1229,7 @@ rl_complete_internal (what_to_do)
   saved_line_buffer = rl_line_buffer ? savestring (rl_line_buffer) : (char *)NULL;
   our_func = rl_completion_entry_function
 		? rl_completion_entry_function
-		: (Function *)filename_completion_function;
+		: rl_filename_completion_function;
 
   /* We now look backwards for the start of a filename/variable word. */
   end = rl_point;
@@ -1266,27 +1250,23 @@ rl_complete_internal (what_to_do)
 
   if (matches == 0)
     {
-      ding ();
+      rl_ding ();
       FREE (saved_line_buffer);
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
       return (0);
     }
 
-#if 0
-  /* If we are matching filenames, our_func will have been set to
-     filename_completion_function */
-  i = our_func == (Function *)filename_completion_function;
-#else
   /* If we are matching filenames, the attempted completion function will
      have set rl_filename_completion_desired to a non-zero value.  The basic
-     filename_completion_function does this. */
+     rl_filename_completion_function does this. */
   i = rl_filename_completion_desired;
-#endif
 
   if (postprocess_matches (&matches, i) == 0)
     {
-      ding ();
+      rl_ding ();
       FREE (saved_line_buffer);
       completion_changed_buffer = 0;
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
       return (0);
     }
 
@@ -1314,7 +1294,7 @@ rl_complete_internal (what_to_do)
 	      break;
 	    }
 	  else if (rl_editing_mode != vi_mode)
-	    ding ();	/* There are other matches remaining. */
+	    rl_ding ();	/* There are other matches remaining. */
 	}
       else
 	append_to_match (matches[0], delimiter, quote_char);
@@ -1331,8 +1311,9 @@ rl_complete_internal (what_to_do)
 
     default:
       fprintf (stderr, "\r\nreadline: bad value %d for what_to_do in rl_complete\n", what_to_do);
-      ding ();
+      rl_ding ();
       FREE (saved_line_buffer);
+      RL_UNSETSTATE(RL_STATE_COMPLETING);
       return 1;
     }
 
@@ -1345,6 +1326,7 @@ rl_complete_internal (what_to_do)
       free (saved_line_buffer);
     }
 
+  RL_UNSETSTATE(RL_STATE_COMPLETING);
   return 0;
 }
 
@@ -1367,9 +1349,9 @@ rl_complete_internal (what_to_do)
      when there are no more matches.
  */
 char **
-completion_matches (text, entry_function)
-     char *text;
-     CPFunction *entry_function;
+rl_completion_matches (text, entry_function)
+     const char *text;
+     rl_compentry_func_t *entry_function;
 {
   /* Number of slots in match_list. */
   int match_list_size;
@@ -1414,15 +1396,20 @@ completion_matches (text, entry_function
    TEXT contains a partial username preceded by a random
    character (usually `~').  */
 char *
-username_completion_function (text, state)
-     char *text;
+rl_username_completion_function (text, state)
+     const char *text;
      int state;
 {
 #if defined (__WIN32__) || defined (__OPENNT)
   return (char *)NULL;
 #else /* !__WIN32__ && !__OPENNT) */
   static char *username = (char *)NULL;
+#ifndef __MINGW32__
   static struct passwd *entry;
+#else
+  char UserName[128];
+  unsigned UserLen;
+#endif
   static int namelen, first_char, first_char_loc;
   char *value;
 
@@ -1435,9 +1422,12 @@ username_completion_function (text, stat
 
       username = savestring (&text[first_char_loc]);
       namelen = strlen (username);
+#ifndef __MINGW32__
       setpwent ();
+#endif
     }
 
+#ifndef __MINGW32__
   while (entry = getpwent ())
     {
       /* Null usernames should result in all users as possible completions. */
@@ -1463,6 +1453,21 @@ username_completion_function (text, stat
 
       return (value);
     }
+#else /* __MINGW32__ */
+  if (GetUserName (UserName, &UserLen))
+    {
+      if (namelen == 0 || (!strnicmp (username, UserName, namelen)))
+	{
+	  value = xmalloc (2 + strlen (UserName));
+	  *value = *text;
+	  strcpy (value + first_char_loc, UserName);
+	  if (first_char == '~')
+	    rl_filename_completion_desired = 1;
+	  return (value);
+	}
+    }
+  return ((char *)NULL);
+#endif /* __MINGW32__ */
 #endif /* !__WIN32__ && !__OPENNT */
 }
 
@@ -1471,18 +1476,26 @@ username_completion_function (text, stat
    because of all the pathnames that must be followed when looking up the
    completion for a command. */
 char *
-filename_completion_function (text, state)
-     char *text;
+rl_filename_completion_function (text, state)
+     const char *text;
      int state;
 {
+#ifdef __MINGW32__
+  static WIN32_FIND_DATA entry;
+  static HANDLE directory = NULL;
+  static BOOL found = 0;
+  char tmp[MAX_PATH];
+# define DIR void
+#else
+  struct dirent *entry;
   static DIR *directory = (DIR *)NULL;
+#endif
   static char *filename = (char *)NULL;
   static char *dirname = (char *)NULL;
   static char *users_dirname = (char *)NULL;
   static int filename_len;
   char *temp;
   int dirlen;
-  struct dirent *entry;
 
   /* If we don't have any state, then do some initialization. */
   if (state == 0)
@@ -1542,13 +1555,27 @@ filename_completion_function (text, stat
 	  dirname = temp;
 	}
 
+      if (rl_directory_rewrite_hook)
+	(*rl_directory_rewrite_hook) (&dirname);
+
       if (rl_directory_completion_hook && (*rl_directory_completion_hook) (&dirname))
 	{
 	  free (users_dirname);
 	  users_dirname = savestring (dirname);
 	}
 
+#ifdef __MINGW32__
+      strcpy (tmp, dirname);
+      if (tmp[strlen (tmp) - 1] == '/')
+	strcat (tmp, "*");
+      else
+	strcat (tmp, "/*");
+	
+      directory = FindFirstFile (tmp, &entry);
+      found = 1;
+#else  
       directory = opendir (dirname);
+#endif
       filename_len = strlen (filename);
 
       rl_filename_completion_desired = 1;
@@ -1561,17 +1588,20 @@ filename_completion_function (text, stat
   /* *** UNIMPLEMENTED *** */
 
   /* Now that we have some state, we can read the directory. */
-
+#ifndef __MINGW32__
   entry = (struct dirent *)NULL;
   while (directory && (entry = readdir (directory)))
+#else
+  while (directory != INVALID_HANDLE_VALUE && directory && found)
+#endif
     {
       /* Special case for no filename.
 	 All entries except "." and ".." match. */
       if (filename_len == 0)
 	{
-	  if (entry->d_name[0] != '.' ||
-	       (entry->d_name[1] &&
-		 (entry->d_name[1] != '.' || entry->d_name[2])))
+	  if (FILENAME(entry)[0] != '.' ||
+	      (FILENAME(entry)[1] &&
+	       (FILENAME(entry)[1] != '.' || FILENAME(entry)[2])))
 	    break;
 	}
       else
@@ -1580,22 +1610,29 @@ filename_completion_function (text, stat
 	     it is a match. */
 	  if (_rl_completion_case_fold)
 	    {
-	      if ((_rl_to_lower (entry->d_name[0]) == _rl_to_lower (filename[0])) &&
+	      if ((_rl_to_lower (FILENAME(entry)[0]) == _rl_to_lower (filename[0])) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (_rl_strnicmp (filename, entry->d_name, filename_len) == 0))
+		  (_rl_strnicmp (filename, FILENAME(entry), filename_len) == 0))
 		break;
 	    }
 	  else
 	    {
-	      if ((entry->d_name[0] == filename[0]) &&
+	      if ((FILENAME(entry)[0] == filename[0]) &&
 		  (((int)D_NAMLEN (entry)) >= filename_len) &&
-		  (strncmp (filename, entry->d_name, filename_len) == 0))
+		  (strncmp (filename, FILENAME(entry), filename_len) == 0))
 		break;
 	    }
 	}
+#ifdef __MINGW32__
+      found = FindNextFile (directory, &entry);
+#endif    
     }
 
+#ifdef __MINGW32__
+  if (!found)
+#else
   if (entry == 0)
+#endif
     {
       if (directory)
 	{
@@ -1641,15 +1678,21 @@ filename_completion_function (text, stat
 	  else
 	    {
 	      dirlen = strlen (users_dirname);
-	      temp = xmalloc (1 + dirlen + D_NAMLEN (entry));
+	      temp = xmalloc (2 + dirlen + D_NAMLEN (entry));
 	      strcpy (temp, users_dirname);
+	      /* Make sure that temp has a trailing slash here. */
+	      if (users_dirname[dirlen - 1] != '/')
+		temp[dirlen++] = '/';
 	    }
 
-	  strcpy (temp + dirlen, entry->d_name);
+	  strcpy (temp + dirlen, FILENAME(entry));
 	}
       else
-	temp = savestring (entry->d_name);
+	temp = savestring (FILENAME(entry));
 
+#ifdef __MINGW32__
+      found = FindNextFile (directory, &entry);
+#endif
       return (temp);
     }
 }
@@ -1667,7 +1710,7 @@ int
 rl_menu_complete (count, ignore)
      int count, ignore;
 {
-  Function *our_func;
+  rl_compentry_func_t *our_func;
   int matching_filenames, found_quote;
 
   static char *orig_text;
@@ -1697,7 +1740,7 @@ rl_menu_complete (count, ignore)
 
       our_func = rl_completion_entry_function
 			? rl_completion_entry_function
-			: (Function *)filename_completion_function;
+			: rl_filename_completion_function;
 
       /* We now look backwards for the start of a filename/variable word. */
       orig_end = rl_point;
@@ -1716,19 +1759,14 @@ rl_menu_complete (count, ignore)
       matches = gen_completion_matches (orig_text, orig_start, orig_end,
 					our_func, found_quote, quote_char);
 
-#if 0
-      /* If we are matching filenames, our_func will have been set to
-	 filename_completion_function */
-      matching_filenames = our_func == (Function *)filename_completion_function;
-#else
       /* If we are matching filenames, the attempted completion function will
 	 have set rl_filename_completion_desired to a non-zero value.  The basic
-	 filename_completion_function does this. */
+	 rl_filename_completion_function does this. */
       matching_filenames = rl_filename_completion_desired;
-#endif
+
       if (matches == 0 || postprocess_matches (&matches, matching_filenames) == 0)
 	{
-    	  ding ();
+    	  rl_ding ();
 	  FREE (matches);
 	  matches = (char **)0;
 	  FREE (orig_text);
@@ -1749,7 +1787,7 @@ rl_menu_complete (count, ignore)
 
   if (matches == 0 || match_list_size == 0) 
     {
-      ding ();
+      rl_ding ();
       FREE (matches);
       matches = (char **)0;
       completion_changed_buffer = 0;
@@ -1762,7 +1800,7 @@ rl_menu_complete (count, ignore)
 
   if (match_list_index == 0 && match_list_size > 1)
     {
-      ding ();
+      rl_ding ();
       insert_match (orig_text, orig_start, MULT_MATCH, &quote_char);
     }
   else
Index: readline/config.h.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/config.h.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 config.h.in
--- readline/config.h.in	2003/02/16 21:36:29	1.1.1.1
+++ readline/config.h.in	2001/02/07 18:31:08
@@ -1,63 +1,20 @@
-/* config.h.in.  Generated automatically from configure.in by autoheader.  */
+/* config.h.in.  Maintained by hand. */
 
-/* Define if you have the strcoll function and it is properly defined.  */
-#undef HAVE_STRCOLL
-
 /* Define if on MINIX.  */
 #undef _MINIX
 
-/* Define if the system does not provide POSIX.1 features except
-   with this defined.  */
-#undef _POSIX_1_SOURCE
-
-/* Define if you need to in order for stat and other things to work.  */
-#undef _POSIX_SOURCE
-
 /* Define as the return type of signal handlers (int or void).  */
 #undef RETSIGTYPE
 
 /* Define if the `S_IS*' macros in <sys/stat.h> do not work properly.  */
 #undef STAT_MACROS_BROKEN
 
-/* Definitions pulled in from aclocal.m4. */
 #undef VOID_SIGHANDLER
-
-#undef GWINSZ_IN_SYS_IOCTL
-
-#undef TIOCSTAT_IN_SYS_IOCTL
-
-#undef HAVE_GETPW_DECLS
-
-#undef FIONREAD_IN_SYS_IOCTL
-
-#undef HAVE_BSD_SIGNALS
-
-#undef HAVE_LSTAT
-
-#undef HAVE_POSIX_SIGNALS
-
-#undef HAVE_POSIX_SIGSETJMP
-
-#undef HAVE_USG_SIGHOLD
-
-#undef MUST_REINSTALL_SIGHANDLERS
-
-#undef SPEED_T_IN_SYS_TYPES
-
-#undef STRCOLL_BROKEN
-
-#undef STRUCT_DIRENT_HAS_D_FILENO
-
-#undef STRUCT_DIRENT_HAS_D_INO
 
-#undef STRUCT_WINSIZE_IN_SYS_IOCTL
-
-#undef STRUCT_WINSIZE_IN_TERMIOS
-
-/* Define if you have the lstat function.  */
+/* Define if you have the lstat function. */
 #undef HAVE_LSTAT
 
-/* Define if you have the memmove function.  */
+/* Define if you have the memmove function. */
 #undef HAVE_MEMMOVE
 
 /* Define if you have the putenv function.  */
@@ -69,27 +26,26 @@
 /* Define if you have the setenv function.  */
 #undef HAVE_SETENV
 
-/* Define if you have the setlocale function.  */
-#undef HAVE_SETLOCALE
-
 /* Define if you have the strcasecmp function.  */
 #undef HAVE_STRCASECMP
 
+/* Define if you have the setlocale function. */
+#undef HAVE_SETLOCALE
+
 /* Define if you have the tcgetattr function.  */
 #undef HAVE_TCGETATTR
 
+/* Define if you have the strcoll function.  */
+#undef HAVE_STRCOLL
+
+#undef STRCOLL_BROKEN
+
 /* Define if you have the <dirent.h> header file.  */
 #undef HAVE_DIRENT_H
 
-/* Define if you have the <locale.h> header file.  */
-#undef HAVE_LOCALE_H
-
 /* Define if you have the <ndir.h> header file.  */
 #undef HAVE_NDIR_H
 
-/* Define if you have the <stdarg.h> header file.  */
-#undef HAVE_STDARG_H
-
 /* Define if you have the <stdlib.h> header file.  */
 #undef HAVE_STDLIB_H
 
@@ -131,7 +87,43 @@
 
 /* Define if you have the <varargs.h> header file.  */
 #undef HAVE_VARARGS_H
-/* config.h.bot */
+
+/* Define if you have the <stdarg.h> header file.  */
+#undef HAVE_STDARG_H
+
+#undef HAVE_LOCALE_H
+
+/* Definitions pulled in from aclocal.m4. */
+#undef VOID_SIGHANDLER
+
+#undef GWINSZ_IN_SYS_IOCTL
+
+#undef STRUCT_WINSIZE_IN_SYS_IOCTL
+
+#undef STRUCT_WINSIZE_IN_TERMIOS
+
+#undef TIOCSTAT_IN_SYS_IOCTL
+
+#undef FIONREAD_IN_SYS_IOCTL
+
+#undef SPEED_T_IN_SYS_TYPES
+
+#undef HAVE_GETPW_DECLS
+
+#undef STRUCT_DIRENT_HAS_D_INO
+
+#undef STRUCT_DIRENT_HAS_D_FILENO
+
+#undef HAVE_BSD_SIGNALS
+
+#undef HAVE_POSIX_SIGNALS
+
+#undef HAVE_USG_SIGHOLD
+
+#undef MUST_REINSTALL_SIGHANDLERS
+
+#undef HAVE_POSIX_SIGSETJMP
+
 /* modify settings or make new ones based on what autoconf tells us. */
 
 /* Ultrix botches type-ahead when switching from canonical to
Index: readline/configure
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/configure,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure
--- readline/configure	2003/02/16 21:36:29	1.1.1.1
+++ readline/configure	2001/04/02 19:56:02
@@ -1,7 +1,7 @@
 #! /bin/sh
 
-# From configure.in for Readline 4.1, version 2.22, from autoconf version 2.13
-LIBVERSION=4.1
+# From configure.in for Readline 4.2, version 2.26, from autoconf version 2.13
+LIBVERSION=4.2
 
 
 
@@ -103,6 +103,8 @@ LIBVERSION=4.1
 
 
 
+
+
 # Guess values for system-dependent variables and create Makefiles.
 # Generated automatically using autoconf version 2.13 
 # Copyright (C) 1992, 93, 94, 95, 96 Free Software Foundation, Inc.
@@ -630,9 +632,8 @@ fi
 
 
 
-
 ac_aux_dir=
-for ac_dir in $srcdir $srcdir/.. $srcdir/../..; do
+for ac_dir in ./support $srcdir/./support; do
   if test -f $ac_dir/install-sh; then
     ac_aux_dir=$ac_dir
     ac_install_sh="$ac_aux_dir/install-sh -c"
@@ -644,20 +645,21 @@ for ac_dir in $srcdir $srcdir/.. $srcdir
   fi
 done
 if test -z "$ac_aux_dir"; then
-  { echo "configure: error: can not find install-sh or install.sh in $srcdir $srcdir/.. $srcdir/../.." 1>&2; exit 1; }
+  { echo "configure: error: can not find install-sh or install.sh in ./support $srcdir/./support" 1>&2; exit 1; }
 fi
 ac_config_guess=$ac_aux_dir/config.guess
 ac_config_sub=$ac_aux_dir/config.sub
 ac_configure=$ac_aux_dir/configure # This should be Cygnus configure.
 
 
+
 # Make sure we can run config.sub.
 if ${CONFIG_SHELL-/bin/sh} $ac_config_sub sun4 >/dev/null 2>&1; then :
 else { echo "configure: error: can not run $ac_config_sub" 1>&2; exit 1; }
 fi
 
 echo $ac_n "checking host system type""... $ac_c" 1>&6
-echo "configure:661: checking host system type" >&5
+echo "configure:663: checking host system type" >&5
 
 host_alias=$host
 case "$host_alias" in
@@ -695,10 +697,37 @@ fi
 # We want these before the checks, so the checks can modify their values.
 test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
 
+echo $ac_n "checking whether ${MAKE-make} sets \${MAKE}""... $ac_c" 1>&6
+echo "configure:702: checking whether ${MAKE-make} sets \${MAKE}" >&5
+set dummy ${MAKE-make}; ac_make=`echo "$2" | sed 'y%./+-%__p_%'`
+if eval "test \"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\" = set"; then
+  echo $ac_n "(cached) $ac_c" 1>&6
+else
+  cat > conftestmake <<\EOF
+all:
+	@echo 'ac_maketemp="${MAKE}"'
+EOF
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
+eval `${MAKE-make} -f conftestmake 2>/dev/null | grep temp=`
+if test -n "$ac_maketemp"; then
+  eval ac_cv_prog_make_${ac_make}_set=yes
+else
+  eval ac_cv_prog_make_${ac_make}_set=no
+fi
+rm -f conftestmake
+fi
+if eval "test \"`echo '$ac_cv_prog_make_'${ac_make}_set`\" = yes"; then
+  echo "$ac_t""yes" 1>&6
+  SET_MAKE=
+else
+  echo "$ac_t""no" 1>&6
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
 # Extract the first word of "gcc", so it can be a program name with args.
 set dummy gcc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:702: checking for $ac_word" >&5
+echo "configure:731: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -728,7 +757,7 @@ if test -z "$CC"; then
   # Extract the first word of "cc", so it can be a program name with args.
 set dummy cc; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:732: checking for $ac_word" >&5
+echo "configure:761: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -779,7 +808,7 @@ fi
       # Extract the first word of "cl", so it can be a program name with args.
 set dummy cl; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:783: checking for $ac_word" >&5
+echo "configure:812: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_CC'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -811,7 +840,7 @@ fi
 fi
 
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works""... $ac_c" 1>&6
-echo "configure:815: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
+echo "configure:844: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works" >&5
 
 ac_ext=c
 # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.
@@ -822,12 +851,12 @@ cross_compiling=$ac_cv_prog_cc_cross
 
 cat > conftest.$ac_ext << EOF
 
-#line 826 "configure"
+#line 855 "configure"
 #include "confdefs.h"
 
 main(){return(0);}
 EOF
-if { (eval echo configure:831: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   ac_cv_prog_cc_works=yes
   # If we can't run a trivial program, we are probably using a cross compiler.
   if (./conftest; exit) 2>/dev/null; then
@@ -853,12 +882,12 @@ if test $ac_cv_prog_cc_works = no; then
   { echo "configure: error: installation or configuration problem: C compiler cannot create executables." 1>&2; exit 1; }
 fi
 echo $ac_n "checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler""... $ac_c" 1>&6
-echo "configure:857: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
+echo "configure:886: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler" >&5
 echo "$ac_t""$ac_cv_prog_cc_cross" 1>&6
 cross_compiling=$ac_cv_prog_cc_cross
 
 echo $ac_n "checking whether we are using GNU C""... $ac_c" 1>&6
-echo "configure:862: checking whether we are using GNU C" >&5
+echo "configure:891: checking whether we are using GNU C" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -867,7 +896,7 @@ else
   yes;
 #endif
 EOF
-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:871: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:900: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then
   ac_cv_prog_gcc=yes
 else
   ac_cv_prog_gcc=no
@@ -886,7 +915,7 @@ ac_test_CFLAGS="${CFLAGS+set}"
 ac_save_CFLAGS="$CFLAGS"
 CFLAGS=
 echo $ac_n "checking whether ${CC-cc} accepts -g""... $ac_c" 1>&6
-echo "configure:890: checking whether ${CC-cc} accepts -g" >&5
+echo "configure:919: checking whether ${CC-cc} accepts -g" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_cc_g'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -918,7 +947,7 @@ else
 fi
 
 echo $ac_n "checking how to run the C preprocessor""... $ac_c" 1>&6
-echo "configure:922: checking how to run the C preprocessor" >&5
+echo "configure:951: checking how to run the C preprocessor" >&5
 # On Suns, sometimes $CPP names a directory.
 if test -n "$CPP" && test -d "$CPP"; then
   CPP=
@@ -933,13 +962,13 @@ else
   # On the NeXT, cc -E runs the code through the compiler's parser,
   # not just through cpp.
   cat > conftest.$ac_ext <<EOF
-#line 937 "configure"
+#line 966 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:943: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:972: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -950,13 +979,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -E -traditional-cpp"
   cat > conftest.$ac_ext <<EOF
-#line 954 "configure"
+#line 983 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:960: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:989: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -967,13 +996,13 @@ else
   rm -rf conftest*
   CPP="${CC-cc} -nologo -E"
   cat > conftest.$ac_ext <<EOF
-#line 971 "configure"
+#line 1000 "configure"
 #include "confdefs.h"
 #include <assert.h>
 Syntax Error
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:977: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1006: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   :
@@ -999,17 +1028,17 @@ echo "$ac_t""$CPP" 1>&6
 
 ac_safe=`echo "minix/config.h" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for minix/config.h""... $ac_c" 1>&6
-echo "configure:1003: checking for minix/config.h" >&5
+echo "configure:1032: checking for minix/config.h" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1008 "configure"
+#line 1037 "configure"
 #include "confdefs.h"
 #include <minix/config.h>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1013: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1042: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -1047,52 +1076,18 @@ EOF
 fi
 
 
- 
-if test "x$cross_compiling" = "xyes"; then
-    case "${host}" in
-    *-cygwin*)
-	cross_cache=${srcdir}/cross-build/cygwin.cache
-	if test -r "${cross_cache}"; then
-	    echo "loading cross-build cache file ${cross_cache}"
-	    . ${cross_cache}
-	fi
-	LOCAL_CFLAGS="$LOCAL_CFLAGS -I${srcdir}/../libtermcap"
-	unset cross_cache
-	;;
-    *)  echo "configure: cross-compiling for a non-cygwin target is not supported" >&2
-	;;
-    esac
-fi
- 
-if test "x$cross_compiling" = "xyes"; then
-  CROSS_COMPILING_FLAG=-DCROSS_COMPILING
-else
-  CROSS_COMPILING_FLAG=
-fi
-
- 
-if test -z "$CC_FOR_BUILD"; then
-    if test "x$cross_compiling" = "xno"; then
-        CC_FOR_BUILD='$(CC)'
-    else
-        CC_FOR_BUILD=gcc
-    fi
-fi
-
- 
-
 # If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
 test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
 
 if test $ac_cv_prog_gcc = yes; then
     echo $ac_n "checking whether ${CC-cc} needs -traditional""... $ac_c" 1>&6
-echo "configure:1090: checking whether ${CC-cc} needs -traditional" >&5
+echo "configure:1085: checking whether ${CC-cc} needs -traditional" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_gcc_traditional'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
     ac_pattern="Autoconf.*'x'"
   cat > conftest.$ac_ext <<EOF
-#line 1096 "configure"
+#line 1091 "configure"
 #include "confdefs.h"
 #include <sgtty.h>
 Autoconf TIOCGETP
@@ -1110,7 +1105,7 @@ rm -f conftest*
 
   if test $ac_cv_prog_gcc_traditional = no; then
     cat > conftest.$ac_ext <<EOF
-#line 1114 "configure"
+#line 1109 "configure"
 #include "confdefs.h"
 #include <termio.h>
 Autoconf TCGETA
@@ -1143,7 +1138,7 @@ fi
 # SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
 # ./install, which can be erroneously created by make from ./install.sh.
 echo $ac_n "checking for a BSD compatible install""... $ac_c" 1>&6
-echo "configure:1147: checking for a BSD compatible install" >&5
+echo "configure:1142: checking for a BSD compatible install" >&5
 if test -z "$INSTALL"; then
 if eval "test \"`echo '$''{'ac_cv_path_install'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1198,7 +1193,7 @@ test -z "$INSTALL_DATA" && INSTALL_DATA=
 # Extract the first word of "ar", so it can be a program name with args.
 set dummy ar; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1202: checking for $ac_word" >&5
+echo "configure:1197: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_AR'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1228,7 +1223,7 @@ test -n "$ARFLAGS" || ARFLAGS="cr"
 # Extract the first word of "ranlib", so it can be a program name with args.
 set dummy ranlib; ac_word=$2
 echo $ac_n "checking for $ac_word""... $ac_c" 1>&6
-echo "configure:1232: checking for $ac_word" >&5
+echo "configure:1227: checking for $ac_word" >&5
 if eval "test \"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1260,12 +1255,12 @@ MAKE_SHELL=/bin/sh
 
 
 echo $ac_n "checking return type of signal handlers""... $ac_c" 1>&6
-echo "configure:1264: checking return type of signal handlers" >&5
+echo "configure:1259: checking return type of signal handlers" >&5
 if eval "test \"`echo '$''{'ac_cv_type_signal'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1269 "configure"
+#line 1264 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -1282,7 +1277,7 @@ int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:1286: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1281: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   ac_cv_type_signal=void
 else
@@ -1302,12 +1297,12 @@ EOF
 
 
 echo $ac_n "checking whether stat file-mode macros are broken""... $ac_c" 1>&6
-echo "configure:1306: checking whether stat file-mode macros are broken" >&5
+echo "configure:1301: checking whether stat file-mode macros are broken" >&5
 if eval "test \"`echo '$''{'ac_cv_header_stat_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1311 "configure"
+#line 1306 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -1362,12 +1357,12 @@ for ac_hdr in dirent.h sys/ndir.h sys/di
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr that defines DIR""... $ac_c" 1>&6
-echo "configure:1366: checking for $ac_hdr that defines DIR" >&5
+echo "configure:1361: checking for $ac_hdr that defines DIR" >&5
 if eval "test \"`echo '$''{'ac_cv_header_dirent_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1371 "configure"
+#line 1366 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <$ac_hdr>
@@ -1375,7 +1370,7 @@ int main() {
 DIR *dirp = 0;
 ; return 0; }
 EOF
-if { (eval echo configure:1379: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:1374: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   eval "ac_cv_header_dirent_$ac_safe=yes"
 else
@@ -1400,7 +1395,7 @@ done
 # Two versions of opendir et al. are in -ldir and -lx on SCO Xenix.
 if test $ac_header_dirent = dirent.h; then
 echo $ac_n "checking for opendir in -ldir""... $ac_c" 1>&6
-echo "configure:1404: checking for opendir in -ldir" >&5
+echo "configure:1399: checking for opendir in -ldir" >&5
 ac_lib_var=`echo dir'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1408,7 +1403,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ldir  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1412 "configure"
+#line 1407 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1419,7 +1414,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1423: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1418: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1441,7 +1436,7 @@ fi
 
 else
 echo $ac_n "checking for opendir in -lx""... $ac_c" 1>&6
-echo "configure:1445: checking for opendir in -lx" >&5
+echo "configure:1440: checking for opendir in -lx" >&5
 ac_lib_var=`echo x'_'opendir | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -1449,7 +1444,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lx  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 1453 "configure"
+#line 1448 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -1460,7 +1455,7 @@ int main() {
 opendir()
 ; return 0; }
 EOF
-if { (eval echo configure:1464: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1459: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -1487,12 +1482,12 @@ for ac_func in lstat memmove putenv sele
 		strcasecmp tcgetattr
 do
 echo $ac_n "checking for $ac_func""... $ac_c" 1>&6
-echo "configure:1491: checking for $ac_func" >&5
+echo "configure:1486: checking for $ac_func" >&5
 if eval "test \"`echo '$''{'ac_cv_func_$ac_func'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1496 "configure"
+#line 1491 "configure"
 #include "confdefs.h"
 /* System header to define __stub macros and hopefully few prototypes,
     which can conflict with char $ac_func(); below.  */
@@ -1515,7 +1510,7 @@ $ac_func();
 
 ; return 0; }
 EOF
-if { (eval echo configure:1519: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1514: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_func_$ac_func=yes"
 else
@@ -1541,7 +1536,7 @@ done
 
 
 echo $ac_n "checking for working strcoll""... $ac_c" 1>&6
-echo "configure:1545: checking for working strcoll" >&5
+echo "configure:1540: checking for working strcoll" >&5
 if eval "test \"`echo '$''{'ac_cv_func_strcoll_works'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1549,7 +1544,7 @@ else
   ac_cv_func_strcoll_works=no
 else
   cat > conftest.$ac_ext <<EOF
-#line 1553 "configure"
+#line 1548 "configure"
 #include "confdefs.h"
 #include <string.h>
 main ()
@@ -1559,7 +1554,7 @@ main ()
 	strcoll ("123", "456") >= 0);
 }
 EOF
-if { (eval echo configure:1563: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1558: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   ac_cv_func_strcoll_works=yes
 else
@@ -1588,17 +1583,17 @@ for ac_hdr in unistd.h stdlib.h varargs.
 do
 ac_safe=`echo "$ac_hdr" | sed 'y%./+-%__p_%'`
 echo $ac_n "checking for $ac_hdr""... $ac_c" 1>&6
-echo "configure:1592: checking for $ac_hdr" >&5
+echo "configure:1587: checking for $ac_hdr" >&5
 if eval "test \"`echo '$''{'ac_cv_header_$ac_safe'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1597 "configure"
+#line 1592 "configure"
 #include "confdefs.h"
 #include <$ac_hdr>
 EOF
 ac_try="$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out"
-{ (eval echo configure:1602: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
+{ (eval echo configure:1597: \"$ac_try\") 1>&5; (eval $ac_try) 2>&5; }
 ac_err=`grep -v '^ *+' conftest.out | grep -v "^conftest.${ac_ext}\$"`
 if test -z "$ac_err"; then
   rm -rf conftest*
@@ -1627,13 +1622,13 @@ done
 
 
 echo $ac_n "checking for type of signal functions""... $ac_c" 1>&6
-echo "configure:1631: checking for type of signal functions" >&5
+echo "configure:1626: checking for type of signal functions" >&5
 if eval "test \"`echo '$''{'bash_cv_signal_vintage'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   
   cat > conftest.$ac_ext <<EOF
-#line 1637 "configure"
+#line 1632 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -1646,7 +1641,7 @@ int main() {
   
 ; return 0; }
 EOF
-if { (eval echo configure:1650: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1645: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=posix
 else
@@ -1655,7 +1650,7 @@ else
   rm -rf conftest*
   
     cat > conftest.$ac_ext <<EOF
-#line 1659 "configure"
+#line 1654 "configure"
 #include "confdefs.h"
 #include <signal.h>
 int main() {
@@ -1665,7 +1660,7 @@ int main() {
     
 ; return 0; }
 EOF
-if { (eval echo configure:1669: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1664: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=4.2bsd
 else
@@ -1674,7 +1669,7 @@ else
   rm -rf conftest*
   
       cat > conftest.$ac_ext <<EOF
-#line 1678 "configure"
+#line 1673 "configure"
 #include "confdefs.h"
 
 	#include <signal.h>
@@ -1687,7 +1682,7 @@ int main() {
         
 ; return 0; }
 EOF
-if { (eval echo configure:1691: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1686: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_signal_vintage=svr3
 else
@@ -1728,7 +1723,7 @@ fi
 
 
 echo $ac_n "checking if signal handlers must be reinstalled when invoked""... $ac_c" 1>&6
-echo "configure:1732: checking if signal handlers must be reinstalled when invoked" >&5
+echo "configure:1727: checking if signal handlers must be reinstalled when invoked" >&5
 if eval "test \"`echo '$''{'bash_cv_must_reinstall_sighandlers'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1738,7 +1733,7 @@ else
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 1742 "configure"
+#line 1737 "configure"
 #include "confdefs.h"
 
 #include <signal.h>
@@ -1785,7 +1780,7 @@ main()
 }
 
 EOF
-if { (eval echo configure:1789: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1784: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_must_reinstall_sighandlers=no
 else
@@ -1810,7 +1805,7 @@ fi
 
 
 echo $ac_n "checking for presence of POSIX-style sigsetjmp/siglongjmp""... $ac_c" 1>&6
-echo "configure:1814: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
+echo "configure:1809: checking for presence of POSIX-style sigsetjmp/siglongjmp" >&5
 if eval "test \"`echo '$''{'bash_cv_func_sigsetjmp'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1820,7 +1815,7 @@ else
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 1824 "configure"
+#line 1819 "configure"
 #include "confdefs.h"
 
 #ifdef HAVE_UNISTD_H
@@ -1861,7 +1856,7 @@ exit(1);
 #endif
 }
 EOF
-if { (eval echo configure:1865: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:1860: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_sigsetjmp=present
 else
@@ -1884,12 +1879,12 @@ EOF
 fi
 
 echo $ac_n "checking for lstat""... $ac_c" 1>&6
-echo "configure:1888: checking for lstat" >&5
+echo "configure:1883: checking for lstat" >&5
 if eval "test \"`echo '$''{'bash_cv_func_lstat'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1893 "configure"
+#line 1888 "configure"
 #include "confdefs.h"
 
 #include <sys/types.h>
@@ -1899,7 +1894,7 @@ int main() {
  lstat(".",(struct stat *)0); 
 ; return 0; }
 EOF
-if { (eval echo configure:1903: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:1898: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   bash_cv_func_lstat=yes
 else
@@ -1919,37 +1914,36 @@ EOF
 
 fi
 
-echo $ac_n "checking whether programs are able to redeclare getpw functions""... $ac_c" 1>&6
-echo "configure:1924: checking whether programs are able to redeclare getpw functions" >&5
-if eval "test \"`echo '$''{'bash_cv_can_redecl_getpw'+set}'`\" = set"; then
+echo $ac_n "checking whether getpw functions are declared in pwd.h""... $ac_c" 1>&6
+echo "configure:1919: checking whether getpw functions are declared in pwd.h" >&5
+if eval "test \"`echo '$''{'bash_cv_getpw_declared'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 1929 "configure"
+#line 1924 "configure"
 #include "confdefs.h"
+
 #include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+#  include <unistd.h>
+#endif
 #include <pwd.h>
-extern struct passwd *getpwent();
-extern struct passwd *getpwuid();
-extern struct passwd *getpwnam();
-int main() {
-struct passwd *z; z = getpwent(); z = getpwuid(0); z = getpwnam("root");
-; return 0; }
+
 EOF
-if { (eval echo configure:1940: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if (eval "$ac_cpp conftest.$ac_ext") 2>&5 |
+  egrep "getpwuid" >/dev/null 2>&1; then
   rm -rf conftest*
-  bash_cv_can_redecl_getpw=yes
+  bash_cv_getpw_declared=yes
 else
-  echo "configure: failed program was:" >&5
-  cat conftest.$ac_ext >&5
   rm -rf conftest*
-  bash_cv_can_redecl_getpw=no
+  bash_cv_getpw_declared=no
 fi
 rm -f conftest*
+
 fi
 
-echo "$ac_t""$bash_cv_can_redecl_getpw" 1>&6
-if test $bash_cv_can_redecl_getpw = no; then
+echo "$ac_t""$bash_cv_getpw_declared" 1>&6
+if test $bash_cv_getpw_declared = yes; then
 cat >> confdefs.h <<\EOF
 #define HAVE_GETPW_DECLS 1
 EOF
@@ -1958,7 +1952,7 @@ fi
 
 
 echo $ac_n "checking whether or not strcoll and strcmp differ""... $ac_c" 1>&6
-echo "configure:1962: checking whether or not strcoll and strcmp differ" >&5
+echo "configure:1956: checking whether or not strcoll and strcmp differ" >&5
 if eval "test \"`echo '$''{'bash_cv_func_strcoll_broken'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
@@ -1968,7 +1962,7 @@ else
 
 else
   cat > conftest.$ac_ext <<EOF
-#line 1972 "configure"
+#line 1966 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -2007,7 +2001,7 @@ char    *v[];
 }
 
 EOF
-if { (eval echo configure:2011: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
+if { (eval echo configure:2005: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null
 then
   bash_cv_func_strcoll_broken=yes
 else
@@ -2031,12 +2025,12 @@ fi
 
 
 echo $ac_n "checking whether signal handlers are of type void""... $ac_c" 1>&6
-echo "configure:2035: checking whether signal handlers are of type void" >&5
+echo "configure:2029: checking whether signal handlers are of type void" >&5
 if eval "test \"`echo '$''{'bash_cv_void_sighandler'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2040 "configure"
+#line 2034 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <signal.h>
@@ -2051,7 +2045,7 @@ int main() {
 int i;
 ; return 0; }
 EOF
-if { (eval echo configure:2055: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2049: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_void_sighandler=yes
 else
@@ -2071,12 +2065,12 @@ EOF
 fi
 
 echo $ac_n "checking for TIOCGWINSZ in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:2075: checking for TIOCGWINSZ in sys/ioctl.h" >&5
+echo "configure:2069: checking for TIOCGWINSZ in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocgwinsz_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2080 "configure"
+#line 2074 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -2084,7 +2078,7 @@ int main() {
 int x = TIOCGWINSZ;
 ; return 0; }
 EOF
-if { (eval echo configure:2088: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2082: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocgwinsz_in_ioctl=yes
 else
@@ -2105,12 +2099,12 @@ EOF
 fi
 
 echo $ac_n "checking for TIOCSTAT in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:2109: checking for TIOCSTAT in sys/ioctl.h" >&5
+echo "configure:2103: checking for TIOCSTAT in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_tiocstat_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2114 "configure"
+#line 2108 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -2118,7 +2112,7 @@ int main() {
 int x = TIOCSTAT;
 ; return 0; }
 EOF
-if { (eval echo configure:2122: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2116: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_tiocstat_in_ioctl=yes
 else
@@ -2139,12 +2133,12 @@ EOF
 fi
 
 echo $ac_n "checking for FIONREAD in sys/ioctl.h""... $ac_c" 1>&6
-echo "configure:2143: checking for FIONREAD in sys/ioctl.h" >&5
+echo "configure:2137: checking for FIONREAD in sys/ioctl.h" >&5
 if eval "test \"`echo '$''{'bash_cv_fionread_in_ioctl'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2148 "configure"
+#line 2142 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -2152,7 +2146,7 @@ int main() {
 int x = FIONREAD;
 ; return 0; }
 EOF
-if { (eval echo configure:2156: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2150: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_fionread_in_ioctl=yes
 else
@@ -2173,19 +2167,19 @@ EOF
 fi
 
 echo $ac_n "checking for speed_t in sys/types.h""... $ac_c" 1>&6
-echo "configure:2177: checking for speed_t in sys/types.h" >&5
+echo "configure:2171: checking for speed_t in sys/types.h" >&5
 if eval "test \"`echo '$''{'bash_cv_speed_t_in_sys_types'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2182 "configure"
+#line 2176 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 int main() {
 speed_t x;
 ; return 0; }
 EOF
-if { (eval echo configure:2189: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2183: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_speed_t_in_sys_types=yes
 else
@@ -2206,12 +2200,12 @@ EOF
 fi
 
 echo $ac_n "checking for struct winsize in sys/ioctl.h and termios.h""... $ac_c" 1>&6
-echo "configure:2210: checking for struct winsize in sys/ioctl.h and termios.h" >&5
+echo "configure:2204: checking for struct winsize in sys/ioctl.h and termios.h" >&5
 if eval "test \"`echo '$''{'bash_cv_struct_winsize_header'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2215 "configure"
+#line 2209 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <sys/ioctl.h>
@@ -2219,7 +2213,7 @@ int main() {
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:2223: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2217: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=ioctl_h
 else
@@ -2227,7 +2221,7 @@ else
   cat conftest.$ac_ext >&5
   rm -rf conftest*
   cat > conftest.$ac_ext <<EOF
-#line 2231 "configure"
+#line 2225 "configure"
 #include "confdefs.h"
 #include <sys/types.h>
 #include <termios.h>
@@ -2235,7 +2229,7 @@ int main() {
 struct winsize x;
 ; return 0; }
 EOF
-if { (eval echo configure:2239: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2233: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_struct_winsize_header=termios_h
 else
@@ -2268,12 +2262,12 @@ fi
 
 
 echo $ac_n "checking if struct dirent has a d_ino member""... $ac_c" 1>&6
-echo "configure:2272: checking if struct dirent has a d_ino member" >&5
+echo "configure:2266: checking if struct dirent has a d_ino member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_dino'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2277 "configure"
+#line 2271 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -2302,7 +2296,7 @@ struct dirent d; int z; z = d.d_ino;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2306: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2300: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_dino=yes
 else
@@ -2324,12 +2318,12 @@ fi
 
 
 echo $ac_n "checking if struct dirent has a d_fileno member""... $ac_c" 1>&6
-echo "configure:2328: checking if struct dirent has a d_fileno member" >&5
+echo "configure:2322: checking if struct dirent has a d_fileno member" >&5
 if eval "test \"`echo '$''{'bash_cv_dirent_has_d_fileno'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   cat > conftest.$ac_ext <<EOF
-#line 2333 "configure"
+#line 2327 "configure"
 #include "confdefs.h"
 
 #include <stdio.h>
@@ -2358,7 +2352,7 @@ struct dirent d; int z; z = d.d_fileno;
 
 ; return 0; }
 EOF
-if { (eval echo configure:2362: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
+if { (eval echo configure:2356: \"$ac_compile\") 1>&5; (eval $ac_compile) 2>&5; }; then
   rm -rf conftest*
   bash_cv_dirent_has_d_fileno=yes
 else
@@ -2387,14 +2381,14 @@ if test "X$bash_cv_termcap_lib" = "X"; t
 _bash_needmsg=yes
 else
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:2391: checking which library has the termcap functions" >&5
+echo "configure:2385: checking which library has the termcap functions" >&5
 _bash_needmsg=
 fi
 if eval "test \"`echo '$''{'bash_cv_termcap_lib'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
 else
   echo $ac_n "checking for tgetent in -ltermcap""... $ac_c" 1>&6
-echo "configure:2398: checking for tgetent in -ltermcap" >&5
+echo "configure:2392: checking for tgetent in -ltermcap" >&5
 ac_lib_var=`echo termcap'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2402,7 +2396,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-ltermcap  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2406 "configure"
+#line 2400 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2413,7 +2407,7 @@ int main() {
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:2417: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2411: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2432,7 +2426,7 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lcurses""... $ac_c" 1>&6
-echo "configure:2436: checking for tgetent in -lcurses" >&5
+echo "configure:2430: checking for tgetent in -lcurses" >&5
 ac_lib_var=`echo curses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2440,7 +2434,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lcurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2444 "configure"
+#line 2438 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2451,7 +2445,7 @@ int main() {
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:2455: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2449: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2470,7 +2464,7 @@ if eval "test \"`echo '$ac_cv_lib_'$ac_l
 else
   echo "$ac_t""no" 1>&6
 echo $ac_n "checking for tgetent in -lncurses""... $ac_c" 1>&6
-echo "configure:2474: checking for tgetent in -lncurses" >&5
+echo "configure:2468: checking for tgetent in -lncurses" >&5
 ac_lib_var=`echo ncurses'_'tgetent | sed 'y%./+-%__p_%'`
 if eval "test \"`echo '$''{'ac_cv_lib_$ac_lib_var'+set}'`\" = set"; then
   echo $ac_n "(cached) $ac_c" 1>&6
@@ -2478,7 +2472,7 @@ else
   ac_save_LIBS="$LIBS"
 LIBS="-lncurses  $LIBS"
 cat > conftest.$ac_ext <<EOF
-#line 2482 "configure"
+#line 2476 "configure"
 #include "confdefs.h"
 /* Override any gcc2 internal prototype to avoid an error.  */
 /* We use char because int might match the return type of a gcc2
@@ -2489,7 +2483,7 @@ int main() {
 tgetent()
 ; return 0; }
 EOF
-if { (eval echo configure:2493: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
+if { (eval echo configure:2487: \"$ac_link\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then
   rm -rf conftest*
   eval "ac_cv_lib_$ac_lib_var=yes"
 else
@@ -2518,7 +2512,7 @@ fi
 
 if test "X$_bash_needmsg" = "Xyes"; then
 echo $ac_n "checking which library has the termcap functions""... $ac_c" 1>&6
-echo "configure:2522: checking which library has the termcap functions" >&5
+echo "configure:2516: checking which library has the termcap functions" >&5
 fi
 echo "$ac_t""using $bash_cv_termcap_lib" 1>&6
 if test $bash_cv_termcap_lib = gnutermcap && test -z "$prefer_curses"; then
@@ -2542,7 +2536,7 @@ fi
 
 case "$host_cpu" in
 *cray*)	LOCAL_CFLAGS=-DCRAY ;;
-*s390*)	LOCAL_CFLAGS=-fsigned-char ;;
+*s390*) LOCAL_CFLAGS=-fsigned-char ;;
 esac
 
 case "$host_os" in
@@ -2556,7 +2550,7 @@ esac
 #
 if test -f ${srcdir}/support/shobj-conf; then
         echo $ac_n "checking configuration for building shared libraries""... $ac_c" 1>&6
-echo "configure:2559: checking configuration for building shared libraries" >&5
+echo "configure:2554: checking configuration for building shared libraries" >&5
         eval `${CONFIG_SHELL-/bin/sh} ${srcdir}/support/shobj-conf -C "${CC}" -c ${host_cpu} -o ${host_os} -v ${host_vendor}`
         
         
@@ -2740,10 +2734,9 @@ s%@host_alias@%$host_alias%g
 s%@host_cpu@%$host_cpu%g
 s%@host_vendor@%$host_vendor%g
 s%@host_os@%$host_os%g
+s%@SET_MAKE@%$SET_MAKE%g
 s%@CC@%$CC%g
 s%@CPP@%$CPP%g
-s%@CROSS_COMPILING_FLAG@%$CROSS_COMPILING_FLAG%g
-s%@CC_FOR_BUILD@%$CC_FOR_BUILD%g
 s%@INSTALL_PROGRAM@%$INSTALL_PROGRAM%g
 s%@INSTALL_SCRIPT@%$INSTALL_SCRIPT%g
 s%@INSTALL_DATA@%$INSTALL_DATA%g
Index: readline/configure.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/configure.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 configure.in
--- readline/configure.in	2003/02/16 21:36:29	1.1.1.1
+++ readline/configure.in	2001/04/02 19:55:12
@@ -4,8 +4,8 @@ dnl
 dnl report bugs to chet@po.cwru.edu
 dnl
 dnl Process this file with autoconf to produce a configure script.
-AC_REVISION([for Readline 4.1, version 2.22, from autoconf version] AC_ACVERSION)
-LIBVERSION=4.1
+AC_REVISION([for Readline 4.2, version 2.26, from autoconf version] AC_ACVERSION)
+LIBVERSION=4.2
 
 AC_INIT(readline.h)
 AC_CONFIG_HEADER(config.h)
@@ -13,7 +13,7 @@ AC_CONFIG_HEADER(config.h)
 dnl make sure we are using a recent autoconf version
 AC_PREREQ(2.10)
 
-dnl AC_CONFIG_AUX_DIR(./support)
+AC_CONFIG_AUX_DIR(./support)
 
 AC_CANONICAL_HOST
 
@@ -31,48 +31,11 @@ fi
 # We want these before the checks, so the checks can modify their values.
 test -z "$CFLAGS" && CFLAGS=-g auto_cflags=1
 
+AC_PROG_MAKE_SET
 AC_PROG_CC
 dnl AC_AIX
 AC_MINIX
 
-dnl BEGIN changes for CYGNUS cross-building for Cygwin
- 
-dnl load up the cross-building cache file -- add more cases and cache
-dnl files as necessary
-if test "x$cross_compiling" = "xyes"; then
-    case "${host}" in
-    *-cygwin*)
-	cross_cache=${srcdir}/cross-build/cygwin.cache
-	if test -r "${cross_cache}"; then
-	    echo "loading cross-build cache file ${cross_cache}"
-	    . ${cross_cache}
-	fi
-	LOCAL_CFLAGS="$LOCAL_CFLAGS -I${srcdir}/../libtermcap"
-	unset cross_cache
-	;;
-    *)  echo "configure: cross-compiling for a non-cygwin target is not supported" >&2
-	;;
-    esac
-fi
- 
-if test "x$cross_compiling" = "xyes"; then
-  CROSS_COMPILING_FLAG=-DCROSS_COMPILING
-else
-  CROSS_COMPILING_FLAG=
-fi
-AC_SUBST(CROSS_COMPILING_FLAG)
- 
-if test -z "$CC_FOR_BUILD"; then
-    if test "x$cross_compiling" = "xno"; then
-        CC_FOR_BUILD='$(CC)'
-    else
-        CC_FOR_BUILD=gcc
-    fi
-fi
-AC_SUBST(CC_FOR_BUILD)
- 
-dnl END changes for CYGNUS cross-building for Cygwin
-
 # If we're using gcc and the user hasn't specified CFLAGS, add -O to CFLAGS.
 test -n "$GCC" && test -n "$auto_cflags" && CFLAGS="$CFLAGS -O"
 
@@ -129,7 +92,7 @@ fi
 
 case "$host_cpu" in
 *cray*)	LOCAL_CFLAGS=-DCRAY ;;
-*s390*)	LOCAL_CFLAGS=-fsigned-char ;;
+*s390*) LOCAL_CFLAGS=-fsigned-char ;;
 esac
 
 case "$host_os" in
Index: readline/display.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/display.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 display.c
--- readline/display.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/display.c	2003/02/17 12:47:09
@@ -41,10 +41,6 @@
 
 #include <stdio.h>
 
-#ifdef __MSDOS__
-# include <pc.h>
-#endif
-
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
@@ -58,19 +54,33 @@
 #include "rlprivate.h"
 #include "xmalloc.h"
 
+#ifdef __MINGW32__
+#include <windows.h>
+extern int haveConsole;
+extern HANDLE hStdout, hStdin;
+extern COORD rlScreenEnd;
+extern int rlScreenMax;
+#endif /* __MINGW32__ */
+
 #if !defined (strchr) && !defined (__STDC__)
 extern char *strchr (), *strrchr ();
 #endif /* !strchr && !__STDC__ */
 
 #if defined (HACK_TERMCAP_MOTION)
-extern char *term_forward_char;
+extern char *_rl_term_forward_char;
 #endif
 
 static void update_line __P((char *, char *, int, int, int, int));
-static void space_to_eol __P((int));
 static void delete_chars __P((int));
 static void insert_some_chars __P((char *, int));
+#ifndef __MINGW32__
+static void space_to_eol __P((int));
 static void cr __P((void));
+#else
+# define cr() _rl_move_cursor_relative (0, 0)
+# define space_to_eol(count) _rl_clear_to_eol (count)
+# define putc(ch, stream) _rl_output_character_function (ch)
+#endif
 
 static int *inv_lbreaks, *vis_lbreaks;
 static int inv_lbsize, vis_lbsize;
@@ -107,7 +117,7 @@ static int inv_lbsize, vis_lbsize;
    RL_DISPLAY_FIXED variable.  This is good for efficiency. */
 
 /* Application-specific redisplay function. */
-VFunction *rl_redisplay_function = rl_redisplay;
+rl_voidfunc_t *rl_redisplay_function = rl_redisplay;
 
 /* Global variables declared here. */
 /* What YOU turn on when you have handled all redisplay yourself. */
@@ -146,27 +156,40 @@ static int forced_display;
 /* Default and initial buffer size.  Can grow. */
 static int line_size = 1024;
 
+/* Variables to keep track of the expanded prompt string, which may
+   include invisible characters. */
+
 static char *local_prompt, *local_prompt_prefix;
-static int visible_length, prefix_length;
+static int prompt_visible_length, prompt_prefix_length;
 
 /* The number of invisible characters in the line currently being
    displayed on the screen. */
 static int visible_wrap_offset;
 
-/* static so it can be shared between rl_redisplay and update_line */
+/* The number of invisible characters in the prompt string.  Static so it
+   can be shared between rl_redisplay and update_line */
 static int wrap_offset;
 
-/* The index of the last invisible_character in the prompt string. */
-static int last_invisible;
+/* The index of the last invisible character in the prompt string. */
+static int prompt_last_invisible;
 
 /* The length (buffer offset) of the first line of the last (possibly
    multi-line) buffer displayed on the screen. */
 static int visible_first_line_len;
 
+/* Number of invisible characters on the first physical line of the prompt.
+   Only valid when the number of physical characters in the prompt exceeds
+   (or is equal to) _rl_screenwidth. */
+static int prompt_invis_chars_first_line;
+
+static int prompt_last_screen_line;
+
 /* Expand the prompt string S and return the number of visible
    characters in *LP, if LP is not null.  This is currently more-or-less
    a placeholder for expansion.  LIP, if non-null is a place to store the
-   index of the last invisible character in the returned string. */
+   index of the last invisible character in the returned string. NIFLP,
+   if non-zero, is a place to store the number of invisible characters in
+   the first prompt line. */
 
 /* Current implementation:
 	\001 (^A) start non-visible characters
@@ -176,12 +199,12 @@ static int visible_first_line_len;
    \002 are assumed to be `visible'. */	
 
 static char *
-expand_prompt (pmt, lp, lip)
+expand_prompt (pmt, lp, lip, niflp)
      char *pmt;
-     int *lp, *lip;
+     int *lp, *lip, *niflp;
 {
   char *r, *ret, *p;
-  int l, rl, last, ignoring;
+  int l, rl, last, ignoring, ninvis, invfl;
 
   /* Short-circuit if we can. */
   if (strchr (pmt, RL_PROMPT_START_IGNORE) == 0)
@@ -194,8 +217,10 @@ expand_prompt (pmt, lp, lip)
 
   l = strlen (pmt);
   r = ret = xmalloc (l + 1);
-  
-  for (rl = ignoring = last = 0, p = pmt; p && *p; p++)
+
+  invfl = 0;	/* invisible chars in first line of prompt */
+
+  for (rl = ignoring = last = ninvis = 0, p = pmt; p && *p; p++)
     {
       /* This code strips the invisible character string markers
 	 RL_PROMPT_START_IGNORE and RL_PROMPT_END_IGNORE */
@@ -215,14 +240,23 @@ expand_prompt (pmt, lp, lip)
 	  *r++ = *p;
 	  if (!ignoring)
 	    rl++;
+	  else
+	    ninvis++;
+	  if (rl == _rl_screenwidth)
+	    invfl = ninvis;
 	}
     }
 
+  if (rl < _rl_screenwidth)
+    invfl = ninvis;
+
   *r = '\0';
   if (lp)
     *lp = rl;
   if (lip)
     *lip = last;
+  if (niflp)
+    *niflp = invfl;
   return ret;
 }
 
@@ -234,7 +268,7 @@ _rl_strip_prompt (pmt)
 {
   char *ret;
 
-  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL);
+  ret = expand_prompt (pmt, (int *)NULL, (int *)NULL, (int *)NULL);
   return ret;
 }
 
@@ -246,8 +280,8 @@ _rl_strip_prompt (pmt)
  *		  (portion after the final newline)
  * local_prompt_prefix = portion before last newline of rl_display_prompt,
  *			 expanded via expand_prompt
- * visible_length = number of visible characters in local_prompt
- * prefix_length = number of visible characters in local_prompt_prefix
+ * prompt_visible_length = number of visible characters in local_prompt
+ * prompt_prefix_length = number of visible characters in local_prompt_prefix
  *
  * This function is called once per call to readline().  It may also be
  * called arbitrarily to expand the primary prompt.
@@ -263,12 +297,11 @@ rl_expand_prompt (prompt)
   int c;
 
   /* Clear out any saved values. */
-  if (local_prompt)
-    free (local_prompt);
-  if (local_prompt_prefix)
-    free (local_prompt_prefix);
+  FREE (local_prompt);
+  FREE (local_prompt_prefix);
+
   local_prompt = local_prompt_prefix = (char *)0;
-  last_invisible = visible_length = 0;
+  prompt_last_invisible = prompt_visible_length = 0;
 
   if (prompt == 0 || *prompt == 0)
     return (0);
@@ -276,22 +309,28 @@ rl_expand_prompt (prompt)
   p = strrchr (prompt, '\n');
   if (!p)
     {
-      /* The prompt is only one line. */
-      local_prompt = expand_prompt (prompt, &visible_length, &last_invisible);
+      /* The prompt is only one logical line, though it might wrap. */
+      local_prompt = expand_prompt (prompt, &prompt_visible_length,
+					    &prompt_last_invisible,
+					    &prompt_invis_chars_first_line);
       local_prompt_prefix = (char *)0;
-      return (visible_length);
+      return (prompt_visible_length);
     }
   else
     {
       /* The prompt spans multiple lines. */
       t = ++p;
-      local_prompt = expand_prompt (p, &visible_length, &last_invisible);
+      local_prompt = expand_prompt (p, &prompt_visible_length,
+				       &prompt_last_invisible,
+				       &prompt_invis_chars_first_line);
       c = *t; *t = '\0';
       /* The portion of the prompt string up to and including the
 	 final newline is now null-terminated. */
-      local_prompt_prefix = expand_prompt (prompt, &prefix_length, (int *)NULL);
+      local_prompt_prefix = expand_prompt (prompt, &prompt_prefix_length,
+						   (int *)NULL,
+						   &prompt_invis_chars_first_line);
       *t = c;
-      return (prefix_length);
+      return (prompt_prefix_length);
     }
 }
 
@@ -403,7 +442,7 @@ rl_redisplay ()
 	  out += local_len;
 	}
       line[out] = '\0';
-      wrap_offset = local_len - visible_length;
+      wrap_offset = local_len - prompt_visible_length;
     }
   else
     {
@@ -436,7 +475,7 @@ rl_redisplay ()
       strncpy (line + out,  prompt_this_line, pmtlen);
       out += pmtlen;
       line[out] = '\0';
-      wrap_offset = 0;
+      wrap_offset = prompt_invis_chars_first_line = 0;
     }
 
 #define CHECK_INV_LBREAKS() \
@@ -451,7 +490,7 @@ rl_redisplay ()
 #define CHECK_LPOS() \
       do { \
 	lpos++; \
-	if (lpos >= screenwidth) \
+	if (lpos >= _rl_screenwidth) \
 	  { \
 	    if (newlines >= (inv_lbsize - 2)) \
 	      { \
@@ -466,22 +505,37 @@ rl_redisplay ()
   /* inv_lbreaks[i] is where line i starts in the buffer. */
   inv_lbreaks[newlines = 0] = 0;
   lpos = out - wrap_offset;
+
+  /* prompt_invis_chars_first_line is the number of invisible characters in
+     the first physical line of the prompt.
+     wrap_offset - prompt_invis_chars_first_line is the number of invis
+     chars on the second line. */
 
-  /* XXX - what if lpos is already >= screenwidth before we start drawing the
+  /* what if lpos is already >= _rl_screenwidth before we start drawing the
      contents of the command line? */
-  while (lpos >= screenwidth)
+  while (lpos >= _rl_screenwidth)
     {
-      /* XXX - possible fix from Darin Johnson <darin@acuson.com> for prompt
-	 string with invisible characters that is longer than the screen
-	 width.  XXX - this doesn't work right if invisible characters have
-	 to be put on the second screen line -- it adds too much (the number
-	 of invisible chars after the screenwidth). */
-      temp = ((newlines + 1) * screenwidth) + ((newlines == 0) ? wrap_offset : 0);
+      /* fix from Darin Johnson <darin@acuson.com> for prompt string with
+         invisible characters that is longer than the screen width.  The
+         prompt_invis_chars_first_line variable could be made into an array
+         saying how many invisible characters there are per line, but that's
+         probably too much work for the benefit gained.  How many people have
+         prompts that exceed two physical lines? */
+      temp = ((newlines + 1) * _rl_screenwidth) +
+             ((newlines == 0) ? prompt_invis_chars_first_line : 0) +
+             ((newlines == 1) ? wrap_offset : 0);
 
       inv_lbreaks[++newlines] = temp;
-      lpos -= screenwidth;
+      lpos -= _rl_screenwidth;
     }
 
+  prompt_last_screen_line = newlines;
+
+  /* Draw the rest of the line (after the prompt) into invisible_line, keeping
+     track of where the cursor is (c_pos), the number of the line containing
+     the cursor (lb_linenum), the last line number (lb_botlin and inv_botlin).
+     It maintains an array of line breaks for display (inv_lbreaks).
+     This handles expanding tabs for display and displaying meta characters. */
   lb_linenum = 0;
   for (in = 0; in < rl_end; in++)
     {
@@ -507,9 +561,9 @@ rl_redisplay ()
 	    {
 	      sprintf (line + out, "\\%o", c);
 
-	      if (lpos + 4 >= screenwidth)
+	      if (lpos + 4 >= _rl_screenwidth)
 		{
-		  temp = screenwidth - lpos;
+		  temp = _rl_screenwidth - lpos;
 		  CHECK_INV_LBREAKS ();
 		  inv_lbreaks[++newlines] = out + temp;
 		  lpos = 4 - temp;
@@ -528,7 +582,7 @@ rl_redisplay ()
 #if defined (DISPLAY_TABS)
       else if (c == '\t')
 	{
-	  register int temp, newout;
+	  register int newout;
 
 #if 0
 	  newout = (out | (int)7) + 1;
@@ -536,10 +590,10 @@ rl_redisplay ()
 	  newout = out + 8 - lpos % 8;
 #endif
 	  temp = newout - out;
-	  if (lpos + temp >= screenwidth)
+	  if (lpos + temp >= _rl_screenwidth)
 	    {
 	      register int temp2;
-	      temp2 = screenwidth - lpos;
+	      temp2 = _rl_screenwidth - lpos;
 	      CHECK_INV_LBREAKS ();
 	      inv_lbreaks[++newlines] = out + temp2;
 	      lpos = temp - temp2;
@@ -554,7 +608,7 @@ rl_redisplay ()
 	    }
 	}
 #endif
-      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && term_up && *term_up)
+      else if (c == '\n' && _rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
 	{
 	  line[out++] = '\0';	/* XXX - sentinel */
 	  CHECK_INV_LBREAKS ();
@@ -586,7 +640,8 @@ rl_redisplay ()
   inv_lbreaks[newlines+1] = out;
   cursor_linenum = lb_linenum;
 
-  /* C_POS == position in buffer where cursor should be placed. */
+  /* C_POS == position in buffer where cursor should be placed.
+     CURSOR_LINENUM == line number where the cursor should be placed. */
 
   /* PWP: now is when things get a bit hairy.  The visible and invisible
      line buffers are really multiple lines, which would wrap every
@@ -597,7 +652,7 @@ rl_redisplay ()
      otherwise, let long lines display in a single terminal line, and
      horizontally scroll it. */
 
-  if (_rl_horizontal_scroll_mode == 0 && term_up && *term_up)
+  if (_rl_horizontal_scroll_mode == 0 && _rl_term_up && *_rl_term_up)
     {
       int nleft, pos, changed_screen_line;
 
@@ -608,8 +663,8 @@ rl_redisplay ()
 	  /* If we have more than a screenful of material to display, then
 	     only display a screenful.  We should display the last screen,
 	     not the first.  */
-	  if (out >= screenchars)
-	    out = screenchars - 1;
+	  if (out >= _rl_screenchars)
+	    out = _rl_screenchars - 1;
 
 	  /* The first line is at character position 0 in the buffer.  The
 	     second and subsequent lines start at inv_lbreaks[N], offset by
@@ -639,7 +694,7 @@ rl_redisplay ()
 		  (wrap_offset > visible_wrap_offset) &&
 		  (_rl_last_c_pos < visible_first_line_len))
 		{
-		  nleft = screenwidth + wrap_offset - _rl_last_c_pos;
+		  nleft = _rl_screenwidth + wrap_offset - _rl_last_c_pos;
 		  if (nleft)
 		    _rl_clear_to_eol (nleft);
 		}
@@ -660,7 +715,7 @@ rl_redisplay ()
 		  _rl_move_vert (linenum);
 		  _rl_move_cursor_relative (0, tt);
 		  _rl_clear_to_eol
-		    ((linenum == _rl_vis_botlin) ? strlen (tt) : screenwidth);
+		    ((linenum == _rl_vis_botlin) ? strlen (tt) : _rl_screenwidth);
 		}
 	    }
 	  _rl_vis_botlin = inv_botlin;
@@ -671,7 +726,7 @@ rl_redisplay ()
 	  if (changed_screen_line)
 	    {
 	      _rl_move_vert (cursor_linenum);
-	      /* If we moved up to the line with the prompt using term_up,
+	      /* If we moved up to the line with the prompt using _rl_term_up,
 		 the physical cursor position on the screen stays the same,
 		 but the buffer position needs to be adjusted to account
 		 for invisible characters. */
@@ -684,15 +739,17 @@ rl_redisplay ()
 	     the characters from the current cursor position.  But we
 	     only need to reprint it if the cursor is before the last
 	     invisible character in the prompt string. */
-	  nleft = visible_length + wrap_offset;
+	  nleft = prompt_visible_length + wrap_offset;
 	  if (cursor_linenum == 0 && wrap_offset > 0 && _rl_last_c_pos > 0 &&
-	      _rl_last_c_pos <= last_invisible && local_prompt)
+	      _rl_last_c_pos <= prompt_last_invisible && local_prompt)
 	    {
 #if defined (__MSDOS__)
 	      putc ('\r', rl_outstream);
+#elif defined (__MINGW32__)
+	      cr ();
 #else
-	      if (term_cr)
-		tputs (term_cr, 1, _rl_output_character_function);
+	      if (_rl_term_cr)
+		tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
 	      _rl_output_some_chars (local_prompt, nleft);
 	      _rl_last_c_pos = nleft;
@@ -731,11 +788,11 @@ rl_redisplay ()
 
       /* The number of characters that will be displayed before the cursor. */
       ndisp = c_pos - wrap_offset;
-      nleft  = visible_length + wrap_offset;
+      nleft  = prompt_visible_length + wrap_offset;
       /* Where the new cursor position will be on the screen.  This can be
 	 longer than SCREENWIDTH; if it is, lmargin will be adjusted. */
       phys_c_pos = c_pos - (last_lmargin ? last_lmargin : wrap_offset);
-      t = screenwidth / 3;
+      t = _rl_screenwidth / 3;
 
       /* If the number of characters had already exceeded the screenwidth,
 	 last_lmargin will be > 0. */
@@ -743,7 +800,7 @@ rl_redisplay ()
       /* If the number of characters to be displayed is more than the screen
 	 width, compute the starting offset so that the cursor is about
 	 two-thirds of the way across the screen. */
-      if (phys_c_pos > screenwidth - 2)
+      if (phys_c_pos > _rl_screenwidth - 2)
 	{
 	  lmargin = c_pos - (2 * t);
 	  if (lmargin < 0)
@@ -753,7 +810,7 @@ rl_redisplay ()
 	  if (wrap_offset && lmargin > 0 && lmargin < nleft)
 	    lmargin = nleft;
 	}
-      else if (ndisp < screenwidth - 2)		/* XXX - was -1 */
+      else if (ndisp < _rl_screenwidth - 2)		/* XXX - was -1 */
 	lmargin = 0;
       else if (phys_c_pos < 1)
 	{
@@ -775,7 +832,7 @@ rl_redisplay ()
 	 the whole line, indicate that with a special character at the
 	 right edge of the screen.  If LMARGIN is 0, we need to take the
 	 wrap offset into account. */
-      t = lmargin + M_OFFSET (lmargin, wrap_offset) + screenwidth;
+      t = lmargin + M_OFFSET (lmargin, wrap_offset) + _rl_screenwidth;
       if (t < out)
 	line[t - 1] = '>';
 
@@ -785,8 +842,8 @@ rl_redisplay ()
 	  update_line (&visible_line[last_lmargin],
 		       &invisible_line[lmargin],
 		       0,
-		       screenwidth + visible_wrap_offset,
-		       screenwidth + (lmargin ? 0 : wrap_offset),
+		       _rl_screenwidth + visible_wrap_offset,
+		       _rl_screenwidth + (lmargin ? 0 : wrap_offset),
 		       0);
 
 	  /* If the visible new line is shorter than the old, but the number
@@ -797,12 +854,12 @@ rl_redisplay ()
 	      (_rl_last_c_pos == out) &&
 	      t < visible_first_line_len)
 	    {
-	      nleft = screenwidth - t;
+	      nleft = _rl_screenwidth - t;
 	      _rl_clear_to_eol (nleft);
 	    }
 	  visible_first_line_len = out - lmargin - M_OFFSET (lmargin, wrap_offset);
-	  if (visible_first_line_len > screenwidth)
-	    visible_first_line_len = screenwidth;
+	  if (visible_first_line_len > _rl_screenwidth)
+	    visible_first_line_len = _rl_screenwidth;
 
 	  _rl_move_cursor_relative (c_pos - lmargin, &invisible_line[lmargin]);
 	  last_lmargin = lmargin;
@@ -812,11 +869,11 @@ rl_redisplay ()
 
   /* Swap visible and non-visible lines. */
   {
-    char *temp = visible_line;
+    char *vtemp = visible_line;
     int *itemp = vis_lbreaks, ntemp = vis_lbsize;
 
     visible_line = invisible_line;
-    invisible_line = temp;
+    invisible_line = vtemp;
 
     vis_lbreaks = inv_lbreaks;
     inv_lbreaks = itemp;
@@ -866,7 +923,7 @@ update_line (old, new, current_line, oma
      emulators.  In this calculation, TEMP is the physical screen
      position of the cursor. */
   temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
-  if (temp == screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
+  if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
       && _rl_last_v_pos == current_line - 1)
     {
       if (new[0])
@@ -943,13 +1000,15 @@ update_line (old, new, current_line, oma
   lendiff = local_prompt ? strlen (local_prompt) : 0;
   od = ofd - old;	/* index of first difference in visible line */
   if (current_line == 0 && !_rl_horizontal_scroll_mode &&
-      term_cr && lendiff > visible_length && _rl_last_c_pos > 0 &&
-      od > lendiff && _rl_last_c_pos < last_invisible)
+      _rl_term_cr && lendiff > prompt_visible_length && _rl_last_c_pos > 0 &&
+      od >= lendiff && _rl_last_c_pos <= prompt_last_invisible)
     {
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
+#elif defined (__MINGW32__)
+      cr ();
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
       _rl_output_some_chars (local_prompt, lendiff);
       _rl_last_c_pos = lendiff;
@@ -971,20 +1030,21 @@ update_line (old, new, current_line, oma
   temp = ne - nfd;
   if (lendiff > 0)
     {
+#ifndef __MINGW32__
       /* Non-zero if we're increasing the number of lines. */
       int gl = current_line >= _rl_vis_botlin && inv_botlin > _rl_vis_botlin;
       /* Sometimes it is cheaper to print the characters rather than
 	 use the terminal's capabilities.  If we're growing the number
 	 of lines, make sure we actually cause the new line to wrap
 	 around on auto-wrapping terminals. */
-      if (terminal_can_insert && ((2 * temp) >= lendiff || term_IC) && (!_rl_term_autowrap || !gl))
+      if (_rl_terminal_can_insert && ((2 * temp) >= lendiff || _rl_term_IC) && (!_rl_term_autowrap || !gl))
 	{
-	  /* If lendiff > visible_length and _rl_last_c_pos == 0 and
+	  /* If lendiff > prompt_visible_length and _rl_last_c_pos == 0 and
 	     _rl_horizontal_scroll_mode == 1, inserting the characters with
-	     term_IC or term_ic will screw up the screen because of the
+	     _rl_term_IC or _rl_term_ic will screw up the screen because of the
 	     invisible characters.  We need to just draw them. */
 	  if (*ols && (!_rl_horizontal_scroll_mode || _rl_last_c_pos > 0 ||
-			lendiff <= visible_length || !current_invis_chars))
+			lendiff <= prompt_visible_length || !current_invis_chars))
 	    {
 	      insert_some_chars (nfd, lendiff);
 	      _rl_last_c_pos += lendiff;
@@ -1016,6 +1076,7 @@ update_line (old, new, current_line, oma
 	    }
 	}
       else
+#endif /* !__MINGW32__ */
 	{
 	  /* cannot insert chars, write to EOL */
 	  _rl_output_some_chars (nfd, temp);
@@ -1024,8 +1085,9 @@ update_line (old, new, current_line, oma
     }
   else				/* Delete characters from line. */
     {
+#ifndef __MINGW32__
       /* If possible and inexpensive to use terminal deletion, then do so. */
-      if (term_dc && (2 * temp) >= -lendiff)
+      if (_rl_term_dc && (2 * temp) >= -lendiff)
 	{
 	  /* If all we're doing is erasing the invisible characters in the
 	     prompt string, don't bother.  It screws up the assumptions
@@ -1047,6 +1109,7 @@ update_line (old, new, current_line, oma
 	}
       /* Otherwise, print over the existing material. */
       else
+#endif /* !__MINGW32__ */
 	{
 	  if (temp > 0)
 	    {
@@ -1110,7 +1173,7 @@ rl_on_new_line_with_prompt ()
   /* Dissect prompt_last_line into screen lines. Note that here we have
      to use the real screenwidth. Readline's notion of screenwidth might be
      one less, see terminal.c. */
-  real_screenwidth = screenwidth + (_rl_term_autowrap ? 0 : 1);
+  real_screenwidth = _rl_screenwidth + (_rl_term_autowrap ? 0 : 1);
   _rl_last_v_pos = l / real_screenwidth;
   /* If the prompt length is a multiple of real_screenwidth, we don't know
      whether the cursor is at the end of the last line, or already at the
@@ -1152,10 +1215,11 @@ rl_forced_update_display ()
 /* Move the cursor from _rl_last_c_pos to NEW, which are buffer indices.
    DATA is the contents of the screen line of interest; i.e., where
    the movement is being done. */
+#ifndef __MINGW32__
 void
 _rl_move_cursor_relative (new, data)
      int new;
-     char *data;
+     const char *data;
 {
   register int i;
 
@@ -1167,12 +1231,12 @@ _rl_move_cursor_relative (new, data)
   /* i == current physical cursor position. */
   i = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
   if (new == 0 || CR_FASTER (new, _rl_last_c_pos) ||
-      (_rl_term_autowrap && i == screenwidth))
+      (_rl_term_autowrap && i == _rl_screenwidth))
     {
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif /* !__MSDOS__ */
       _rl_last_c_pos = 0;
     }
@@ -1189,9 +1253,9 @@ _rl_move_cursor_relative (new, data)
 	 That kind of control is for people who don't know what the
 	 data is underneath the cursor. */
 #if defined (HACK_TERMCAP_MOTION)
-      if (term_forward_char)
+      if (_rl_term_forward_char)
 	for (i = _rl_last_c_pos; i < new; i++)
-	  tputs (term_forward_char, 1, _rl_output_character_function);
+	  tputs (_rl_term_forward_char, 1, _rl_output_character_function);
       else
 	for (i = _rl_last_c_pos; i < new; i++)
 	  putc (data[i], rl_outstream);
@@ -1212,7 +1276,7 @@ _rl_move_vert (to)
 {
   register int delta, i;
 
-  if (_rl_last_v_pos == to || to > screenheight)
+  if (_rl_last_v_pos == to || to > _rl_screenheight)
     return;
 
   if ((delta = to - _rl_last_v_pos) > 0)
@@ -1222,29 +1286,54 @@ _rl_move_vert (to)
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
       _rl_last_c_pos = 0;
     }
   else
     {			/* delta < 0 */
-#ifdef __MSDOS__
-      int row, col;
-
-      i = fflush (rl_outstream); /* make sure the cursor pos is current! */
-      ScreenGetCursor (&row, &col);
-      ScreenSetCursor ((row + to - _rl_last_v_pos), col);
-      delta = i;
-#else /* !__MSDOS__ */
-      if (term_up && *term_up)
+      if (_rl_term_up && *_rl_term_up)
 	for (i = 0; i < -delta; i++)
-	  tputs (term_up, 1, _rl_output_character_function);
-#endif /* !__MSDOS__ */
+	  tputs (_rl_term_up, 1, _rl_output_character_function);
     }
 
   _rl_last_v_pos = to;		/* Now TO is here */
 }
 
+#else /* __MINGW32__ */
+
+void
+_rl_move_cursor_relative (new, data)
+     int new;
+     const char *data;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if ( (_rl_last_c_pos != new)
+       && haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      csbi.dwCursorPosition.X += new - _rl_last_c_pos;
+      if ( SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition) )
+	_rl_last_c_pos = new;
+    }
+  return;
+}
+ 
+void
+_rl_move_vert (to)
+     int to;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if ( (_rl_last_v_pos != to) && (to <= _rl_screenheight)
+       && haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      csbi.dwCursorPosition.Y += to - _rl_last_v_pos;
+      if ( SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition) )
+	_rl_last_v_pos = to;
+    }
+}
+
+#endif /* __MINGW32__ */
+
 /* Physically print C on rl_outstream.  This is for functions which know
    how to optimize the display.  Return the number of characters output. */
 int
@@ -1373,25 +1462,23 @@ rl_save_prompt ()
 {
   saved_local_prompt = local_prompt;
   saved_local_prefix = local_prompt_prefix;
-  saved_last_invisible = last_invisible;
-  saved_visible_length = visible_length;
+  saved_last_invisible = prompt_last_invisible;
+  saved_visible_length = prompt_visible_length;
 
   local_prompt = local_prompt_prefix = (char *)0;
-  last_invisible = visible_length = 0;
+  prompt_last_invisible = prompt_visible_length = 0;
 }
 
 void
 rl_restore_prompt ()
 {
-  if (local_prompt)
-    free (local_prompt);
-  if (local_prompt_prefix)
-    free (local_prompt_prefix);
+  FREE (local_prompt);
+  FREE (local_prompt_prefix);
 
   local_prompt = saved_local_prompt;
   local_prompt_prefix = saved_local_prefix;
-  last_invisible = saved_last_invisible;
-  visible_length = saved_visible_length;
+  prompt_last_invisible = saved_last_invisible;
+  prompt_visible_length = saved_visible_length;
 }
 
 char *
@@ -1421,8 +1508,8 @@ _rl_make_prompt_for_search (pchar)
       pmt[len] = pchar;
       pmt[len+1] = '\0';
       local_prompt = savestring (pmt);
-      last_invisible = saved_last_invisible;
-      visible_length = saved_visible_length + 1;
+      prompt_last_invisible = saved_last_invisible;
+      prompt_visible_length = saved_visible_length + 1;
     }
   return pmt;
 }
@@ -1445,16 +1532,14 @@ _rl_erase_at_end_of_line (l)
 
 /* Clear to the end of the line.  COUNT is the minimum
    number of character spaces to clear, */
+#ifndef __MINGW32__ /* replace next two functions */
 void
 _rl_clear_to_eol (count)
      int count;
 {
-#ifndef __MSDOS__
-  if (term_clreol)
-    tputs (term_clreol, 1, _rl_output_character_function);
-  else
-#endif
-  if (count)
+  if (_rl_term_clreol)
+    tputs (_rl_term_clreol, 1, _rl_output_character_function);
+  else if (count)
     space_to_eol (count);
 }
 
@@ -1472,34 +1557,55 @@ space_to_eol (count)
   _rl_last_c_pos += count;
 }
 
+#else	/* __MINGW32__ */
+
 void
+_rl_clear_to_eol (count)
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  if (haveConsole && GetConsoleScreenBufferInfo(hStdout, &csbi))
+    {
+      DWORD written;
+      int linear_pos;
+      
+      linear_pos = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+	+ (int)csbi.dwCursorPosition.X;
+      if (linear_pos < rlScreenMax)
+	{
+	  rlScreenEnd = csbi.dwCursorPosition;
+	  rlScreenMax = linear_pos;
+	}
+      FillConsoleOutputCharacter(hStdout, ' ', count, csbi.dwCursorPosition, &written);
+    }
+  return;
+}
+
+#endif	/* __MINGW32__ */
+
+void
 _rl_clear_screen ()
 {
-#if defined (__GO32__)
-  ScreenClear ();	/* FIXME: only works in text modes */
-  ScreenSetCursor (0, 0);  /* term_clrpag is "cl" which homes the cursor */
-#else
-  if (term_clrpag)
-    tputs (term_clrpag, 1, _rl_output_character_function);
+#ifndef __MINGW32__
+  if (_rl_term_clrpag)
+    tputs (_rl_term_clrpag, 1, _rl_output_character_function);
   else
-    crlf ();
 #endif
+    rl_crlf ();
 }
 
+#ifndef __MINGW32__
 /* Insert COUNT characters from STRING to the output stream. */
 static void
 insert_some_chars (string, count)
      char *string;
      int count;
 {
-#ifdef __MSDOS__
-  _rl_output_some_chars (string, count);
-#else  /* !__MSDOS__ */
   /* If IC is defined, then we do not have to "enter" insert mode. */
-  if (term_IC)
+  if (_rl_term_IC)
     {
       char *buffer;
-      buffer = tgoto (term_IC, 0, count);
+      buffer = tgoto (_rl_term_IC, 0, count);
       tputs (buffer, 1, _rl_output_character_function);
       _rl_output_some_chars (string, count);
     }
@@ -1508,15 +1614,15 @@ insert_some_chars (string, count)
       register int i;
 
       /* If we have to turn on insert-mode, then do so. */
-      if (term_im && *term_im)
-	tputs (term_im, 1, _rl_output_character_function);
+      if (_rl_term_im && *_rl_term_im)
+	tputs (_rl_term_im, 1, _rl_output_character_function);
 
       /* If there is a special command for inserting characters, then
 	 use that first to open up the space. */
-      if (term_ic && *term_ic)
+      if (_rl_term_ic && *_rl_term_ic)
 	{
 	  for (i = count; i--; )
-	    tputs (term_ic, 1, _rl_output_character_function);
+	    tputs (_rl_term_ic, 1, _rl_output_character_function);
 	}
 
       /* Print the text. */
@@ -1524,10 +1630,9 @@ insert_some_chars (string, count)
 
       /* If there is a string to turn off insert mode, we had best use
 	 it now. */
-      if (term_ei && *term_ei)
-	tputs (term_ei, 1, _rl_output_character_function);
+      if (_rl_term_ei && *_rl_term_ei)
+	tputs (_rl_term_ei, 1, _rl_output_character_function);
     }
-#endif /* !__MSDOS__ */
 }
 
 /* Delete COUNT characters from the display line. */
@@ -1535,24 +1640,23 @@ static void
 delete_chars (count)
      int count;
 {
-  if (count > screenwidth)	/* XXX */
+  if (count > _rl_screenwidth)	/* XXX */
     return;
 
-#ifndef __MSDOS__
-  if (term_DC && *term_DC)
+  if (_rl_term_DC && *_rl_term_DC)
     {
       char *buffer;
-      buffer = tgoto (term_DC, count, count);
+      buffer = tgoto (_rl_term_DC, count, count);
       tputs (buffer, count, _rl_output_character_function);
     }
   else
     {
-      if (term_dc && *term_dc)
+      if (_rl_term_dc && *_rl_term_dc)
 	while (count--)
-	  tputs (term_dc, 1, _rl_output_character_function);
+	  tputs (_rl_term_dc, 1, _rl_output_character_function);
     }
-#endif /* !__MSDOS__ */
 }
+#endif /* !__MINGW32__ */
 
 void
 _rl_update_final ()
@@ -1570,7 +1674,7 @@ _rl_update_final ()
     }
   _rl_move_vert (_rl_vis_botlin);
   /* If we've wrapped lines, remove the final xterm line-wrap flag. */
-  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == screenwidth))
+  if (full_lines && _rl_term_autowrap && (VIS_LLEN(_rl_vis_botlin) == _rl_screenwidth))
     {
       char *last_line;
 #if 0
@@ -1578,30 +1682,32 @@ _rl_update_final ()
 #else
       last_line = &visible_line[vis_lbreaks[_rl_vis_botlin]];
 #endif
-      _rl_move_cursor_relative (screenwidth - 1, last_line);
+      _rl_move_cursor_relative (_rl_screenwidth - 1, last_line);
       _rl_clear_to_eol (0);
-      putc (last_line[screenwidth - 1], rl_outstream);
+      putc (last_line[_rl_screenwidth - 1], rl_outstream);
     }
   _rl_vis_botlin = 0;
-  crlf ();
+  rl_crlf ();
   fflush (rl_outstream);
   rl_display_fixed++;
 }
 
+#ifndef __MINGW32__
 /* Move to the start of the current line. */
 static void
 cr ()
 {
-  if (term_cr)
+  if (_rl_term_cr)
     {
 #if defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
       _rl_last_c_pos = 0;
     }
 }
+#endif
 
 /* Redraw the last line of a multi-line prompt that may possibly contain
    terminal escape sequences.  Called with the cursor at column 0 of the
@@ -1611,27 +1717,31 @@ redraw_prompt (t)
      char *t;
 {
   char *oldp, *oldl, *oldlprefix;
-  int oldlen, oldlast, oldplen;
+  int oldlen, oldlast, oldplen, oldninvis;
 
   /* Geez, I should make this a struct. */
   oldp = rl_display_prompt;
   oldl = local_prompt;
   oldlprefix = local_prompt_prefix;
-  oldlen = visible_length;
-  oldplen = prefix_length;
-  oldlast = last_invisible;
+  oldlen = prompt_visible_length;
+  oldplen = prompt_prefix_length;
+  oldlast = prompt_last_invisible;
+  oldninvis = prompt_invis_chars_first_line;
 
   rl_display_prompt = t;
-  local_prompt = expand_prompt (t, &visible_length, &last_invisible);
+  local_prompt = expand_prompt (t, &prompt_visible_length,
+				   &prompt_last_invisible,
+				   &prompt_invis_chars_first_line);
   local_prompt_prefix = (char *)NULL;
   rl_forced_update_display ();
 
   rl_display_prompt = oldp;
   local_prompt = oldl;
   local_prompt_prefix = oldlprefix;
-  visible_length = oldlen;
-  prefix_length = oldplen;
-  last_invisible = oldlast;
+  prompt_visible_length = oldlen;
+  prompt_prefix_length = oldplen;
+  prompt_last_invisible = oldlast;
+  prompt_invis_chars_first_line = oldninvis;
 }
       
 /* Redisplay the current line after a SIGWINCH is received. */
@@ -1642,31 +1752,35 @@ _rl_redisplay_after_sigwinch ()
 
   /* Clear the current line and put the cursor at column 0.  Make sure
      the right thing happens if we have wrapped to a new screen line. */
-  if (term_cr)
+  if (_rl_term_cr)
     {
-#if defined (__MSDOS__)
+#ifdef __MINGW32__
+      _rl_move_cursor_relative (0, 0);
+      space_to_eol (_rl_screenwidth);
+      _rl_move_cursor_relative (0, 0);
+#elif defined (__MSDOS__)
       putc ('\r', rl_outstream);
 #else
-      tputs (term_cr, 1, _rl_output_character_function);
+      tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif
       _rl_last_c_pos = 0;
 #if defined (__MSDOS__)
-      space_to_eol (screenwidth);
+      space_to_eol (_rl_screenwidth);
       putc ('\r', rl_outstream);
-#else
-      if (term_clreol)
-	tputs (term_clreol, 1, _rl_output_character_function);
+#elif !defined (__MINGW32__)
+      if (_rl_term_clreol)
+	tputs (_rl_term_clreol, 1, _rl_output_character_function);
       else
 	{
-	  space_to_eol (screenwidth);
-	  tputs (term_cr, 1, _rl_output_character_function);
+	  space_to_eol (_rl_screenwidth);
+	  tputs (_rl_term_cr, 1, _rl_output_character_function);
 	}
 #endif
       if (_rl_last_v_pos > 0)
 	_rl_move_vert (0);
     }
   else
-    crlf ();
+    rl_crlf ();
 
   /* Redraw only the last line of a multi-line prompt. */
   t = strrchr (rl_display_prompt, '\n');
@@ -1707,12 +1821,12 @@ _rl_current_display_line ()
   /* Find out whether or not there might be invisible characters in the
      editing buffer. */
   if (rl_display_prompt == rl_prompt)
-    nleft = _rl_last_c_pos - screenwidth - rl_visible_prompt_length;
+    nleft = _rl_last_c_pos - _rl_screenwidth - rl_visible_prompt_length;
   else
-    nleft = _rl_last_c_pos - screenwidth;
+    nleft = _rl_last_c_pos - _rl_screenwidth;
 
   if (nleft > 0)
-    ret = 1 + nleft / screenwidth;
+    ret = 1 + nleft / _rl_screenwidth;
   else
     ret = 0;
 
Index: readline/emacs_keymap.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/emacs_keymap.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 emacs_keymap.c
--- readline/emacs_keymap.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/emacs_keymap.c	2000/10/30 17:01:50
@@ -33,185 +33,185 @@
 KEYMAP_ENTRY_ARRAY emacs_standard_keymap = {
 
   /* Control keys. */
-  { ISFUNC, rl_set_mark },		/* Control-@ */
-  { ISFUNC, rl_beg_of_line },		/* Control-a */
-  { ISFUNC, rl_backward },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, rl_delete },		/* Control-d */
-  { ISFUNC, rl_end_of_line },		/* Control-e */
-  { ISFUNC, rl_forward },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, rl_rubout },		/* Control-h */
-  { ISFUNC, rl_complete },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, rl_clear_screen },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_get_next_history },	/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },	/* Control-p */
-  { ISFUNC, rl_quoted_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISKMAP, (Function *)emacs_ctlx_keymap },	/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-  { ISKMAP, (Function *)emacs_meta_keymap }, /* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, rl_char_search },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_undo_command },		/* Control-_ */
+  { ISFUNC, rl_set_mark },			/* Control-@ */
+  { ISFUNC, rl_beg_of_line },			/* Control-a */
+  { ISFUNC, rl_backward },			/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, rl_delete },			/* Control-d */
+  { ISFUNC, rl_end_of_line },			/* Control-e */
+  { ISFUNC, rl_forward },			/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, rl_rubout },			/* Control-h */
+  { ISFUNC, rl_complete },			/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, rl_clear_screen },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_get_next_history },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },		/* Control-p */
+  { ISFUNC, rl_quoted_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISKMAP, (rl_command_func_t *)emacs_ctlx_keymap },	/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+  { ISKMAP, (rl_command_func_t *)emacs_meta_keymap }, /* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, rl_char_search },			/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_undo_command },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_insert },	/* SPACE */
-  { ISFUNC, rl_insert },	/* ! */
-  { ISFUNC, rl_insert },	/* " */
-  { ISFUNC, rl_insert },	/* # */
-  { ISFUNC, rl_insert },	/* $ */
-  { ISFUNC, rl_insert },	/* % */
-  { ISFUNC, rl_insert },	/* & */
-  { ISFUNC, rl_insert },	/* ' */
-  { ISFUNC, rl_insert },	/* ( */
-  { ISFUNC, rl_insert },	/* ) */
-  { ISFUNC, rl_insert },	/* * */
-  { ISFUNC, rl_insert },	/* + */
-  { ISFUNC, rl_insert },	/* , */
-  { ISFUNC, rl_insert },	/* - */
-  { ISFUNC, rl_insert },	/* . */
-  { ISFUNC, rl_insert },	/* / */
+  { ISFUNC, rl_insert },		/* SPACE */
+  { ISFUNC, rl_insert },		/* ! */
+  { ISFUNC, rl_insert },		/* " */
+  { ISFUNC, rl_insert },		/* # */
+  { ISFUNC, rl_insert },		/* $ */
+  { ISFUNC, rl_insert },		/* % */
+  { ISFUNC, rl_insert },		/* & */
+  { ISFUNC, rl_insert },		/* ' */
+  { ISFUNC, rl_insert },		/* ( */
+  { ISFUNC, rl_insert },		/* ) */
+  { ISFUNC, rl_insert },		/* * */
+  { ISFUNC, rl_insert },		/* + */
+  { ISFUNC, rl_insert },		/* , */
+  { ISFUNC, rl_insert },		/* - */
+  { ISFUNC, rl_insert },		/* . */
+  { ISFUNC, rl_insert },		/* / */
+	
+	  /* Regular digits. */
+  { ISFUNC, rl_insert },		/* 0 */
+  { ISFUNC, rl_insert },		/* 1 */
+  { ISFUNC, rl_insert },		/* 2 */
+  { ISFUNC, rl_insert },		/* 3 */
+  { ISFUNC, rl_insert },		/* 4 */
+  { ISFUNC, rl_insert },		/* 5 */
+  { ISFUNC, rl_insert },		/* 6 */
+  { ISFUNC, rl_insert },		/* 7 */
+  { ISFUNC, rl_insert },		/* 8 */
+  { ISFUNC, rl_insert },		/* 9 */
 
-  /* Regular digits. */
-  { ISFUNC, rl_insert },	/* 0 */
-  { ISFUNC, rl_insert },	/* 1 */
-  { ISFUNC, rl_insert },	/* 2 */
-  { ISFUNC, rl_insert },	/* 3 */
-  { ISFUNC, rl_insert },	/* 4 */
-  { ISFUNC, rl_insert },	/* 5 */
-  { ISFUNC, rl_insert },	/* 6 */
-  { ISFUNC, rl_insert },	/* 7 */
-  { ISFUNC, rl_insert },	/* 8 */
-  { ISFUNC, rl_insert },	/* 9 */
-
   /* A little more punctuation. */
-  { ISFUNC, rl_insert },	/* : */
-  { ISFUNC, rl_insert },	/* ; */
-  { ISFUNC, rl_insert },	/* < */
-  { ISFUNC, rl_insert },	/* = */
-  { ISFUNC, rl_insert },	/* > */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* @ */
+  { ISFUNC, rl_insert },		/* : */
+  { ISFUNC, rl_insert },		/* ; */
+  { ISFUNC, rl_insert },		/* < */
+  { ISFUNC, rl_insert },		/* = */
+  { ISFUNC, rl_insert },		/* > */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },	/* A */
-  { ISFUNC, rl_insert },	/* B */
-  { ISFUNC, rl_insert },	/* C */
-  { ISFUNC, rl_insert },	/* D */
-  { ISFUNC, rl_insert },	/* E */
-  { ISFUNC, rl_insert },	/* F */
-  { ISFUNC, rl_insert },	/* G */
-  { ISFUNC, rl_insert },	/* H */
-  { ISFUNC, rl_insert },	/* I */
-  { ISFUNC, rl_insert },	/* J */
-  { ISFUNC, rl_insert },	/* K */
-  { ISFUNC, rl_insert },	/* L */
-  { ISFUNC, rl_insert },	/* M */
-  { ISFUNC, rl_insert },	/* N */
-  { ISFUNC, rl_insert },	/* O */
-  { ISFUNC, rl_insert },	/* P */
-  { ISFUNC, rl_insert },	/* Q */
-  { ISFUNC, rl_insert },	/* R */
-  { ISFUNC, rl_insert },	/* S */
-  { ISFUNC, rl_insert },	/* T */
-  { ISFUNC, rl_insert },	/* U */
-  { ISFUNC, rl_insert },	/* V */
-  { ISFUNC, rl_insert },	/* W */
-  { ISFUNC, rl_insert },	/* X */
-  { ISFUNC, rl_insert },	/* Y */
-  { ISFUNC, rl_insert },	/* Z */
+  { ISFUNC, rl_insert },		/* A */
+  { ISFUNC, rl_insert },		/* B */
+  { ISFUNC, rl_insert },		/* C */
+  { ISFUNC, rl_insert },		/* D */
+  { ISFUNC, rl_insert },		/* E */
+  { ISFUNC, rl_insert },		/* F */
+  { ISFUNC, rl_insert },		/* G */
+  { ISFUNC, rl_insert },		/* H */
+  { ISFUNC, rl_insert },		/* I */
+  { ISFUNC, rl_insert },		/* J */
+  { ISFUNC, rl_insert },		/* K */
+  { ISFUNC, rl_insert },		/* L */
+  { ISFUNC, rl_insert },		/* M */
+  { ISFUNC, rl_insert },		/* N */
+  { ISFUNC, rl_insert },		/* O */
+  { ISFUNC, rl_insert },		/* P */
+  { ISFUNC, rl_insert },		/* Q */
+  { ISFUNC, rl_insert },		/* R */
+  { ISFUNC, rl_insert },		/* S */
+  { ISFUNC, rl_insert },		/* T */
+  { ISFUNC, rl_insert },		/* U */
+  { ISFUNC, rl_insert },		/* V */
+  { ISFUNC, rl_insert },		/* W */
+  { ISFUNC, rl_insert },		/* X */
+  { ISFUNC, rl_insert },		/* Y */
+  { ISFUNC, rl_insert },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_insert },	/* [ */
-  { ISFUNC, rl_insert },	/* \ */
-  { ISFUNC, rl_insert },	/* ] */
-  { ISFUNC, rl_insert },	/* ^ */
-  { ISFUNC, rl_insert },	/* _ */
-  { ISFUNC, rl_insert },	/* ` */
+  { ISFUNC, rl_insert },		/* [ */
+  { ISFUNC, rl_insert },		/* \ */
+  { ISFUNC, rl_insert },		/* ] */
+  { ISFUNC, rl_insert },		/* ^ */
+  { ISFUNC, rl_insert },		/* _ */
+  { ISFUNC, rl_insert },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },	/* a */
-  { ISFUNC, rl_insert },	/* b */
-  { ISFUNC, rl_insert },	/* c */
-  { ISFUNC, rl_insert },	/* d */
-  { ISFUNC, rl_insert },	/* e */
-  { ISFUNC, rl_insert },	/* f */
-  { ISFUNC, rl_insert },	/* g */
-  { ISFUNC, rl_insert },	/* h */
-  { ISFUNC, rl_insert },	/* i */
-  { ISFUNC, rl_insert },	/* j */
-  { ISFUNC, rl_insert },	/* k */
-  { ISFUNC, rl_insert },	/* l */
-  { ISFUNC, rl_insert },	/* m */
-  { ISFUNC, rl_insert },	/* n */
-  { ISFUNC, rl_insert },	/* o */
-  { ISFUNC, rl_insert },	/* p */
-  { ISFUNC, rl_insert },	/* q */
-  { ISFUNC, rl_insert },	/* r */
-  { ISFUNC, rl_insert },	/* s */
-  { ISFUNC, rl_insert },	/* t */
-  { ISFUNC, rl_insert },	/* u */
-  { ISFUNC, rl_insert },	/* v */
-  { ISFUNC, rl_insert },	/* w */
-  { ISFUNC, rl_insert },	/* x */
-  { ISFUNC, rl_insert },	/* y */
-  { ISFUNC, rl_insert },	/* z */
+  { ISFUNC, rl_insert },		/* a */
+  { ISFUNC, rl_insert },		/* b */
+  { ISFUNC, rl_insert },		/* c */
+  { ISFUNC, rl_insert },		/* d */
+  { ISFUNC, rl_insert },		/* e */
+  { ISFUNC, rl_insert },		/* f */
+  { ISFUNC, rl_insert },		/* g */
+  { ISFUNC, rl_insert },		/* h */
+  { ISFUNC, rl_insert },		/* i */
+  { ISFUNC, rl_insert },		/* j */
+  { ISFUNC, rl_insert },		/* k */
+  { ISFUNC, rl_insert },		/* l */
+  { ISFUNC, rl_insert },		/* m */
+  { ISFUNC, rl_insert },		/* n */
+  { ISFUNC, rl_insert },		/* o */
+  { ISFUNC, rl_insert },		/* p */
+  { ISFUNC, rl_insert },		/* q */
+  { ISFUNC, rl_insert },		/* r */
+  { ISFUNC, rl_insert },		/* s */
+  { ISFUNC, rl_insert },		/* t */
+  { ISFUNC, rl_insert },		/* u */
+  { ISFUNC, rl_insert },		/* v */
+  { ISFUNC, rl_insert },		/* w */
+  { ISFUNC, rl_insert },		/* x */
+  { ISFUNC, rl_insert },		/* y */
+  { ISFUNC, rl_insert },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, rl_insert },	/* { */
-  { ISFUNC, rl_insert },	/* | */
-  { ISFUNC, rl_insert },	/* } */
-  { ISFUNC, rl_insert },	/* ~ */
-  { ISFUNC, rl_rubout },	/* RUBOUT */
+  { ISFUNC, rl_insert },		/* { */
+  { ISFUNC, rl_insert },		/* | */
+  { ISFUNC, rl_insert },		/* } */
+  { ISFUNC, rl_insert },		/* ~ */
+  { ISFUNC, rl_rubout },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Pure 8-bit characters (128 - 159).
      These might be used in some
      character sets. */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
-  { ISFUNC, rl_insert },	/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
+  { ISFUNC, rl_insert },		/* ? */
 
   /* ISO Latin-1 characters (160 - 255) */
   { ISFUNC, rl_insert },	/* No-break space */
@@ -316,78 +316,78 @@ KEYMAP_ENTRY_ARRAY emacs_standard_keymap
 KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
 
   /* Meta keys.  Just like above, but the high bit is set. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-@ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-a */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-b */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-c */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-d */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-e */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-f */
-  { ISFUNC, rl_abort },		/* Meta-Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-f */
+  { ISFUNC, rl_abort },			/* Meta-Control-g */
   { ISFUNC, rl_backward_kill_word },	/* Meta-Control-h */
-  { ISFUNC, rl_tab_insert },	/* Meta-Control-i */
-  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-j */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-k */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-l */
-  { ISFUNC, rl_vi_editing_mode }, /* Meta-Control-m */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-n */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-o */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-p */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-q */
-  { ISFUNC, rl_revert_line },	/* Meta-Control-r */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-s */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-t */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-u */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-v */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-w */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-x */
-  { ISFUNC, rl_yank_nth_arg },	/* Meta-Control-y */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-z */
+  { ISFUNC, rl_tab_insert },		/* Meta-Control-i */
+  { ISFUNC, rl_vi_editing_mode },	/* Meta-Control-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-l */
+  { ISFUNC, rl_vi_editing_mode }, 	/* Meta-Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-q */
+  { ISFUNC, rl_revert_line },		/* Meta-Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-t */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-x */
+  { ISFUNC, rl_yank_nth_arg },		/* Meta-Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-z */
 
-  { ISFUNC, rl_complete },	/* Meta-Control-[ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-\ */
+  { ISFUNC, rl_complete },		/* Meta-Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-\ */
   { ISFUNC, rl_backward_char_search },	/* Meta-Control-] */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-^ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_set_mark },	/* Meta-SPACE */
-  { ISFUNC, (Function *)0x0 },	/* Meta-! */
-  { ISFUNC, (Function *)0x0 },	/* Meta-" */
-  { ISFUNC, rl_insert_comment },/* Meta-# */
-  { ISFUNC, (Function *)0x0 },	/* Meta-$ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-% */
-  { ISFUNC, rl_tilde_expand },	/* Meta-& */
-  { ISFUNC, (Function *)0x0 },	/* Meta-' */
-  { ISFUNC, (Function *)0x0 },	/* Meta-( */
-  { ISFUNC, (Function *)0x0 },	/* Meta-) */
+  { ISFUNC, rl_set_mark },		/* Meta-SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-! */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-" */
+  { ISFUNC, rl_insert_comment },	/* Meta-# */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-$ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-% */
+  { ISFUNC, rl_tilde_expand },		/* Meta-& */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-' */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-( */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-) */
   { ISFUNC, rl_insert_completions },	/* Meta-* */
-  { ISFUNC, (Function *)0x0 },	/* Meta-+ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-, */
-  { ISFUNC, rl_digit_argument }, /* Meta-- */
-  { ISFUNC, rl_yank_last_arg},	/* Meta-. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-/ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-+ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-, */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-- */
+  { ISFUNC, rl_yank_last_arg},		/* Meta-. */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-/ */
 
   /* Regular digits. */
-  { ISFUNC, rl_digit_argument }, /* Meta-0 */
-  { ISFUNC, rl_digit_argument }, /* Meta-1 */
-  { ISFUNC, rl_digit_argument }, /* Meta-2 */
-  { ISFUNC, rl_digit_argument }, /* Meta-3 */
-  { ISFUNC, rl_digit_argument }, /* Meta-4 */
-  { ISFUNC, rl_digit_argument }, /* Meta-5 */
-  { ISFUNC, rl_digit_argument }, /* Meta-6 */
-  { ISFUNC, rl_digit_argument }, /* Meta-7 */
-  { ISFUNC, rl_digit_argument }, /* Meta-8 */
-  { ISFUNC, rl_digit_argument }, /* Meta-9 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-0 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-1 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-2 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-3 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-4 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-5 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-6 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-7 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-8 */
+  { ISFUNC, rl_digit_argument }, 	/* Meta-9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* Meta-: */
-  { ISFUNC, (Function *)0x0 },		/* Meta-; */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-: */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-; */
   { ISFUNC, rl_beginning_of_history },	/* Meta-< */
   { ISFUNC, rl_possible_completions },	/* Meta-= */
   { ISFUNC, rl_end_of_history },	/* Meta-> */
   { ISFUNC, rl_possible_completions },	/* Meta-? */
-  { ISFUNC, (Function *)0x0 },		/* Meta-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-@ */
 
   /* Uppercase alphabet. */
   { ISFUNC, rl_do_lowercase_version },	/* Meta-A */
@@ -418,456 +418,456 @@ KEYMAP_ENTRY_ARRAY emacs_meta_keymap = {
   { ISFUNC, rl_do_lowercase_version },	/* Meta-Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-[ */	/* was rl_arrow_keys */
   { ISFUNC, rl_delete_horizontal_space },	/* Meta-\ */
-  { ISFUNC, (Function *)0x0 },		/* Meta-] */
-  { ISFUNC, (Function *)0x0 },		/* Meta-^ */
-  { ISFUNC, rl_yank_last_arg },		/* Meta-_ */
-  { ISFUNC, (Function *)0x0 },		/* Meta-` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-^ */
+  { ISFUNC, rl_yank_last_arg },			/* Meta-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Meta-` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-a */
-  { ISFUNC, rl_backward_word },	/* Meta-b */
-  { ISFUNC, rl_capitalize_word }, /* Meta-c */
-  { ISFUNC, rl_kill_word },	/* Meta-d */
-  { ISFUNC, (Function *)0x0 },	/* Meta-e */
-  { ISFUNC, rl_forward_word },	/* Meta-f */
-  { ISFUNC, (Function *)0x0 },	/* Meta-g */
-  { ISFUNC, (Function *)0x0 },	/* Meta-h */
-  { ISFUNC, (Function *)0x0 },	/* Meta-i */
-  { ISFUNC, (Function *)0x0 },	/* Meta-j */
-  { ISFUNC, (Function *)0x0 },	/* Meta-k */
-  { ISFUNC, rl_downcase_word },	/* Meta-l */
-  { ISFUNC, (Function *)0x0 },	/* Meta-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-a */
+  { ISFUNC, rl_backward_word },		/* Meta-b */
+  { ISFUNC, rl_capitalize_word }, 	/* Meta-c */
+  { ISFUNC, rl_kill_word },		/* Meta-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-e */
+  { ISFUNC, rl_forward_word },		/* Meta-f */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-i */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-k */
+  { ISFUNC, rl_downcase_word },		/* Meta-l */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-m */
   { ISFUNC, rl_noninc_forward_search },	/* Meta-n */
-  { ISFUNC, (Function *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-o */	/* was rl_arrow_keys */
   { ISFUNC, rl_noninc_reverse_search },	/* Meta-p */
-  { ISFUNC, (Function *)0x0 },	/* Meta-q */
-  { ISFUNC, rl_revert_line },	/* Meta-r */
-  { ISFUNC, (Function *)0x0 },	/* Meta-s */
-  { ISFUNC, rl_transpose_words }, /* Meta-t */
-  { ISFUNC, rl_upcase_word },	/* Meta-u */
-  { ISFUNC, (Function *)0x0 },	/* Meta-v */
-  { ISFUNC, (Function *)0x0 },	/* Meta-w */
-  { ISFUNC, (Function *)0x0 },	/* Meta-x */
-  { ISFUNC, rl_yank_pop },	/* Meta-y */
-  { ISFUNC, (Function *)0x0 },	/* Meta-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-q */
+  { ISFUNC, rl_revert_line },		/* Meta-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-s */
+  { ISFUNC, rl_transpose_words }, 	/* Meta-t */
+  { ISFUNC, rl_upcase_word },		/* Meta-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-x */
+  { ISFUNC, rl_yank_pop },		/* Meta-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },	/* Meta-{ */
-  { ISFUNC, (Function *)0x0 },	/* Meta-| */
-  { ISFUNC, (Function *)0x0 },	/* Meta-} */
-  { ISFUNC, rl_tilde_expand },	/* Meta-~ */
-  { ISFUNC, rl_backward_kill_word }, /* Meta-rubout */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-{ */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-| */
+  { ISFUNC, (rl_command_func_t *)0x0 },	/* Meta-} */
+  { ISFUNC, rl_tilde_expand },		/* Meta-~ */
+  { ISFUNC, rl_backward_kill_word },	/* Meta-rubout */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 KEYMAP_ENTRY_ARRAY emacs_ctlx_keymap = {
 
   /* Control keys. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, (Function *)0x0 },		/* Control-d */
-  { ISFUNC, (Function *)0x0 },		/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, (Function *)0x0 },		/* Control-h */
-  { ISFUNC, (Function *)0x0 },		/* Control-i */
-  { ISFUNC, (Function *)0x0 },		/* Control-j */
-  { ISFUNC, (Function *)0x0 },		/* Control-k */
-  { ISFUNC, (Function *)0x0 },		/* Control-l */
-  { ISFUNC, (Function *)0x0 },		/* Control-m */
-  { ISFUNC, (Function *)0x0 },		/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, (Function *)0x0 },		/* Control-p */
-  { ISFUNC, (Function *)0x0 },		/* Control-q */
-  { ISFUNC, rl_re_read_init_file },	/* Control-r */
-  { ISFUNC, (Function *)0x0 },		/* Control-s */
-  { ISFUNC, (Function *)0x0 },		/* Control-t */
-  { ISFUNC, rl_undo_command },		/* Control-u */
-  { ISFUNC, (Function *)0x0 },		/* Control-v */
-  { ISFUNC, (Function *)0x0 },		/* Control-w */
-  { ISFUNC, rl_exchange_point_and_mark },/* Control-x */
-  { ISFUNC, (Function *)0x0 },		/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-  { ISFUNC, (Function *)0x0 },		/* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, (Function *)0x0 },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
+  { ISFUNC, rl_re_read_init_file },		/* Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
+  { ISFUNC, rl_undo_command },			/* Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
+  { ISFUNC, rl_exchange_point_and_mark },	/* Control-x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, (Function *)0x0 },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, (Function *)0x0 },		/* # */
-  { ISFUNC, (Function *)0x0 },		/* $ */
-  { ISFUNC, (Function *)0x0 },		/* % */
-  { ISFUNC, (Function *)0x0 },		/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, rl_start_kbd_macro },	/* ( */
-  { ISFUNC, rl_end_kbd_macro  },	/* ) */
-  { ISFUNC, (Function *)0x0 },		/* * */
-  { ISFUNC, (Function *)0x0 },		/* + */
-  { ISFUNC, (Function *)0x0 },		/* , */
-  { ISFUNC, (Function *)0x0 },		/* - */
-  { ISFUNC, (Function *)0x0 },		/* . */
-  { ISFUNC, (Function *)0x0 },		/* / */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, rl_start_kbd_macro },		/* ( */
+  { ISFUNC, rl_end_kbd_macro  },		/* ) */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
 
   /* Regular digits. */
-  { ISFUNC, (Function *)0x0 },		/* 0 */
-  { ISFUNC, (Function *)0x0 },		/* 1 */
-  { ISFUNC, (Function *)0x0 },		/* 2 */
-  { ISFUNC, (Function *)0x0 },		/* 3 */
-  { ISFUNC, (Function *)0x0 },		/* 4 */
-  { ISFUNC, (Function *)0x0 },		/* 5 */
-  { ISFUNC, (Function *)0x0 },		/* 6 */
-  { ISFUNC, (Function *)0x0 },		/* 7 */
-  { ISFUNC, (Function *)0x0 },		/* 8 */
-  { ISFUNC, (Function *)0x0 },		/* 9 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 0 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 1 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 2 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 3 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 4 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 5 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 6 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 7 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 8 */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },	/* : */
-  { ISFUNC, (Function *)0x0 },	/* ; */
-  { ISFUNC, (Function *)0x0 },	/* < */
-  { ISFUNC, (Function *)0x0 },	/* = */
-  { ISFUNC, (Function *)0x0 },	/* > */
-  { ISFUNC, (Function *)0x0 },	/* ? */
-  { ISFUNC, (Function *)0x0 },	/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },	/* A */
-  { ISFUNC, rl_do_lowercase_version },	/* B */
-  { ISFUNC, rl_do_lowercase_version },	/* C */
-  { ISFUNC, rl_do_lowercase_version },	/* D */
-  { ISFUNC, rl_do_lowercase_version },	/* E */
-  { ISFUNC, rl_do_lowercase_version },	/* F */
-  { ISFUNC, rl_do_lowercase_version },	/* G */
-  { ISFUNC, rl_do_lowercase_version },	/* H */
-  { ISFUNC, rl_do_lowercase_version },	/* I */
-  { ISFUNC, rl_do_lowercase_version },	/* J */
-  { ISFUNC, rl_do_lowercase_version },	/* K */
-  { ISFUNC, rl_do_lowercase_version },	/* L */
-  { ISFUNC, rl_do_lowercase_version },	/* M */
-  { ISFUNC, rl_do_lowercase_version },	/* N */
-  { ISFUNC, rl_do_lowercase_version },	/* O */
-  { ISFUNC, rl_do_lowercase_version },	/* P */
-  { ISFUNC, rl_do_lowercase_version },	/* Q */
-  { ISFUNC, rl_do_lowercase_version },	/* R */
-  { ISFUNC, rl_do_lowercase_version },	/* S */
-  { ISFUNC, rl_do_lowercase_version },	/* T */
-  { ISFUNC, rl_do_lowercase_version },	/* U */
-  { ISFUNC, rl_do_lowercase_version },	/* V */
-  { ISFUNC, rl_do_lowercase_version },	/* W */
-  { ISFUNC, rl_do_lowercase_version },	/* X */
-  { ISFUNC, rl_do_lowercase_version },	/* Y */
-  { ISFUNC, rl_do_lowercase_version },	/* Z */
+  { ISFUNC, rl_do_lowercase_version },		/* A */
+  { ISFUNC, rl_do_lowercase_version },		/* B */
+  { ISFUNC, rl_do_lowercase_version },		/* C */
+  { ISFUNC, rl_do_lowercase_version },		/* D */
+  { ISFUNC, rl_do_lowercase_version },		/* E */
+  { ISFUNC, rl_do_lowercase_version },		/* F */
+  { ISFUNC, rl_do_lowercase_version },		/* G */
+  { ISFUNC, rl_do_lowercase_version },		/* H */
+  { ISFUNC, rl_do_lowercase_version },		/* I */
+  { ISFUNC, rl_do_lowercase_version },		/* J */
+  { ISFUNC, rl_do_lowercase_version },		/* K */
+  { ISFUNC, rl_do_lowercase_version },		/* L */
+  { ISFUNC, rl_do_lowercase_version },		/* M */
+  { ISFUNC, rl_do_lowercase_version },		/* N */
+  { ISFUNC, rl_do_lowercase_version },		/* O */
+  { ISFUNC, rl_do_lowercase_version },		/* P */
+  { ISFUNC, rl_do_lowercase_version },		/* Q */
+  { ISFUNC, rl_do_lowercase_version },		/* R */
+  { ISFUNC, rl_do_lowercase_version },		/* S */
+  { ISFUNC, rl_do_lowercase_version },		/* T */
+  { ISFUNC, rl_do_lowercase_version },		/* U */
+  { ISFUNC, rl_do_lowercase_version },		/* V */
+  { ISFUNC, rl_do_lowercase_version },		/* W */
+  { ISFUNC, rl_do_lowercase_version },		/* X */
+  { ISFUNC, rl_do_lowercase_version },		/* Y */
+  { ISFUNC, rl_do_lowercase_version },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* [ */
-  { ISFUNC, (Function *)0x0 },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, (Function *)0x0 },		/* ^ */
-  { ISFUNC, (Function *)0x0 },		/* _ */
-  { ISFUNC, (Function *)0x0 },		/* ` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },		/* a */
-  { ISFUNC, (Function *)0x0 },		/* b */
-  { ISFUNC, (Function *)0x0 },		/* c */
-  { ISFUNC, (Function *)0x0 },		/* d */
-  { ISFUNC, rl_call_last_kbd_macro },	/* e */
-  { ISFUNC, (Function *)0x0 },		/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, (Function *)0x0 },		/* h */
-  { ISFUNC, (Function *)0x0 },		/* i */
-  { ISFUNC, (Function *)0x0 },		/* j */
-  { ISFUNC, (Function *)0x0 },		/* k */
-  { ISFUNC, (Function *)0x0 },		/* l */
-  { ISFUNC, (Function *)0x0 },		/* m */
-  { ISFUNC, (Function *)0x0 },		/* n */
-  { ISFUNC, (Function *)0x0 },		/* o */
-  { ISFUNC, (Function *)0x0 },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, (Function *)0x0 },		/* r */
-  { ISFUNC, (Function *)0x0 },		/* s */
-  { ISFUNC, (Function *)0x0 },		/* t */
-  { ISFUNC, (Function *)0x0 },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, (Function *)0x0 },		/* w */
-  { ISFUNC, (Function *)0x0 },		/* x */
-  { ISFUNC, (Function *)0x0 },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
+  { ISFUNC, rl_call_last_kbd_macro },		/* e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, (Function *)0x0 },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, (Function *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_line },	/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_line },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
Index: readline/funmap.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/funmap.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 funmap.c
--- readline/funmap.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/funmap.c	2003/02/17 12:47:10
@@ -46,7 +46,7 @@ typedef int QSFUNC (const void *, const 
 typedef int QSFUNC ();
 #endif
 
-extern int _rl_qsort_string_compare ();
+extern int _rl_qsort_string_compare __P((char **, char **));
 
 FUNMAP **funmap;
 static int funmap_size;
@@ -108,7 +108,7 @@ static FUNMAP default_funmap[] = {
   { "non-incremental-reverse-search-history", rl_noninc_reverse_search },
   { "non-incremental-forward-search-history-again", rl_noninc_forward_search_again },
   { "non-incremental-reverse-search-history-again", rl_noninc_reverse_search_again },
-#ifdef __CYGWIN32__
+#if defined (__CYGWIN__) || defined (__MINGW32__)
   { "paste-from-clipboard", rl_paste_from_clipboard },
 #endif
   { "possible-completions", rl_possible_completions },
@@ -142,7 +142,6 @@ static FUNMAP default_funmap[] = {
   { "vi-arg-digit", rl_vi_arg_digit },
   { "vi-back-to-indent", rl_vi_back_to_indent },
   { "vi-bWord", rl_vi_bWord },
-  { "vi-bracktype", rl_vi_bracktype },
   { "vi-bword", rl_vi_bword },
   { "vi-change-case", rl_vi_change_case },
   { "vi-change-char", rl_vi_change_char },
@@ -182,13 +181,13 @@ static FUNMAP default_funmap[] = {
   { "vi-yank-to", rl_vi_yank_to },
 #endif /* VI_MODE */
 
- {(char *)NULL, (Function *)NULL }
+ {(char *)NULL, (rl_command_func_t *)NULL }
 };
 
 int
 rl_add_funmap_entry (name, function)
-     char *name;
-     Function *function;
+     const char *name;
+     rl_command_func_t *function;
 {
   if (funmap_entry + 2 >= funmap_size)
     {
@@ -225,21 +224,21 @@ rl_initialize_funmap ()
 /* Produce a NULL terminated array of known function names.  The array
    is sorted.  The array itself is allocated, but not the strings inside.
    You should free () the array when you done, but not the pointrs. */
-char **
+const char **
 rl_funmap_names ()
 {
-  char **result;
+  const char **result;
   int result_size, result_index;
 
   /* Make sure that the function map has been initialized. */
   rl_initialize_funmap ();
 
-  for (result_index = result_size = 0, result = (char **)NULL; funmap[result_index]; result_index++)
+  for (result_index = result_size = 0, result = (const char **)NULL; funmap[result_index]; result_index++)
     {
       if (result_index + 2 > result_size)
 	{
 	  result_size += 20;
-	  result = (char **)xrealloc (result, result_size * sizeof (char *));
+	  result = (const char **)xrealloc (result, result_size * sizeof (char *));
 	}
 
       result[result_index] = funmap[result_index]->name;
@@ -249,12 +248,3 @@ rl_funmap_names ()
   qsort (result, result_index, sizeof (char *), (QSFUNC *)_rl_qsort_string_compare);
   return (result);
 }
-
-/* Things that mean `Control'. */
-char *possible_control_prefixes[] = {
-  "Control-", "C-", "CTRL-", (char *)NULL
-};
-
-char *possible_meta_prefixes[] = {
-  "Meta", "M-", (char *)NULL
-};
Index: readline/histexpand.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/histexpand.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 histexpand.c
--- readline/histexpand.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/histexpand.c	2001/03/06 19:09:25
@@ -56,6 +56,8 @@
 #define HISTORY_WORD_DELIMITERS		" \t\n;&()|<>"
 #define HISTORY_QUOTE_CHARACTERS	"\"'`"
 
+typedef int _hist_search_func_t __P((const char *, int));
+
 static char error_pointer;
 
 static char *subst_lhs;
@@ -91,9 +93,12 @@ char *history_no_expand_chars = " \t\n\r
    The default is 0. */
 int history_quotes_inhibit_expansion = 0;
 
+/* Used to split words by history_tokenize_internal. */
+char *history_word_delimiters = HISTORY_WORD_DELIMITERS;
+
 /* If set, this points to a function that is called to verify that a
    particular history expansion should be performed. */
-Function *history_inhibit_expansion_function;
+rl_linebuf_func_t *history_inhibit_expansion_function;
 
 /* **************************************************************** */
 /*								    */
@@ -122,7 +127,7 @@ static char *search_match;
    line = get_history_event ("!echo:p", &index, 0);  */
 char *
 get_history_event (string, caller_index, delimiting_quote)
-     char *string;
+     const char *string;
      int *caller_index;
      int delimiting_quote;
 {
@@ -130,7 +135,7 @@ get_history_event (string, caller_index,
   register char c;
   HIST_ENTRY *entry;
   int which, sign, local_index, substring_okay;
-  Function *search_func;
+  _hist_search_func_t *search_func;
   char *temp;
 
   /* The event can be specified in a number of ways.
@@ -340,7 +345,8 @@ hist_error(s, start, current, errtype)
       char *s;
       int start, current, errtype;
 {
-  char *temp, *emsg;
+  char *temp;
+  const char *emsg;
   int ll, elen;
 
   ll = current - start;
@@ -622,7 +628,7 @@ history_expand_internal (string, start, 
 	case '&':
 	case 's':
 	  {
-	    char *new_event, *t;
+	    char *new_event;
 	    int delimiter, failed, si, l_temp;
 
 	    if (c == 's')
@@ -741,7 +747,7 @@ history_expand_internal (string, start, 
       char *x;
 
       if (want_quotes == 'q')
-	x = single_quote (temp);
+	x = sh_single_quote (temp);
       else if (want_quotes == 'x')
 	x = quote_breaks (temp);
       else
@@ -816,6 +822,9 @@ history_expand (hstring, output)
   /* Used when adding the string. */
   char *temp;
 
+  if (output == 0)
+    return 0;
+
   /* Setting the history expansion character to 0 inhibits all
      history expansion. */
   if (history_expansion_char == 0)
@@ -865,7 +874,7 @@ history_expand (hstring, output)
 	     history expansion performed on it.
 	     Skip the rest of the line and break out of the loop. */
 	  if (history_comment_char && string[i] == history_comment_char &&
-	      (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS)))
+	      (i == 0 || member (string[i - 1], history_word_delimiters)))
 	    {
 	      while (string[i])
 		i++;
@@ -963,7 +972,7 @@ history_expand (hstring, output)
 	  }
 
 	case -2:		/* history_comment_char */
-	  if (i == 0 || member (string[i - 1], HISTORY_WORD_DELIMITERS))
+	  if (i == 0 || member (string[i - 1], history_word_delimiters))
 	    {
 	      temp = xmalloc (l - i + 1);
 	      strcpy (temp, string + i);
@@ -1151,7 +1160,7 @@ get_history_word_specifier (spec, from, 
 char *
 history_arg_extract (first, last, string)
      int first, last;
-     char *string;
+     const char *string;
 {
   register int i, len;
   char *result;
@@ -1217,13 +1226,18 @@ history_arg_extract (first, last, string
    *INDP. */
 static char **
 history_tokenize_internal (string, wind, indp)
-     char *string;
+     const char *string;
      int wind, *indp;
 {
   char **result;
   register int i, start, result_index, size;
   int len, delimiter;
 
+  /* If we're searching for a string that's not part of a word (e.g., " "),
+     make sure we set *INDP to a reasonable value. */
+  if (indp && wind != -1)
+    *indp = -1;
+
   /* Get a token, and stuff it into RESULT.  The tokens are split
      exactly where the shell would split them. */
   for (i = result_index = size = 0, result = (char **)NULL; string[i]; )
@@ -1298,7 +1312,7 @@ history_tokenize_internal (string, wind,
 	      continue;
 	    }
 
-	  if (!delimiter && (member (string[i], HISTORY_WORD_DELIMITERS)))
+	  if (!delimiter && (member (string[i], history_word_delimiters)))
 	    break;
 
 	  if (!delimiter && member (string[i], HISTORY_QUOTE_CHARACTERS))
@@ -1328,7 +1342,7 @@ history_tokenize_internal (string, wind,
    parsed out of STRING. */
 char **
 history_tokenize (string)
-     char *string;
+     const char *string;
 {
   return (history_tokenize_internal (string, -1, (int *)NULL));
 }
@@ -1345,7 +1359,7 @@ history_find_word (line, ind)
   int i, wind;
 
   words = history_tokenize_internal (line, ind, &wind);
-  if (wind == -1)
+  if (wind == -1 || words == 0)
     return ((char *)NULL);
   s = words[wind];
   for (i = 0; i < wind; i++)
Index: readline/histfile.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/histfile.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 histfile.c
--- readline/histfile.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/histfile.c	2003/02/17 12:47:10
@@ -32,7 +32,7 @@
 #include <stdio.h>
 
 #include <sys/types.h>
-#ifndef _MINIX
+#if HAVE_SYS_FILE_H
 #  include <sys/file.h>
 #endif
 #include "posixstat.h"
@@ -54,12 +54,15 @@
 #  include <strings.h>
 #endif /* !HAVE_STRING_H */
 
+#ifdef __MINGW32__
+#include <io.h>
+#endif
 
 /* If we're compiling for __EMX__ (OS/2) or __CYGWIN__ (cygwin32 environment
    on win 95/98/nt), we want to open files with O_BINARY mode so that there
    is no \n -> \r\n conversion performed.  On other systems, we don't want to
    mess around with O_BINARY at all, so we ensure that it's defined to 0. */
-#if defined (__EMX__) || defined (__CYGWIN__)
+#if defined (__EMX__) || defined (__CYGWIN__) || defined (__MINGW32__)
 #  ifndef O_BINARY
 #    define O_BINARY 0
 #  endif
@@ -79,14 +82,20 @@ extern int errno;
 #include "rlshell.h"
 #include "xmalloc.h"
 
+#ifdef __MINGW32__
+#include "rldefs.h"
+extern char *get_user_registry_string(char *keyName, char* valName);
+#endif
+
 /* Return the string that should be used in the place of this
    filename.  This only matters when you don't specify the
    filename to read_history (), or write_history (). */
 static char *
 history_filename (filename)
-     char *filename;
+     const char *filename;
 {
-  char *return_val, *home;
+  char *return_val;
+  const char *home;
   int home_len;
 
   return_val = filename ? savestring (filename) : (char *)NULL;
@@ -94,10 +103,16 @@ history_filename (filename)
   if (return_val)
     return (return_val);
   
-  home = get_env_value ("HOME");
+  home = sh_get_env_value ("HOME");
 
   if (home == 0)
     {
+#if defined (__MINGW32__) && defined (INITFILES_IN_REGISTRY)
+      return_val = get_user_registry_string (READLINE_REGKEY, HISTFILE_REGVAL);
+      if (return_val)
+        return (return_val);
+      free (return_val);
+#endif	/* __MINGW32__ ... */
       home = ".";
       home_len = 1;
     }
@@ -121,7 +136,7 @@ history_filename (filename)
    successful, or errno if not. */
 int
 read_history (filename)
-     char *filename;
+     const char *filename;
 {
   return (read_history_range (filename, 0, -1));
 }
@@ -133,7 +148,7 @@ read_history (filename)
    ~/.history.  Returns 0 if successful, or errno if not. */
 int
 read_history_range (filename, from, to)
-     char *filename;
+     const char *filename;
      int from, to;
 {
   register int line_start, line_end;
@@ -221,14 +236,15 @@ read_history_range (filename, from, to)
 }
 
 /* Truncate the history file FNAME, leaving only LINES trailing lines.
-   If FNAME is NULL, then use ~/.history. */
+   If FNAME is NULL, then use ~/.history.  Returns 0 on success, errno
+   on failure. */
 int
 history_truncate_file (fname, lines)
-     char *fname;
+     const char *fname;
      int lines;
 {
   register int i;
-  int file, chars_read;
+  int file, chars_read, rv;
   char *buffer, *filename;
   struct stat finfo;
   size_t file_size;
@@ -236,13 +252,27 @@ history_truncate_file (fname, lines)
   buffer = (char *)NULL;
   filename = history_filename (fname);
   file = open (filename, O_RDONLY|O_BINARY, 0666);
+  rv = 0;
 
+  /* Don't try to truncate non-regular files. */
   if (file == -1 || fstat (file, &finfo) == -1)
-    goto truncate_exit;
+    {
+      rv = errno;
+      if (file != -1)
+	close (file);
+      goto truncate_exit;
+    }
 
-  /* Don't try to truncate non-regular files. */
-  if (S_ISREG(finfo.st_mode) == 0)
-    goto truncate_exit;
+  if (S_ISREG (finfo.st_mode) == 0)
+    {
+      close (file);
+#ifdef EFTYPE
+      rv = EFTYPE;
+#else
+      rv = EINVAL;
+#endif
+      goto truncate_exit;
+    }
 
   file_size = (size_t)finfo.st_size;
 
@@ -251,7 +281,11 @@ history_truncate_file (fname, lines)
     {
       close (file);
 #if defined (EFBIG)
-      errno = EFBIG;
+      rv = errno = EFBIG;
+#elif defined (EOVERFLOW)
+      rv = errno = EOVERFLOW;
+#else
+      rv = errno = EINVAL;
 #endif
       goto truncate_exit;
     }
@@ -261,7 +295,10 @@ history_truncate_file (fname, lines)
   close (file);
 
   if (chars_read <= 0)
-    goto truncate_exit;
+    {
+      rv = (chars_read < 0) ? errno : 0;
+      goto truncate_exit;
+    }
 
   /* Count backwards from the end of buffer until we have passed
      LINES lines. */
@@ -302,7 +339,7 @@ history_truncate_file (fname, lines)
   FREE (buffer);
 
   free (filename);
-  return 0;
+  return rv;
 }
 
 /* Workhorse function for writing history.  Writes NELEMENT entries
@@ -310,15 +347,16 @@ history_truncate_file (fname, lines)
    wish to replace FILENAME with the entries. */
 static int
 history_do_write (filename, nelements, overwrite)
-     char *filename;
+     const char *filename;
      int nelements, overwrite;
 {
   register int i;
   char *output;
-  int file, mode;
+  int file, mode, rv;
 
   mode = overwrite ? O_WRONLY|O_CREAT|O_TRUNC|O_BINARY : O_WRONLY|O_APPEND|O_BINARY;
   output = history_filename (filename);
+  rv = 0;
 
   if ((file = open (output, mode, 0600)) == -1)
     {
@@ -352,7 +390,8 @@ history_do_write (filename, nelements, o
 	buffer[j++] = '\n';
       }
 
-    write (file, buffer, buffer_size);
+    if (write (file, buffer, buffer_size) < 0)
+      rv = errno;
     free (buffer);
   }
 
@@ -360,7 +399,7 @@ history_do_write (filename, nelements, o
 
   FREE (output);
 
-  return (0);
+  return (rv);
 }
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
@@ -368,7 +407,7 @@ history_do_write (filename, nelements, o
 int
 append_history (nelements, filename)
      int nelements;
-     char *filename;
+     const char *filename;
 {
   return (history_do_write (filename, nelements, HISTORY_APPEND));
 }
@@ -378,7 +417,7 @@ append_history (nelements, filename)
    are as in read_history ().*/
 int
 write_history (filename)
-     char *filename;
+     const char *filename;
 {
   return (history_do_write (filename, history_length, HISTORY_OVERWRITE));
 }
Index: readline/histlib.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/histlib.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 histlib.h
--- readline/histlib.h	2003/02/16 21:36:30	1.1.1.1
+++ readline/histlib.h	2000/10/30 19:18:45
@@ -22,15 +22,6 @@
 #if !defined (_HISTLIB_H_)
 #define _HISTLIB_H_
 
-/* Function pointers can be declared as (Function *)foo. */
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-#endif /* _FUNCTION_DEF */
-
 #if !defined (STREQ)
 #define STREQ(a, b)	(((a)[0] == (b)[0]) && (strcmp ((a), (b)) == 0))
 #define STREQN(a, b, n) (((n) == 0) ? (1) \
Index: readline/history.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/history.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 history.c
--- readline/history.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/history.c	2001/03/06 18:34:44
@@ -73,7 +73,8 @@ static int history_stifled;
 
 /* If HISTORY_STIFLED is non-zero, then this is the maximum number of
    entries to remember. */
-int max_input_history;
+int history_max_entries;
+int max_input_history;	/* backwards compatibility */
 
 /* The current location of the interactive history pointer.  Just makes
    life easier for outside callers. */
@@ -134,9 +135,7 @@ history_total_bytes ()
 {
   register int i, result;
 
-  result = 0;
-
-  for (i = 0; the_history && the_history[i]; i++)
+  for (i = result = 0; the_history && the_history[i]; i++)
     result += strlen (the_history[i]->line);
 
   return (result);
@@ -217,16 +216,16 @@ history_get (offset)
    is  set to NULL. */
 void
 add_history (string)
-     char *string;
+     const char *string;
 {
   HIST_ENTRY *temp;
 
-  if (history_stifled && (history_length == max_input_history))
+  if (history_stifled && (history_length == history_max_entries))
     {
       register int i;
 
       /* If the history is stifled, and history_length is zero,
-	 and it equals max_input_history, we don't save items. */
+	 and it equals history_max_entries, we don't save items. */
       if (history_length == 0)
 	return;
 
@@ -277,15 +276,15 @@ add_history (string)
 HIST_ENTRY *
 replace_history_entry (which, line, data)
      int which;
-     char *line;
+     const char *line;
      histdata_t data;
 {
-  HIST_ENTRY *temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-  HIST_ENTRY *old_value;
+  HIST_ENTRY *temp, *old_value;
 
   if (which >= history_length)
     return ((HIST_ENTRY *)NULL);
 
+  temp = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
   old_value = the_history[which];
 
   temp->line = savestring (line);
@@ -303,12 +302,12 @@ remove_history (which)
      int which;
 {
   HIST_ENTRY *return_value;
+  register int i;
 
   if (which >= history_length || !history_length)
     return_value = (HIST_ENTRY *)NULL;
   else
     {
-      register int i;
       return_value = the_history[which];
 
       for (i = which; i < history_length; i++)
@@ -325,13 +324,13 @@ void
 stifle_history (max)
      int max;
 {
+  register int i, j;
+
   if (max < 0)
     max = 0;
 
   if (history_length > max)
     {
-      register int i, j;
-
       /* This loses because we cannot free the data. */
       for (i = 0, j = history_length - max; i < j; i++)
 	{
@@ -347,7 +346,7 @@ stifle_history (max)
     }
 
   history_stifled = 1;
-  max_input_history = max;
+  max_input_history = history_max_entries = max;
 }
 
 /* Stop stifling the history.  This returns the previous amount the 
@@ -359,10 +358,10 @@ unstifle_history ()
   if (history_stifled)
     {
       history_stifled = 0;
-      return (-max_input_history);
+      return (-history_max_entries);
     }
 
-  return (max_input_history);
+  return (history_max_entries);
 }
 
 int
Index: readline/history.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/history.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 history.h
--- readline/history.h	2003/02/16 21:36:30	1.1.1.1
+++ readline/history.h	2003/02/17 12:47:10
@@ -22,24 +22,26 @@
 #ifndef _HISTORY_H_
 #define _HISTORY_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #if defined READLINE_LIBRARY
 #  include "rlstdc.h"
+#  include "rltypedefs.h"
 #else
 #  include <readline/rlstdc.h>
+#  include <readline/rltypedefs.h>
 #endif
 
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-#endif
-
 #ifdef __STDC__
 typedef void *histdata_t;
 #else
@@ -68,81 +70,81 @@ typedef struct _hist_state {
 
 /* Begin a session in which the history functions might be used.  This
    just initializes the interactive variables. */
-extern void using_history __P((void));
+READLINE_API extern void using_history __P((void));
 
 /* Return the current HISTORY_STATE of the history. */
-extern HISTORY_STATE *history_get_history_state __P((void));
+READLINE_API extern HISTORY_STATE *history_get_history_state __P((void));
 
 /* Set the state of the current history array to STATE. */
-extern void history_set_history_state __P((HISTORY_STATE *));
+READLINE_API extern void history_set_history_state __P((HISTORY_STATE *));
 
 /* Manage the history list. */
 
 /* Place STRING at the end of the history list.
    The associated data field (if any) is set to NULL. */
-extern void add_history __P((char *));
+READLINE_API extern void add_history __P((const char *));
 
 /* A reasonably useless function, only here for completeness.  WHICH
    is the magic number that tells us which element to delete.  The
    elements are numbered from 0. */
-extern HIST_ENTRY *remove_history __P((int));
+READLINE_API extern HIST_ENTRY *remove_history __P((int));
 
 /* Make the history entry at WHICH have LINE and DATA.  This returns
    the old entry so you can dispose of the data.  In the case of an
    invalid WHICH, a NULL pointer is returned. */
-extern HIST_ENTRY *replace_history_entry __P((int, char *, histdata_t));
+READLINE_API extern HIST_ENTRY *replace_history_entry __P((int, const char *, histdata_t));
 
 /* Clear the history list and start over. */
-extern void clear_history __P((void));
+READLINE_API extern void clear_history __P((void));
 
 /* Stifle the history list, remembering only MAX number of entries. */
-extern void stifle_history __P((int));
+READLINE_API extern void stifle_history __P((int));
 
 /* Stop stifling the history.  This returns the previous amount the
    history was stifled by.  The value is positive if the history was
    stifled, negative if it wasn't. */
-extern int unstifle_history __P((void));
+READLINE_API extern int unstifle_history __P((void));
 
 /* Return 1 if the history is stifled, 0 if it is not. */
-extern int history_is_stifled __P((void));
+READLINE_API extern int history_is_stifled __P((void));
 
 /* Information about the history list. */
 
 /* Return a NULL terminated array of HIST_ENTRY which is the current input
    history.  Element 0 of this list is the beginning of time.  If there
    is no history, return NULL. */
-extern HIST_ENTRY **history_list __P((void));
+READLINE_API extern HIST_ENTRY **history_list __P((void));
 
 /* Returns the number which says what history element we are now
    looking at.  */
-extern int where_history __P((void));
+READLINE_API extern int where_history __P((void));
   
 /* Return the history entry at the current position, as determined by
    history_offset.  If there is no entry there, return a NULL pointer. */
-extern HIST_ENTRY *current_history __P((void));
+READLINE_API extern HIST_ENTRY *current_history __P((void));
 
 /* Return the history entry which is logically at OFFSET in the history
    array.  OFFSET is relative to history_base. */
-extern HIST_ENTRY *history_get __P((int));
+READLINE_API extern HIST_ENTRY *history_get __P((int));
 
 /* Return the number of bytes that the primary history entries are using.
    This just adds up the lengths of the_history->lines. */
-extern int history_total_bytes __P((void));
+READLINE_API extern int history_total_bytes __P((void));
 
 /* Moving around the history list. */
 
 /* Set the position in the history list to POS. */
-extern int history_set_pos __P((int));
+READLINE_API extern int history_set_pos __P((int));
 
 /* Back up history_offset to the previous history entry, and return
    a pointer to that entry.  If there is no previous entry, return
    a NULL pointer. */
-extern HIST_ENTRY *previous_history __P((void));
+READLINE_API extern HIST_ENTRY *previous_history __P((void));
 
 /* Move history_offset forward to the next item in the input_history,
    and return the a pointer to that entry.  If there is no next entry,
    return a NULL pointer. */
-extern HIST_ENTRY *next_history __P((void));
+READLINE_API extern HIST_ENTRY *next_history __P((void));
 
 /* Searching the history list. */
 
@@ -152,45 +154,45 @@ extern HIST_ENTRY *next_history __P((voi
    current_history () is the history entry, and the value of this function
    is the offset in the line of that history entry that the string was
    found in.  Otherwise, nothing is changed, and a -1 is returned. */
-extern int history_search __P((char *, int));
+READLINE_API extern int history_search __P((const char *, int));
 
 /* Search the history for STRING, starting at history_offset.
    The search is anchored: matching lines must begin with string.
    DIRECTION is as in history_search(). */
-extern int history_search_prefix __P((char *, int));
+READLINE_API extern int history_search_prefix __P((const char *, int));
 
 /* Search for STRING in the history list, starting at POS, an
    absolute index into the list.  DIR, if negative, says to search
    backwards from POS, else forwards.
    Returns the absolute index of the history element where STRING
    was found, or -1 otherwise. */
-extern int history_search_pos __P((char *, int, int));
+READLINE_API extern int history_search_pos __P((const char *, int, int));
 
 /* Managing the history file. */
 
 /* Add the contents of FILENAME to the history list, a line at a time.
    If FILENAME is NULL, then read from ~/.history.  Returns 0 if
    successful, or errno if not. */
-extern int read_history __P((char *));
+READLINE_API extern int read_history __P((const char *));
 
 /* Read a range of lines from FILENAME, adding them to the history list.
    Start reading at the FROM'th line and end at the TO'th.  If FROM
    is zero, start at the beginning.  If TO is less than FROM, read
    until the end of the file.  If FILENAME is NULL, then read from
    ~/.history.  Returns 0 if successful, or errno if not. */
-extern int read_history_range __P((char *, int, int));
+READLINE_API extern int read_history_range __P((const char *, int, int));
 
 /* Write the current history to FILENAME.  If FILENAME is NULL,
    then write the history list to ~/.history.  Values returned
    are as in read_history ().  */
-extern int write_history __P((char *));
+READLINE_API extern int write_history __P((const char *));
 
 /* Append NELEMENT entries to FILENAME.  The entries appended are from
    the end of the list minus NELEMENTs up to the end of the list. */
-extern int append_history __P((int, char *));
+READLINE_API extern int append_history __P((int, const char *));
 
 /* Truncate the history file, leaving only the last NLINES lines. */
-extern int history_truncate_file __P((char *, int));
+READLINE_API extern int history_truncate_file __P((const char *, int));
 
 /* History expansion. */
 
@@ -206,12 +208,12 @@ extern int history_truncate_file __P((ch
 
   If an error ocurred in expansion, then OUTPUT contains a descriptive
   error message. */
-extern int history_expand __P((char *, char **));
+READLINE_API extern int history_expand __P((char *, char **));
 
 /* Extract a string segment consisting of the FIRST through LAST
    arguments present in STRING.  Arguments are broken up as in
    the shell. */
-extern char *history_arg_extract __P((int, int, char *));
+READLINE_API extern char *history_arg_extract __P((int, int, const char *));
 
 /* Return the text of the history event beginning at the current
    offset into STRING.  Pass STRING with *INDEX equal to the
@@ -219,27 +221,31 @@ extern char *history_arg_extract __P((in
    DELIMITING_QUOTE is a character that is allowed to end the string
    specification for what to search for in addition to the normal
    characters `:', ` ', `\t', `\n', and sometimes `?'. */
-extern char *get_history_event __P((char *, int *, int));
+READLINE_API extern char *get_history_event __P((const char *, int *, int));
 
 /* Return an array of tokens, much as the shell might.  The tokens are
    parsed out of STRING. */
-extern char **history_tokenize __P((char *));
+READLINE_API extern char **history_tokenize __P((const char *));
 
 /* Exported history variables. */
-extern int history_base;
-extern int history_length;
-extern int max_input_history;
-extern char history_expansion_char;
-extern char history_subst_char;
-extern char history_comment_char;
-extern char *history_no_expand_chars;
-extern char *history_search_delimiter_chars;
-extern int history_quotes_inhibit_expansion;
+READLINE_API extern int history_base;
+READLINE_API extern int history_length;
+READLINE_API extern int history_max_entries;
+READLINE_API extern char history_expansion_char;
+READLINE_API extern char history_subst_char;
+READLINE_API extern char *history_word_delimiters;
+READLINE_API extern char history_comment_char;
+READLINE_API extern char *history_no_expand_chars;
+READLINE_API extern char *history_search_delimiter_chars;
+READLINE_API extern int history_quotes_inhibit_expansion;
+
+/* Backwards compatibility */
+READLINE_API extern int max_input_history;
 
 /* If set, this function is called to decide whether or not a particular
    history expansion should be treated as a special case for the calling
    application and not expanded. */
-extern Function *history_inhibit_expansion_function;
+READLINE_API extern rl_linebuf_func_t *history_inhibit_expansion_function;
 
 #ifdef __cplusplus
 }
Index: readline/histsearch.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/histsearch.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 histsearch.c
--- readline/histsearch.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/histsearch.c	2000/09/28 18:15:52
@@ -63,7 +63,7 @@ char *history_search_delimiter_chars = (
 
 static int
 history_search_internal (string, direction, anchored)
-     char *string;
+     const char *string;
      int direction, anchored;
 {
   register int i, reverse;
@@ -159,7 +159,7 @@ history_search_internal (string, directi
 /* Do a non-anchored search for STRING through the history in DIRECTION. */
 int
 history_search (string, direction)
-     char *string;
+     const char *string;
      int direction;
 {
   return (history_search_internal (string, direction, NON_ANCHORED_SEARCH));
@@ -168,7 +168,7 @@ history_search (string, direction)
 /* Do an anchored search for string through the history in DIRECTION. */
 int
 history_search_prefix (string, direction)
-     char *string;
+     const char *string;
      int direction;
 {
   return (history_search_internal (string, direction, ANCHORED_SEARCH));
@@ -179,7 +179,7 @@ history_search_prefix (string, direction
    which point to begin searching. */
 int
 history_search_pos (string, dir, pos)
-     char *string;
+     const char *string;
      int dir, pos;
 {
   int ret, old;
Index: readline/input.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/input.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 input.c
--- readline/input.c	2003/02/16 21:36:30	1.1.1.1
+++ readline/input.c	2003/02/17 12:47:10
@@ -78,10 +78,14 @@ extern int errno;
 
 /* Non-null means it is a pointer to a function to run while waiting for
    character input. */
-Function *rl_event_hook = (Function *)NULL;
+rl_hook_func_t *rl_event_hook = (rl_hook_func_t *)NULL;
 
-Function *rl_getc_function = rl_getc;
+rl_getc_func_t *rl_getc_function = rl_getc;
 
+static int _keyboard_input_timeout = 100000;		/* 0.1 seconds; it's in usec */
+
+static void rl_gather_tyi ();
+
 /* **************************************************************** */
 /*								    */
 /*			Character Input Buffering       	    */
@@ -147,6 +151,7 @@ rl_unget_char (key)
   return (0);
 }
 
+#ifndef __MINGW32__
 /* If a character is available to be read, then read it
    and stuff it into IBUFFER.  Otherwise, just return. */
 static void
@@ -169,7 +174,7 @@ rl_gather_tyi ()
   FD_SET (tty, &readfds);
   FD_SET (tty, &exceptfds);
   timeout.tv_sec = 0;
-  timeout.tv_usec = 100000;	/* 0.1 seconds */
+  timeout.tv_usec = _keyboard_input_timeout;
   if (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) <= 0)
     return;	/* Nothing to read. */
 #endif
@@ -222,6 +227,18 @@ rl_gather_tyi ()
     }
 }
 
+int
+rl_set_keyboard_input_timeout (u)
+     int u;
+{
+  int o;
+
+  o = _keyboard_input_timeout;
+  if (u > 0)
+    _keyboard_input_timeout = u;
+  return (o);
+}
+
 /* Is there input available to be read on the readline input file
    descriptor?  Only works if the system has select(2) or FIONREAD. */
 int
@@ -244,7 +261,7 @@ _rl_input_available ()
   FD_SET (tty, &readfds);
   FD_SET (tty, &exceptfds);
   timeout.tv_sec = 0;
-  timeout.tv_usec = 100000;	/* 0.1 seconds */
+  timeout.tv_usec = _keyboard_input_timeout;
   return (select (tty + 1, &readfds, (fd_set *)NULL, &exceptfds, &timeout) > 0);
 #endif
 
@@ -255,6 +272,7 @@ _rl_input_available ()
 
   return 0;
 }
+#endif /* !__MINGW32__ */
 
 void
 _rl_insert_typein (c)
@@ -293,6 +311,7 @@ rl_stuff_char (key)
     {
       key = NEWLINE;
       rl_pending_input = EOF;
+      RL_SETSTATE (RL_STATE_INPUTPENDING);
     }
   ibuffer[push_index++] = key;
   if (push_index >= ibuffer_len)
@@ -307,6 +326,16 @@ rl_execute_next (c)
      int c;
 {
   rl_pending_input = c;
+  RL_SETSTATE (RL_STATE_INPUTPENDING);
+  return 0;
+}
+
+/* Clear any pending input pushed with rl_execute_next() */
+int
+rl_clear_pending_input ()
+{
+  rl_pending_input = 0;
+  RL_UNSETSTATE (RL_STATE_INPUTPENDING);
   return 0;
 }
 
@@ -327,7 +356,7 @@ rl_read_key ()
   if (rl_pending_input)
     {
       c = rl_pending_input;
-      rl_pending_input = 0;
+      rl_clear_pending_input ();
     }
   else
     {
@@ -341,6 +370,8 @@ rl_read_key ()
 	  while (rl_event_hook && rl_get_char (&c) == 0)
 	    {
 	      (*rl_event_hook) ();
+	      if (rl_done)		/* XXX - experimental */
+		return ('\n');
 	      rl_gather_tyi ();
 	    }
 	}
@@ -354,6 +385,7 @@ rl_read_key ()
   return (c);
 }
 
+#ifndef __MINGW32__
 int
 rl_getc (stream)
      FILE *stream;
@@ -392,7 +424,7 @@ rl_getc (stream)
 
       if (errno == X_EWOULDBLOCK || errno == X_EAGAIN)
 	{
-	  if (unset_nodelay_mode (fileno (stream)) < 0)
+	  if (sh_unset_nodelay_mode (fileno (stream)) < 0)
 	    return (EOF);
 	  continue;
 	}
@@ -407,3 +439,198 @@ rl_getc (stream)
 	return (EOF);
     }
 }
+#else /* __MINGW32__ */
+#include <windows.h>
+#include <ctype.h>
+#include <conio.h>
+#include <io.h>
+
+#define EXT_PREFIX 0x1f8
+
+#define KEV	   irec.Event.KeyEvent			/* to make life easier  */
+#define KST	   irec.Event.KeyEvent.dwControlKeyState
+
+
+static int pending_key = 0;
+static int pending_count = 0;
+static int pending_prefix = 0;
+
+extern int _rl_last_c_pos;	/* imported from display.c  */
+extern int _rl_last_v_pos;
+extern int rl_dispatching;	/* imported from readline.c  */
+extern int rl_point;
+extern int rl_done;
+extern int rl_visible_prompt_length;
+extern int _rl_screenwidth;		/* imported from terminal.c  */
+
+extern int haveConsole;		/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD rlScreenOrigin, rlScreenEnd;
+extern int rlScreenStart, rlScreenMax;
+static void MouseEventProc(MOUSE_EVENT_RECORD kev);
+
+int rl_getc (stream)
+     FILE *stream;
+{
+  int key;
+
+  if ( pending_count )
+    {
+      --pending_count;
+      if ( pending_prefix && (pending_count & 1) )
+        return pending_prefix;
+      else
+        return pending_key;
+    }
+
+  while ( 1 )
+    {
+      DWORD dummy;
+
+      if (WaitForSingleObject(hStdin, WAIT_FOR_INPUT) != WAIT_OBJECT_0)
+        {
+          if ( rl_done )
+            return( 0 );
+          else
+            continue;
+        }
+      if ( haveConsole & FOR_INPUT )
+        {
+          INPUT_RECORD irec;
+          ReadConsoleInput(hStdin, &irec, 1, &dummy);
+          switch(irec.EventType)
+            {
+            case KEY_EVENT:
+              if ( KEV.bKeyDown 
+		   && ((KEV.wVirtualKeyCode < VK_SHIFT) || (KEV.wVirtualKeyCode > VK_MENU)) )
+                {
+                  int mask = 0;
+
+                  key = KEV.uChar.AsciiChar & 0xff;
+                  if ( KST & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED) )
+                    mask=0x100;
+                  if ( key )
+                    {
+		      /* Ascii direct */
+                      pending_count = KEV.wRepeatCount - 1;
+                      pending_key = key;
+                      pending_prefix = 0;
+                      if ( mask )
+                        key = tolower(key) | mask;
+                    }
+                  else
+		    /* Others prefixed */
+                    {
+                      key = EXT_PREFIX;
+                      if ( mask )
+                        key |= 4;
+                      if (KST & SHIFT_PRESSED)
+                        key |= 1;
+                      if (KST & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED))
+                        key |= 2;
+                      mask |= EXT_PREFIX;
+                      pending_count = (KEV.wRepeatCount << 1) - 1;
+                      pending_key = KEV.wVirtualKeyCode;
+                      pending_prefix = key;
+                    }
+                  return key;
+                }
+              break;
+            case MOUSE_EVENT:
+              if ( (haveConsole & FOR_OUTPUT) && !rl_dispatching )
+                MouseEventProc(irec.Event.MouseEvent);
+            default:
+              break;
+            }
+        }
+      else
+        {
+          ReadFile(hStdin, &key, 1, &dummy, NULL);
+          return key;
+        }
+    }
+}
+
+void MouseEventProc(MOUSE_EVENT_RECORD mev)
+{
+  static DWORD lastButtonState, cstat_flags;
+  static COORD lastButtonPos, src_down_pos;
+
+#define RLPOS_CHANGED	1
+#define SELECT_START	2
+  
+  switch (mev.dwEventFlags )
+    {
+    case 0 :			/* change in button state  */
+
+      /* Cursor setting: 
+	 LEFT_BUTTON_PRESSED sets cursor anywhere on the screen,
+	 thereafter, any change in button state will clipp the cursor
+	 position to the readline range if there has been no cursor
+	 movement. Otherwhise the cursor is reset to its old position.
+      */
+      if (mev.dwButtonState == FROM_LEFT_1ST_BUTTON_PRESSED)
+        {
+          if (lastButtonState == 0)
+            {
+              src_down_pos = mev.dwMousePosition;
+              cstat_flags |= RLPOS_CHANGED | SELECT_START;
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+            }
+        }
+      else
+        {
+          if (cstat_flags & RLPOS_CHANGED)
+            {
+              if ( (mev.dwMousePosition.X == src_down_pos.X)
+		   && (mev.dwMousePosition.Y == src_down_pos.Y) )
+                {
+                  int linear_pos = (int)mev.dwMousePosition.Y * _rl_screenwidth
+		    + (int)mev.dwMousePosition.X;
+                  if (linear_pos < rlScreenStart + rl_visible_prompt_length)
+                    {
+                      linear_pos = rlScreenStart + rl_visible_prompt_length;
+                      mev.dwMousePosition.X = rlScreenOrigin.X + rl_visible_prompt_length;
+                      mev.dwMousePosition.Y = rlScreenOrigin.Y;
+                    }
+                  if (linear_pos > rlScreenMax)
+                    {
+                      linear_pos = rlScreenMax;
+                      mev.dwMousePosition = rlScreenEnd;
+                    }
+                  rl_point = linear_pos - rlScreenStart - rl_visible_prompt_length;
+                  _rl_last_c_pos = mev.dwMousePosition.X - rlScreenOrigin.X;
+                  _rl_last_v_pos = mev.dwMousePosition.Y - rlScreenOrigin.Y;
+                }
+              else
+                {
+                  mev.dwMousePosition.X = rlScreenOrigin.X + _rl_last_c_pos;
+                  mev.dwMousePosition.Y = rlScreenOrigin.Y + _rl_last_v_pos;
+                }
+              SetConsoleCursorPosition(hStdout, mev.dwMousePosition);
+              cstat_flags &= !RLPOS_CHANGED;
+            }
+        }
+      lastButtonState = mev.dwButtonState;
+      lastButtonPos = mev.dwMousePosition;
+      break;
+    case MOUSE_MOVED:		/* the most frequent event */
+    default:      
+      break;
+    }
+}
+
+int _rl_input_available ()
+{
+  if (isatty (fileno (rl_instream)))
+    return (kbhit());
+  return 0;
+}
+
+static void rl_gather_tyi ()
+{
+  while (isatty (fileno (rl_instream)) && kbhit () && ibuffer_space ())
+    rl_stuff_char ((*rl_getc_function) (rl_instream));
+  return;
+}
+#endif /* __MINGW32__ */
Index: readline/isearch.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/isearch.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 isearch.c
--- readline/isearch.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/isearch.c	2001/02/14 12:37:01
@@ -55,7 +55,7 @@
 unsigned char *_rl_isearch_terminators = (unsigned char *)NULL;
 
 /* Variables imported from other files in the readline library. */
-extern HIST_ENTRY *saved_line_for_history;
+extern HIST_ENTRY *_rl_saved_line_for_history;
 
 /* Forward declarations */
 static int rl_search_history __P((int, int));
@@ -64,6 +64,8 @@ static int rl_search_history __P((int, i
    identical lines many times in a row. */
 static char *prev_line_found;
 
+static unsigned char *default_isearch_terminators = "\033\012";
+
 /* Search backwards through the history looking for a string which is typed
    interactively.  Start with the current line. */
 int
@@ -176,6 +178,7 @@ rl_search_history (direction, invoking_k
      been set, we use that value, otherwise we use ESC and C-J. */
   unsigned char *isearch_terminators;
 
+  RL_SETSTATE(RL_STATE_ISEARCH);
   orig_point = rl_point;
   last_found_line = orig_line = where_history ();
   reverse = direction < 0;
@@ -183,10 +186,10 @@ rl_search_history (direction, invoking_k
   allocated_line = (char *)NULL;
 
   isearch_terminators = _rl_isearch_terminators ? _rl_isearch_terminators
-						: (unsigned char *)"\033\012";
+						: default_isearch_terminators;
 
   /* Create an arrary of pointers to the lines that we want to search. */
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
   i = 0;
   if (hlist)
     for (i = 0; hlist[i]; i++);
@@ -197,8 +200,8 @@ rl_search_history (direction, invoking_k
   for (i = 0; i < hlen; i++)
     lines[i] = hlist[i]->line;
 
-  if (saved_line_for_history)
-    lines[i] = saved_line_for_history->line;
+  if (_rl_saved_line_for_history)
+    lines[i] = _rl_saved_line_for_history->line;
   else
     {
       /* Keep track of this so we can free it. */
@@ -232,10 +235,12 @@ rl_search_history (direction, invoking_k
   found = failed = 0;
   for (;;)
     {
-      Function *f = (Function *)NULL;
+      rl_command_func_t *f = (rl_command_func_t *)NULL;
 
       /* Read a key and decide how to proceed. */
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       if (_rl_keymap[c].type == ISFUNC)
 	{
@@ -273,6 +278,8 @@ rl_search_history (direction, invoking_k
 
       if (c >= 0 && (CTRL_CHAR (c) || META_CHAR (c) || c == RUBOUT) && c != CTRL ('G'))
 	{
+	  /* This sets rl_pending_input to c; it will be picked up the next
+	     time rl_read_key is called. */
 	  rl_execute_next (c);
 	  break;
 	}
@@ -287,7 +294,7 @@ rl_search_history (direction, invoking_k
 	  else if (line_index != sline_len)
 	    ++line_index;
 	  else
-	    ding ();
+	    rl_ding ();
 	  break;
 
 	  /* switch directions */
@@ -305,13 +312,14 @@ rl_search_history (direction, invoking_k
 	  if (allocated_line)
 	    free (allocated_line);
 	  free (lines);
+	  RL_UNSETSTATE(RL_STATE_ISEARCH);
 	  return 0;
 
 #if 0
 	/* delete character from search string. */
 	case -3:
 	  if (search_string_index == 0)
-	    ding ();
+	    rl_ding ();
 	  else
 	    {
 	      search_string[--search_string_index] = '\0';
@@ -384,7 +392,7 @@ rl_search_history (direction, invoking_k
       if (failed)
 	{
 	  /* We cannot find the search string.  Ding the bell. */
-	  ding ();
+	  rl_ding ();
 	  i = last_found_line;
 	  continue; 		/* XXX - was break */
 	}
@@ -437,6 +445,8 @@ rl_search_history (direction, invoking_k
   if (allocated_line)
     free (allocated_line);
   free (lines);
+
+  RL_UNSETSTATE(RL_STATE_ISEARCH);
 
   return 0;
 }
Index: readline/keymaps.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/keymaps.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 keymaps.c
--- readline/keymaps.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/keymaps.c	2000/10/30 17:05:43
@@ -61,7 +61,7 @@ rl_make_bare_keymap ()
   for (i = 0; i < KEYMAP_SIZE; i++)
     {
       keymap[i].type = ISFUNC;
-      keymap[i].function = (Function *)NULL;
+      keymap[i].function = (rl_command_func_t *)NULL;
     }
 
   for (i = 'A'; i < ('Z' + 1); i++)
Index: readline/keymaps.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/keymaps.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 keymaps.h
--- readline/keymaps.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/keymaps.h	2003/02/17 12:47:10
@@ -23,6 +23,14 @@
 #ifndef _KEYMAPS_H_
 #define _KEYMAPS_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -30,17 +38,11 @@ extern "C" {
 #if defined (READLINE_LIBRARY)
 #  include "rlstdc.h"
 #  include "chardefs.h"
+#  include "rltypedefs.h"
 #else
 #  include <readline/rlstdc.h>
 #  include <readline/chardefs.h>
-#endif
-
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
+#  include <readline/rltypedefs.h>
 #endif
 
 /* A keymap contains one entry for each key in the ASCII set.
@@ -50,7 +52,7 @@ typedef char **CPPFunction ();
    TYPE says which kind of thing FUNCTION is. */
 typedef struct _keymap_entry {
   char type;
-  Function *function;
+  rl_command_func_t *function;
 } KEYMAP_ENTRY;
 
 /* This must be large enough to hold bindings for all of the characters
@@ -59,7 +61,7 @@ typedef struct _keymap_entry {
 #define KEYMAP_SIZE 256
 
 /* I wanted to make the above structure contain a union of:
-   union { Function *function; struct _keymap_entry *keymap; } value;
+   union { rl_command_func_t *function; struct _keymap_entry *keymap; } value;
    but this made it impossible for me to create a static array.
    Maybe I need C lessons. */
 
@@ -71,35 +73,35 @@ typedef KEYMAP_ENTRY *Keymap;
 #define ISKMAP 1
 #define ISMACR 2
 
-extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
-extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
+READLINE_API extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap;
+READLINE_API extern KEYMAP_ENTRY_ARRAY vi_insertion_keymap, vi_movement_keymap;
 
 /* Return a new, empty keymap.
    Free it with free() when you are done. */
-extern Keymap rl_make_bare_keymap __P((void));
+READLINE_API extern Keymap rl_make_bare_keymap __P((void));
 
 /* Return a new keymap which is a copy of MAP. */
-extern Keymap rl_copy_keymap __P((Keymap));
+READLINE_API extern Keymap rl_copy_keymap __P((Keymap));
 
 /* Return a new keymap with the printing characters bound to rl_insert,
    the lowercase Meta characters bound to run their equivalents, and
    the Meta digits bound to produce numeric arguments. */
-extern Keymap rl_make_keymap __P((void));
+READLINE_API extern Keymap rl_make_keymap __P((void));
 
 /* Free the storage associated with a keymap. */
-extern void rl_discard_keymap __P((Keymap));
+READLINE_API extern void rl_discard_keymap __P((Keymap));
 
 /* These functions actually appear in bind.c */
 
 /* Return the keymap corresponding to a given name.  Names look like
    `emacs' or `emacs-meta' or `vi-insert'.  */
-extern Keymap rl_get_keymap_by_name __P((char *));
+READLINE_API extern Keymap rl_get_keymap_by_name __P((const char *));
 
 /* Return the current keymap. */
-extern Keymap rl_get_keymap __P((void));
+READLINE_API extern Keymap rl_get_keymap __P((void));
 
 /* Set the current keymap to MAP. */
-extern void rl_set_keymap __P((Keymap));
+READLINE_API extern void rl_set_keymap __P((Keymap));
 
 #ifdef __cplusplus
 }
Index: readline/kill.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/kill.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 kill.c
--- readline/kill.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/kill.c	2003/02/17 12:47:10
@@ -264,7 +264,7 @@ rl_backward_kill_line (direction, ignore
   else
     {
       if (!rl_point)
-	ding ();
+	rl_ding ();
       else
 	{
 	  rl_beg_of_line (1, ignore);
@@ -299,7 +299,7 @@ rl_unix_word_rubout (count, key)
   int orig_point;
 
   if (rl_point == 0)
-    ding ();
+    rl_ding ();
   else
     {
       orig_point = rl_point;
@@ -331,7 +331,7 @@ rl_unix_line_discard (count, key)
      int count, key;
 {
   if (rl_point == 0)
-    ding ();
+    rl_ding ();
   else
     {
       rl_kill_text (rl_point, 0);
@@ -512,14 +512,14 @@ rl_yank_nth_arg_internal (count, ignore,
 
   if (entry == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   arg = history_arg_extract (count, count, entry->line);
   if (!arg || !*arg)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -592,7 +592,7 @@ rl_yank_last_arg (count, key)
 }
 
 /* A special paste command for users of Cygnus's cygwin32. */
-#if defined (__CYGWIN32__)
+#if defined (__CYGWIN__) || defined (__MINGW32__)
 #include <windows.h>
 
 int
@@ -625,4 +625,4 @@ rl_paste_from_clipboard (count, key)
     }
   return (0);
 }
-#endif /* __CYGWIN32__ */
+#endif /* __CYGWIN__ */
Index: readline/macro.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/macro.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 macro.c
--- readline/macro.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/macro.c	2000/11/02 17:36:37
@@ -57,12 +57,12 @@
 /*								    */
 /* **************************************************************** */
 
-/* Non-zero means to save keys that we dispatch on in a kbd macro. */
-int _rl_defining_kbd_macro = 0;
-
 /* The currently executing macro string.  If this is non-zero,
    then it is a malloc ()'ed string where input is coming from. */
-char *_rl_executing_macro = (char *)NULL;
+char *rl_executing_macro = (char *)NULL;
+
+/* Non-zero means to save keys that we dispatch on in a kbd macro. */
+int _rl_defining_kbd_macro = 0;
 
 /* The offset in the above string to the next character to be read. */
 static int executing_macro_index;
@@ -95,8 +95,9 @@ _rl_with_macro_input (string)
      char *string;
 {
   _rl_push_executing_macro ();
-  _rl_executing_macro = string;
+  rl_executing_macro = string;
   executing_macro_index = 0;
+  RL_SETSTATE(RL_STATE_MACROINPUT);
 }
 
 /* Return the next character available from a macro, or 0 if
@@ -104,16 +105,16 @@ _rl_with_macro_input (string)
 int
 _rl_next_macro_key ()
 {
-  if (_rl_executing_macro == 0)
+  if (rl_executing_macro == 0)
     return (0);
 
-  if (_rl_executing_macro[executing_macro_index] == 0)
+  if (rl_executing_macro[executing_macro_index] == 0)
     {
       _rl_pop_executing_macro ();
       return (_rl_next_macro_key ());
     }
 
-  return (_rl_executing_macro[executing_macro_index++]);
+  return (rl_executing_macro[executing_macro_index++]);
 }
 
 /* Save the currently executing macro on a stack of saved macros. */
@@ -125,7 +126,7 @@ _rl_push_executing_macro ()
   saver = (struct saved_macro *)xmalloc (sizeof (struct saved_macro));
   saver->next = macro_list;
   saver->sindex = executing_macro_index;
-  saver->string = _rl_executing_macro;
+  saver->string = rl_executing_macro;
 
   macro_list = saver;
 }
@@ -136,21 +137,22 @@ void
 _rl_pop_executing_macro ()
 {
   struct saved_macro *macro;
-
-  if (_rl_executing_macro)
-    free (_rl_executing_macro);
 
-  _rl_executing_macro = (char *)NULL;
+  FREE (rl_executing_macro);
+  rl_executing_macro = (char *)NULL;
   executing_macro_index = 0;
 
   if (macro_list)
     {
       macro = macro_list;
-      _rl_executing_macro = macro_list->string;
+      rl_executing_macro = macro_list->string;
       executing_macro_index = macro_list->sindex;
       macro_list = macro_list->next;
       free (macro);
     }
+
+  if (rl_executing_macro == 0)
+    RL_UNSETSTATE(RL_STATE_MACROINPUT);
 }
 
 /* Add a character to the macro being built. */
@@ -180,14 +182,12 @@ _rl_kill_kbd_macro ()
     }
   current_macro_size = current_macro_index = 0;
 
-  if (_rl_executing_macro)
-    {
-      free (_rl_executing_macro);
-      _rl_executing_macro = (char *) NULL;
-    }
+  FREE (rl_executing_macro);
+  rl_executing_macro = (char *) NULL;
   executing_macro_index = 0;
 
   _rl_defining_kbd_macro = 0;
+  RL_UNSETSTATE(RL_STATE_MACRODEF);
 }
 
 /* Begin defining a keyboard macro.
@@ -215,6 +215,7 @@ rl_start_kbd_macro (ignore1, ignore2)
     current_macro_index = 0;
 
   _rl_defining_kbd_macro = 1;
+  RL_SETSTATE(RL_STATE_MACRODEF);
   return 0;
 }
 
@@ -235,6 +236,7 @@ rl_end_kbd_macro (count, ignore)
   current_macro[current_macro_index] = '\0';
 
   _rl_defining_kbd_macro = 0;
+  RL_UNSETSTATE(RL_STATE_MACRODEF);
 
   return (rl_call_last_kbd_macro (--count, 0));
 }
@@ -250,7 +252,7 @@ rl_call_last_kbd_macro (count, ignore)
 
   if (_rl_defining_kbd_macro)
     {
-      ding ();		/* no recursive macros */
+      rl_ding ();		/* no recursive macros */
       current_macro[--current_macro_index] = '\0';	/* erase this char */
       return 0;
     }
Index: readline/nls.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/nls.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 nls.c
--- readline/nls.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/nls.c	2000/11/03 16:44:27
@@ -105,9 +105,9 @@ _rl_init_eightbit ()
   /* We don't have setlocale.  Finesse it.  Check the environment for the
      appropriate variables and set eight-bit mode if they have the right
      values. */
-  lspec = get_env_value ("LC_ALL");
-  if (lspec == 0) lspec = get_env_value ("LC_CTYPE");
-  if (lspec == 0) lspec = get_env_value ("LANG");
+  lspec = sh_get_env_value ("LC_ALL");
+  if (lspec == 0) lspec = sh_get_env_value ("LC_CTYPE");
+  if (lspec == 0) lspec = sh_get_env_value ("LANG");
   if (lspec == 0 || (t = normalize_codeset (lspec)) == 0)
     return (0);
   for (i = 0; t && legal_lang_values[i]; i++)
Index: readline/parens.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/parens.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 parens.c
--- readline/parens.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/parens.c	2003/02/17 12:47:10
@@ -34,6 +34,10 @@
 #  define HAVE_SELECT
 #endif
 
+#ifdef __MINGW32__
+# include <windows.h>
+#endif
+
 #if defined (HAVE_SELECT)
 #  include <sys/time.h>
 #endif /* HAVE_SELECT */
@@ -58,12 +62,14 @@ static int find_matching_open __P((char 
 
 /* Non-zero means try to blink the matching open parenthesis when the
    close parenthesis is inserted. */
-#if defined (HAVE_SELECT)
+#if defined (HAVE_SELECT) || defined (__MINGW32__)
 int rl_blink_matching_paren = 1;
 #else /* !HAVE_SELECT */
 int rl_blink_matching_paren = 0;
 #endif /* !HAVE_SELECT */
 
+static int _paren_blink_usec = 500000;
+
 /* Change emacs_standard_keymap to have bindings for paren matching when
    ON_OR_OFF is 1, change them back to self_insert when ON_OR_OFF == 0. */
 void
@@ -85,6 +91,18 @@ _rl_enable_paren_matching (on_or_off)
 }
 
 int
+rl_set_paren_blink_timeout (u)
+     int u;
+{
+  int o;
+
+  o = _paren_blink_usec;
+  if (u > 0)
+    _paren_blink_usec = u;
+  return (o);
+}
+
+int
 rl_insert_close (count, invoking_key)
      int count, invoking_key;
 {
@@ -109,14 +127,31 @@ rl_insert_close (count, invoking_key)
       FD_ZERO (&readfds);
       FD_SET (fileno (rl_instream), &readfds);
       timer.tv_sec = 0;
-      timer.tv_usec = 500000;
+      timer.tv_usec = _paren_blink_usec;
 
       orig_point = rl_point;
       rl_point = match_point;
       (*rl_redisplay_function) ();
       ready = select (1, &readfds, (fd_set *)NULL, (fd_set *)NULL, &timer);
       rl_point = orig_point;
-#else /* !HAVE_SELECT */
+#elif defined (__MINGW32__)
+      int orig_point, match_point, ready;
+
+      rl_insert (1, invoking_key);
+      (*rl_redisplay_function) ();
+      match_point =
+	find_matching_open (rl_line_buffer, rl_point - 2, invoking_key);
+
+      /* Emacs might message or ring the bell here, but I don't. */
+      if (match_point < 0)
+	return -1;
+
+      orig_point = rl_point;
+      rl_point = match_point;
+      (*rl_redisplay_function) ();
+      ready = (WaitForSingleObject (GetStdHandle(STD_INPUT_HANDLE), 500) == WAIT_OBJECT_0);
+      rl_point = orig_point;
+#else /* !__MINGW32__ */
       rl_insert (count, invoking_key);
 #endif /* !HAVE_SELECT */
     }
Index: readline/posixdir.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/posixdir.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 posixdir.h
--- readline/posixdir.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/posixdir.h	2003/02/17 12:47:10
@@ -26,6 +26,7 @@
 #if defined (HAVE_DIRENT_H)
 #  include <dirent.h>
 #  define D_NAMLEN(d)   (strlen ((d)->d_name))
+#  define FILENAME(d)   ((d)->d_name)
 #else
 #  if defined (HAVE_SYS_NDIR_H)
 #    include <sys/ndir.h>
@@ -40,7 +41,16 @@
 #    define dirent direct
 #  endif /* !dirent */
 #  define D_NAMLEN(d)   ((d)->d_namlen)
+#  define FILENAME(d)   ((d)->d_name)
 #endif /* !HAVE_DIRENT_H */
+
+#ifdef __MINGW32__
+# undef FILENAME
+# define FILENAME(d) (d).cFileName
+# define closedir(dir) FindClose (dir)
+# undef D_NAMLEN
+# define D_NAMLEN(d) strlen (d.cFileName)
+#endif
 
 #if defined (STRUCT_DIRENT_HAS_D_INO) && !defined (STRUCT_DIRENT_HAS_D_FILENO)
 #  define d_fileno d_ino
Index: readline/readline.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/readline.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 readline.c
--- readline/readline.c	2003/02/16 21:36:31	1.1.1.1
+++ readline/readline.c	2003/02/17 12:47:10
@@ -67,7 +67,7 @@
 #include "xmalloc.h"
 
 #ifndef RL_LIBRARY_VERSION
-#  define RL_LIBRARY_VERSION "4.1"
+#  define RL_LIBRARY_VERSION "4.2"
 #endif
 
 /* Evaluates its arguments multiple times. */
@@ -90,8 +90,9 @@ static void readline_default_bindings __
 /*								    */
 /* **************************************************************** */
 
-char *rl_library_version = RL_LIBRARY_VERSION;
+const char *rl_library_version = RL_LIBRARY_VERSION;
 
+/* True if this is `real' readline as opposed to some stub substitute. */
 int rl_gnu_readline_p = 1;
 
 /* A pointer to the keymap that is currently in use.
@@ -121,8 +122,13 @@ int rl_arg_sign = 1;
 /* Non-zero means we have been called at least once before. */
 static int rl_initialized;
 
+#if 0
 /* If non-zero, this program is running in an EMACS buffer. */
 static int running_in_emacs;
+#endif
+
+/* Flags word encapsulating the current readline state. */
+int rl_readline_state = RL_STATE_NONE;
 
 /* The current offset in the current input line. */
 int rl_point;
@@ -137,7 +143,7 @@ int rl_end;
 int rl_done;
 
 /* The last function executed by readline. */
-Function *rl_last_func = (Function *)NULL;
+rl_command_func_t *rl_last_func = (rl_command_func_t *)NULL;
 
 /* Top level environment for readline_internal (). */
 procenv_t readline_top_level;
@@ -153,7 +159,7 @@ FILE *rl_outstream = (FILE *)NULL;
 int readline_echoing_p = 1;
 
 /* Current prompt. */
-char *rl_prompt;
+char *rl_prompt = (char *)NULL;
 int rl_visible_prompt_length = 0;
 
 /* Set to non-zero by calling application if it has already printed rl_prompt
@@ -165,12 +171,12 @@ int rl_key_sequence_length = 0;
 
 /* If non-zero, then this is the address of a function to call just
    before readline_internal_setup () prints the first prompt. */
-Function *rl_startup_hook = (Function *)NULL;
+rl_hook_func_t *rl_startup_hook = (rl_hook_func_t *)NULL;
 
 /* If non-zero, this is the address of a function to call just before
    readline_internal_setup () returns and readline_internal starts
    reading input characters. */
-Function *rl_pre_input_hook = (Function *)NULL;
+rl_hook_func_t *rl_pre_input_hook = (rl_hook_func_t *)NULL;
 
 /* What we use internally.  You should always refer to RL_LINE_BUFFER. */
 static char *the_line;
@@ -183,7 +189,7 @@ int _rl_eof_char = CTRL ('D');
 int rl_pending_input = 0;
 
 /* Pointer to a useful terminal name. */
-char *rl_terminal_name = (char *)NULL;
+const char *rl_terminal_name = (const char *)NULL;
 
 /* Non-zero means to always use horizontal scrolling in line display. */
 int _rl_horizontal_scroll_mode = 0;
@@ -243,24 +249,37 @@ int _rl_output_meta_chars = 0;
 /* Non-zero means treat 0200 bit in terminal input as Meta bit. */
 int _rl_meta_flag = 0;	/* Forward declaration */
 
+/* Set up the prompt and expand it.  Called from readline() and
+   rl_callback_handler_install (). */
+int
+rl_set_prompt (prompt)
+     const char *prompt;
+{
+  FREE (rl_prompt);
+  rl_prompt = prompt ? savestring (prompt) : (char *)NULL;
+
+  rl_visible_prompt_length = (rl_prompt && *rl_prompt)
+				? rl_expand_prompt (rl_prompt)
+				: 0;
+  return 0;
+}
+  
 /* Read a line of input.  Prompt with PROMPT.  An empty PROMPT means
    none.  A return value of NULL means that EOF was encountered. */
 char *
 readline (prompt)
-     char *prompt;
+     const char *prompt;
 {
   char *value;
 
-  rl_prompt = prompt;
-
   /* If we are at EOF return a NULL string. */
   if (rl_pending_input == EOF)
     {
-      rl_pending_input = 0;
+      rl_clear_pending_input ();
       return ((char *)NULL);
     }
 
-  rl_visible_prompt_length = rl_expand_prompt (rl_prompt);
+  rl_set_prompt (prompt);
 
   rl_initialize ();
   (*rl_prep_term_function) (_rl_meta_flag);
@@ -348,7 +367,7 @@ readline_internal_teardown (eof)
   /* At any rate, it is highly likely that this line has an undo list.  Get
      rid of it now. */
   if (rl_undo_list)
-    free_undo_list ();
+    rl_free_undo_list ();
 
   return (eof ? (char *)NULL : savestring (the_line));
 }
@@ -384,7 +403,9 @@ readline_internal_charloop ()
 	  rl_key_sequence_length = 0;
 	}
 
+      RL_SETSTATE(RL_STATE_READCMD);
       c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_READCMD);
 
       /* EOF typed to a non-blank line is a <NL>. */
       if (c == EOF && rl_end)
@@ -395,6 +416,7 @@ readline_internal_charloop ()
       if (((c == _rl_eof_char && lastc != c) || c == EOF) && !rl_end)
 	{
 #if defined (READLINE_CALLBACKS)
+	  RL_SETSTATE(RL_STATE_DONE);
 	  return (rl_done = 1);
 #else
 	  eof_found = 1;
@@ -403,7 +425,7 @@ readline_internal_charloop ()
 	}
 
       lastc = c;
-      _rl_dispatch ((unsigned char)c, _rl_keymap);
+      _rl_dispatch (c, _rl_keymap);
 
       /* If there was no change in _rl_last_command_was_kill, then no kill
 	 has taken place.  Note that if input is pending we are reading
@@ -491,7 +513,7 @@ _rl_dispatch (key, map)
 {
   int r, newkey;
   char *macro;
-  Function *func;
+  rl_command_func_t *func;
 
   if (META_CHAR (key) && _rl_convert_meta_chars_to_ascii)
     {
@@ -505,7 +527,7 @@ _rl_dispatch (key, map)
 	  return (_rl_dispatch (key, map));
 	}
       else
-	ding ();
+	rl_ding ();
       return 0;
     }
 
@@ -517,7 +539,7 @@ _rl_dispatch (key, map)
     {
     case ISFUNC:
       func = map[key].function;
-      if (func != (Function *)NULL)
+      if (func)
 	{
 	  /* Special case rl_do_lowercase_version (). */
 	  if (func == rl_do_lowercase_version)
@@ -530,13 +552,15 @@ _rl_dispatch (key, map)
 #endif
 
 	  rl_dispatching = 1;
+	  RL_SETSTATE(RL_STATE_DISPATCHING);
 	  r = (*map[key].function)(rl_numeric_arg * rl_arg_sign, key);
+	  RL_UNSETSTATE(RL_STATE_DISPATCHING);
 	  rl_dispatching = 0;
 
 	  /* If we have input pending, then the last command was a prefix
 	     command.  Don't change the state of rl_last_func.  Otherwise,
 	     remember the last command executed in this variable. */
-	  if (!rl_pending_input && map[key].function != rl_digit_argument)
+	  if (rl_pending_input == 0 && map[key].function != rl_digit_argument)
 	    rl_last_func = map[key].function;
 	}
       else
@@ -547,10 +571,18 @@ _rl_dispatch (key, map)
       break;
 
     case ISKMAP:
-      if (map[key].function != (Function *)NULL)
+      if (map[key].function != 0)
 	{
 	  rl_key_sequence_length++;
+
+	  if (key == ESC)
+	    RL_SETSTATE(RL_STATE_METANEXT);
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  newkey = rl_read_key ();
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	  if (key == ESC)
+	    RL_UNSETSTATE(RL_STATE_METANEXT);
+
 	  r = _rl_dispatch (newkey, FUNCTION_TO_KEYMAP (map, key));
 	}
       else
@@ -561,7 +593,7 @@ _rl_dispatch (key, map)
       break;
 
     case ISMACR:
-      if (map[key].function != (Function *)NULL)
+      if (map[key].function != 0)
 	{
 	  macro = savestring ((char *)map[key].function);
 	  _rl_with_macro_input (macro);
@@ -591,8 +623,11 @@ rl_initialize ()
      terminal and data structures. */
   if (!rl_initialized)
     {
+      RL_SETSTATE(RL_STATE_INITIALIZING);
       readline_initialize_everything ();
+      RL_UNSETSTATE(RL_STATE_INITIALIZING);
       rl_initialized++;
+      RL_SETSTATE(RL_STATE_INITIALIZED);
     }
 
   /* Initalize the current line information. */
@@ -600,6 +635,7 @@ rl_initialize ()
 
   /* We aren't done yet.  We haven't even gotten started yet! */
   rl_done = 0;
+  RL_UNSETSTATE(RL_STATE_DONE);
 
   /* Tell the history routines what is going on. */
   start_using_history ();
@@ -608,7 +644,7 @@ rl_initialize ()
   rl_reset_line_state ();
 
   /* No such function typed yet. */
-  rl_last_func = (Function *)NULL;
+  rl_last_func = (rl_command_func_t *)NULL;
 
   /* Parsing of key-bindings begins in an enabled state. */
   _rl_parsing_conditionalized_out = 0;
@@ -658,8 +694,10 @@ readline_initialize_everything ()
 #endif
 #endif
 
-  /* Find out if we are running in Emacs. */
-  running_in_emacs = get_env_value ("EMACS") != (char *)0;
+#if 0
+  /* Find out if we are running in Emacs -- UNUSED. */
+  running_in_emacs = sh_get_env_value ("EMACS") != (char *)0;
+#endif
 
   /* Set up input and output if they are not already set up. */
   if (!rl_instream)
@@ -679,7 +717,9 @@ readline_initialize_everything ()
     rl_line_buffer = xmalloc (rl_line_buffer_len = DEFAULT_BUFFER_SIZE);
 
   /* Initialize the terminal interface. */
-  _rl_init_terminal_io ((char *)NULL);
+  if (rl_terminal_name == 0)
+    rl_terminal_name = sh_get_env_value ("TERM");
+  _rl_init_terminal_io (rl_terminal_name);
 
   /* Bind tty characters to readline functions. */
   readline_default_bindings ();
@@ -696,16 +736,18 @@ readline_initialize_everything ()
   /* XXX */
   if (_rl_horizontal_scroll_mode && _rl_term_autowrap)
     {
-      screenwidth--;
-      screenchars -= screenheight;
+      _rl_screenwidth--;
+      _rl_screenchars -= _rl_screenheight;
     }
 
   /* Override the effect of any `set keymap' assignments in the
      inputrc file. */
   rl_set_keymap_from_edit_mode ();
 
+#ifndef __MINGW32__
   /* Try to bind a common arrow key prefix, if not already bound. */
   bind_arrow_keys ();
+#endif
 
   /* Enable the meta key, if this terminal has one. */
   if (_rl_enable_meta)
@@ -723,13 +765,14 @@ readline_initialize_everything ()
 static void
 readline_default_bindings ()
 {
-  rltty_set_default_bindings (_rl_keymap);
+  rl_tty_set_default_bindings (_rl_keymap);
 }
 
+#ifndef __MINGW32__
 static void
 bind_arrow_keys_internal ()
 {
-  Function *f;
+  rl_command_func_t *f;
 
 #if defined (__MSDOS__)
   f = rl_function_of_keyseq ("\033[0A", _rl_keymap, (int *)NULL);
@@ -781,6 +824,7 @@ bind_arrow_keys ()
 
   _rl_keymap = xkeymap;
 }
+#endif /* !__MINGW32__ */
 
 
 /* **************************************************************** */
@@ -797,19 +841,23 @@ rl_digit_loop ()
 
   rl_save_prompt ();
 
+  RL_SETSTATE(RL_STATE_NUMERICARG);
   sawminus = sawdigits = 0;
   while (1)
     {
       if (rl_numeric_arg > 1000000)
 	{
 	  sawdigits = rl_explicit_arg = rl_numeric_arg = 0;
-	  ding ();
+	  rl_ding ();
 	  rl_restore_prompt ();
 	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
 	  return 1;
 	}
       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg);
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       key = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       /* If we see a key bound to `universal-argument' after seeing digits,
 	 it ends the argument but is otherwise ignored. */
@@ -823,9 +871,12 @@ rl_digit_loop ()
 	    }
 	  else
 	    {
+	      RL_SETSTATE(RL_STATE_MOREINPUT);
 	      key = rl_read_key ();
+	      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 	      rl_restore_prompt ();
 	      rl_clear_message ();
+	      RL_UNSETSTATE(RL_STATE_NUMERICARG);
 	      return (_rl_dispatch (key, _rl_keymap));
 	    }
 	}
@@ -849,10 +900,12 @@ rl_digit_loop ()
 	    rl_explicit_arg = 1;
 	  rl_restore_prompt ();
 	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
 	  return (_rl_dispatch (key, _rl_keymap));
 	}
     }
 
+  RL_UNSETSTATE(RL_STATE_NUMERICARG);
   return 0;
 }
 
@@ -861,7 +914,7 @@ int
 rl_digit_argument (ignore, key)
      int ignore, key;
 {
-  rl_pending_input = key;
+  rl_execute_next (key);
   return (rl_digit_loop ());
 }
 
@@ -869,7 +922,7 @@ rl_digit_argument (ignore, key)
 int
 rl_discard_argument ()
 {
-  ding ();
+  rl_ding ();
   rl_clear_message ();
   _rl_init_argument ();
   return 0;
@@ -906,7 +959,7 @@ rl_universal_argument (count, key)
    function. */
 int
 rl_insert_text (string)
-     char *string;
+     const char *string;
 {
   register int i, l = strlen (string);
 
@@ -999,7 +1052,7 @@ _rl_fix_point (fix_mark_too)
 
 void
 _rl_replace_text (text, start, end)
-     char *text;
+     const char *text;
      int start, end;
 {
   rl_begin_undo_group ();
@@ -1053,7 +1106,7 @@ rl_forward (count, key)
     {
       int end = rl_point + count;
 #if defined (VI_MODE)
-      int lend = rl_end - (rl_editing_mode == vi_mode);
+      int lend = rl_end > 0 ? rl_end - (rl_editing_mode == vi_mode) : rl_end;
 #else
       int lend = rl_end;
 #endif
@@ -1061,7 +1114,7 @@ rl_forward (count, key)
       if (end > lend)
 	{
 	  rl_point = lend;
-	  ding ();
+	  rl_ding ();
 	}
       else
 	rl_point = end;
@@ -1085,7 +1138,7 @@ rl_backward (count, key)
       if (rl_point < count)
 	{
 	  rl_point = 0;
-	  ding ();
+	  rl_ding ();
 	}
       else
         rl_point -= count;
@@ -1132,12 +1185,12 @@ rl_forward_word (count, key)
       /* If we are not in a word, move forward until we are in one.
 	 Then, move forward until we hit a non-alphabetic character. */
       c = the_line[rl_point];
-      if (alphabetic (c) == 0)
+      if (rl_alphabetic (c) == 0)
 	{
 	  while (++rl_point < rl_end)
 	    {
 	      c = the_line[rl_point];
-	      if (alphabetic (c))
+	      if (rl_alphabetic (c))
 		break;
 	    }
 	}
@@ -1146,7 +1199,7 @@ rl_forward_word (count, key)
       while (++rl_point < rl_end)
 	{
 	  c = the_line[rl_point];
-	  if (alphabetic (c) == 0)
+	  if (rl_alphabetic (c) == 0)
 	    break;
 	}
       --count;
@@ -1176,12 +1229,12 @@ rl_backward_word (count, key)
 	 just before point. */
 
       c = the_line[rl_point - 1];
-      if (alphabetic (c) == 0)
+      if (rl_alphabetic (c) == 0)
 	{
 	  while (--rl_point)
 	    {
 	      c = the_line[rl_point - 1];
-	      if (alphabetic (c))
+	      if (rl_alphabetic (c))
 		break;
 	    }
 	}
@@ -1189,7 +1242,7 @@ rl_backward_word (count, key)
       while (rl_point)
 	{
 	  c = the_line[rl_point - 1];
-	  if (alphabetic (c) == 0)
+	  if (rl_alphabetic (c) == 0)
 	    break;
 	  else
 	    --rl_point;
@@ -1199,6 +1252,8 @@ rl_backward_word (count, key)
   return 0;
 }
 
+extern int _rl_current_display_line ();
+
 /* Clear the current line.  Numeric argument to C-l does this. */
 int
 rl_refresh_line (ignore1, ignore2)
@@ -1245,7 +1300,9 @@ rl_arrow_keys (count, c)
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
   switch (_rl_to_upper (ch))
     {
@@ -1266,7 +1323,7 @@ rl_arrow_keys (count, c)
       break;
 
     default:
-      ding ();
+      rl_ding ();
     }
   return 0;
 }
@@ -1352,7 +1409,11 @@ rl_quoted_insert (count, key)
 #if defined (HANDLE_SIGNALS)
   _rl_disable_tty_signals ();
 #endif
+
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
 #if defined (HANDLE_SIGNALS)
   _rl_restore_tty_signals ();
 #endif
@@ -1376,6 +1437,7 @@ rl_newline (count, key)
      int count, key;
 {
   rl_done = 1;
+  RL_SETSTATE(RL_STATE_DONE);
 
 #if defined (VI_MODE)
   if (rl_editing_mode == vi_mode)
@@ -1386,7 +1448,7 @@ rl_newline (count, key)
 #endif /* VI_MODE */
 
   /* If we've been asked to erase empty lines, suppress the final update,
-     since _rl_update_final calls crlf(). */
+     since _rl_update_final calls rl_crlf(). */
   if (rl_erase_empty_line && rl_point == 0 && rl_end == 0)
     return 0;
 
@@ -1419,7 +1481,7 @@ rl_rubout (count, key)
 
   if (!rl_point)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -1455,7 +1517,7 @@ rl_delete (count, key)
 
   if (rl_point == rl_end)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -1611,11 +1673,11 @@ rl_change_case (count, op)
 
 	case CapCase:
 	  the_line[start] = (inword == 0) ? _rl_to_upper (c) : _rl_to_lower (c);
-	  inword = alphabetic (the_line[start]);
+	  inword = rl_alphabetic (the_line[start]);
 	  break;
 
 	default:
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
     }
@@ -1654,7 +1716,7 @@ rl_transpose_words (count, key)
   /* Do some check to make sure that there really are two words. */
   if ((w1_beg == w2_beg) || (w2_beg < w1_end))
     {
-      ding ();
+      rl_ding ();
       rl_point = orig_point;
       return -1;
     }
@@ -1702,7 +1764,7 @@ rl_transpose_chars (count, key)
 
   if (!rl_point || rl_end < 2)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -1746,7 +1808,7 @@ _rl_char_search_internal (count, dir, sc
     {
       if ((dir < 0 && pos <= 0) || (dir > 0 && pos >= rl_end))
 	{
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
 
@@ -1777,7 +1839,10 @@ _rl_char_search (count, fdir, bdir)
 {
   int c;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (count < 0)
     return (_rl_char_search_internal (-count, bdir, c));
   else
@@ -1810,17 +1875,17 @@ rl_backward_char_search (count, key)
 
 /* While we are editing the history, this is the saved
    version of the original line. */
-HIST_ENTRY *saved_line_for_history = (HIST_ENTRY *)NULL;
+HIST_ENTRY *_rl_saved_line_for_history = (HIST_ENTRY *)NULL;
 
 /* Set the history pointer back to the last entry in the history. */
 static void
 start_using_history ()
 {
   using_history ();
-  if (saved_line_for_history)
-    _rl_free_history_entry (saved_line_for_history);
+  if (_rl_saved_line_for_history)
+    _rl_free_history_entry (_rl_saved_line_for_history);
 
-  saved_line_for_history = (HIST_ENTRY *)NULL;
+  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
 }
 
 /* Free the contents (and containing structure) of a HIST_ENTRY. */
@@ -1837,7 +1902,7 @@ _rl_free_history_entry (entry)
 
 /* Perhaps put back the current line if it has changed. */
 int
-maybe_replace_line ()
+rl_maybe_replace_line ()
 {
   HIST_ENTRY *temp;
 
@@ -1852,43 +1917,54 @@ maybe_replace_line ()
   return 0;
 }
 
-/* Put back the saved_line_for_history if there is one. */
+/* Restore the _rl_saved_line_for_history if there is one. */
 int
-maybe_unsave_line ()
+rl_maybe_unsave_line ()
 {
   int line_len;
 
-  if (saved_line_for_history)
+  if (_rl_saved_line_for_history)
     {
-      line_len = strlen (saved_line_for_history->line);
+      line_len = strlen (_rl_saved_line_for_history->line);
 
       if (line_len >= rl_line_buffer_len)
 	rl_extend_line_buffer (line_len);
 
-      strcpy (the_line, saved_line_for_history->line);
-      rl_undo_list = (UNDO_LIST *)saved_line_for_history->data;
-      _rl_free_history_entry (saved_line_for_history);
-      saved_line_for_history = (HIST_ENTRY *)NULL;
+      strcpy (the_line, _rl_saved_line_for_history->line);
+      rl_undo_list = (UNDO_LIST *)_rl_saved_line_for_history->data;
+      _rl_free_history_entry (_rl_saved_line_for_history);
+      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
       rl_end = rl_point = strlen (the_line);
     }
   else
-    ding ();
+    rl_ding ();
   return 0;
 }
 
-/* Save the current line in saved_line_for_history. */
+/* Save the current line in _rl_saved_line_for_history. */
 int
-maybe_save_line ()
+rl_maybe_save_line ()
 {
-  if (saved_line_for_history == 0)
+  if (_rl_saved_line_for_history == 0)
     {
-      saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
-      saved_line_for_history->line = savestring (the_line);
-      saved_line_for_history->data = (char *)rl_undo_list;
+      _rl_saved_line_for_history = (HIST_ENTRY *)xmalloc (sizeof (HIST_ENTRY));
+      _rl_saved_line_for_history->line = savestring (the_line);
+      _rl_saved_line_for_history->data = (char *)rl_undo_list;
     }
   return 0;
 }
 
+int
+_rl_free_saved_history_line ()
+{
+  if (_rl_saved_line_for_history)
+    {
+      _rl_free_history_entry (_rl_saved_line_for_history);
+      _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
+    }
+  return 0;
+}      
+
 /* **************************************************************** */
 /*								    */
 /*			History Commands			    */
@@ -1908,9 +1984,9 @@ int
 rl_end_of_history (count, key)
      int count, key;
 {
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
   using_history ();
-  maybe_unsave_line ();
+  rl_maybe_unsave_line ();
   return 0;
 }
 
@@ -1928,7 +2004,7 @@ rl_get_next_history (count, key)
   if (count == 0)
     return 0;
 
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
 
   temp = (HIST_ENTRY *)NULL;
   while (count)
@@ -1940,7 +2016,7 @@ rl_get_next_history (count, key)
     }
 
   if (temp == 0)
-    maybe_unsave_line ();
+    rl_maybe_unsave_line ();
   else
     {
       line_len = strlen (temp->line);
@@ -1975,10 +2051,10 @@ rl_get_previous_history (count, key)
     return 0;
 
   /* If we don't have a line saved, then save this one. */
-  maybe_save_line ();
+  rl_maybe_save_line ();
 
   /* If the current line has changed, save the changes. */
-  maybe_replace_line ();
+  rl_maybe_replace_line ();
 
   temp = old_temp = (HIST_ENTRY *)NULL;
   while (count)
@@ -1997,7 +2073,7 @@ rl_get_previous_history (count, key)
     temp = old_temp;
 
   if (temp == 0)
-    ding ();
+    rl_ding ();
   else
     {
       line_len = strlen (temp->line);
@@ -2053,7 +2129,7 @@ rl_exchange_point_and_mark (count, key)
 
   if (rl_mark == -1)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   else
Index: readline/readline.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/readline.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 readline.h
--- readline/readline.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/readline.h	2003/02/17 12:47:10
@@ -23,6 +23,14 @@
 #if !defined (_READLINE_H_)
 #define _READLINE_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -56,15 +64,15 @@ typedef struct undo_list {
 } UNDO_LIST;
 
 /* The current undo list for RL_LINE_BUFFER. */
-extern UNDO_LIST *rl_undo_list;
+READLINE_API extern UNDO_LIST *rl_undo_list;
 
 /* The data structure for mapping textual names to code addresses. */
 typedef struct _funmap {
-  char *name;
-  Function *function;
+  const char *name;
+  rl_command_func_t *function;
 } FUNMAP;
 
-extern FUNMAP **funmap;
+READLINE_API extern FUNMAP **funmap;
 
 /* **************************************************************** */
 /*								    */
@@ -73,184 +81,184 @@ extern FUNMAP **funmap;
 /* **************************************************************** */
 
 /* Bindable commands for numeric arguments. */
-extern int rl_digit_argument __P((int, int));
-extern int rl_universal_argument __P((int, int));
+READLINE_API extern int rl_digit_argument __P((int, int));
+READLINE_API extern int rl_universal_argument __P((int, int));
 
 /* Bindable commands for moving the cursor. */
-extern int rl_forward __P((int, int));
-extern int rl_backward __P((int, int));
-extern int rl_beg_of_line __P((int, int));
-extern int rl_end_of_line __P((int, int));
-extern int rl_forward_word __P((int, int));
-extern int rl_backward_word __P((int, int));
-extern int rl_refresh_line __P((int, int));
-extern int rl_clear_screen __P((int, int));
-extern int rl_arrow_keys __P((int, int));
+READLINE_API extern int rl_forward __P((int, int));
+READLINE_API extern int rl_backward __P((int, int));
+READLINE_API extern int rl_beg_of_line __P((int, int));
+READLINE_API extern int rl_end_of_line __P((int, int));
+READLINE_API extern int rl_forward_word __P((int, int));
+READLINE_API extern int rl_backward_word __P((int, int));
+READLINE_API extern int rl_refresh_line __P((int, int));
+READLINE_API extern int rl_clear_screen __P((int, int));
+READLINE_API extern int rl_arrow_keys __P((int, int));
 
 /* Bindable commands for inserting and deleting text. */
-extern int rl_insert __P((int, int));
-extern int rl_quoted_insert __P((int, int));
-extern int rl_tab_insert __P((int, int));
-extern int rl_newline __P((int, int));
-extern int rl_do_lowercase_version __P((int, int));
-extern int rl_rubout __P((int, int));
-extern int rl_delete __P((int, int));
-extern int rl_rubout_or_delete __P((int, int));
-extern int rl_delete_horizontal_space __P((int, int));
-extern int rl_delete_or_show_completions __P((int, int));
-extern int rl_insert_comment __P((int, int));
+READLINE_API extern int rl_insert __P((int, int));
+READLINE_API extern int rl_quoted_insert __P((int, int));
+READLINE_API extern int rl_tab_insert __P((int, int));
+READLINE_API extern int rl_newline __P((int, int));
+READLINE_API extern int rl_do_lowercase_version __P((int, int));
+READLINE_API extern int rl_rubout __P((int, int));
+READLINE_API extern int rl_delete __P((int, int));
+READLINE_API extern int rl_rubout_or_delete __P((int, int));
+READLINE_API extern int rl_delete_horizontal_space __P((int, int));
+READLINE_API extern int rl_delete_or_show_completions __P((int, int));
+READLINE_API extern int rl_insert_comment __P((int, int));
 
 /* Bindable commands for changing case. */
-extern int rl_upcase_word __P((int, int));
-extern int rl_downcase_word __P((int, int));
-extern int rl_capitalize_word __P((int, int));
+READLINE_API extern int rl_upcase_word __P((int, int));
+READLINE_API extern int rl_downcase_word __P((int, int));
+READLINE_API extern int rl_capitalize_word __P((int, int));
 
 /* Bindable commands for transposing characters and words. */
-extern int rl_transpose_words __P((int, int));
-extern int rl_transpose_chars __P((int, int));
+READLINE_API extern int rl_transpose_words __P((int, int));
+READLINE_API extern int rl_transpose_chars __P((int, int));
 
 /* Bindable commands for searching within a line. */
-extern int rl_char_search __P((int, int));
-extern int rl_backward_char_search __P((int, int));
+READLINE_API extern int rl_char_search __P((int, int));
+READLINE_API extern int rl_backward_char_search __P((int, int));
 
 /* Bindable commands for readline's interface to the command history. */
-extern int rl_beginning_of_history __P((int, int));
-extern int rl_end_of_history __P((int, int));
-extern int rl_get_next_history __P((int, int));
-extern int rl_get_previous_history __P((int, int));
+READLINE_API extern int rl_beginning_of_history __P((int, int));
+READLINE_API extern int rl_end_of_history __P((int, int));
+READLINE_API extern int rl_get_next_history __P((int, int));
+READLINE_API extern int rl_get_previous_history __P((int, int));
 
 /* Bindable commands for managing the mark and region. */
-extern int rl_set_mark __P((int, int));
-extern int rl_exchange_point_and_mark __P((int, int));
+READLINE_API extern int rl_set_mark __P((int, int));
+READLINE_API extern int rl_exchange_point_and_mark __P((int, int));
 
 /* Bindable commands to set the editing mode (emacs or vi). */
-extern int rl_vi_editing_mode __P((int, int));
-extern int rl_emacs_editing_mode __P((int, int));
+READLINE_API extern int rl_vi_editing_mode __P((int, int));
+READLINE_API extern int rl_emacs_editing_mode __P((int, int));
 
 /* Bindable commands for managing key bindings. */
-extern int rl_re_read_init_file __P((int, int));
-extern int rl_dump_functions __P((int, int));
-extern int rl_dump_macros __P((int, int));
-extern int rl_dump_variables __P((int, int));
+READLINE_API extern int rl_re_read_init_file __P((int, int));
+READLINE_API extern int rl_dump_functions __P((int, int));
+READLINE_API extern int rl_dump_macros __P((int, int));
+READLINE_API extern int rl_dump_variables __P((int, int));
 
 /* Bindable commands for word completion. */
-extern int rl_complete __P((int, int));
-extern int rl_possible_completions __P((int, int));
-extern int rl_insert_completions __P((int, int));
-extern int rl_menu_complete __P((int, int));
+READLINE_API extern int rl_complete __P((int, int));
+READLINE_API extern int rl_possible_completions __P((int, int));
+READLINE_API extern int rl_insert_completions __P((int, int));
+READLINE_API extern int rl_menu_complete __P((int, int));
 
 /* Bindable commands for killing and yanking text, and managing the kill ring. */
-extern int rl_kill_word __P((int, int));
-extern int rl_backward_kill_word __P((int, int));
-extern int rl_kill_line __P((int, int));
-extern int rl_backward_kill_line __P((int, int));
-extern int rl_kill_full_line __P((int, int));
-extern int rl_unix_word_rubout __P((int, int));
-extern int rl_unix_line_discard __P((int, int));
-extern int rl_copy_region_to_kill __P((int, int));
-extern int rl_kill_region __P((int, int));
-extern int rl_copy_forward_word __P((int, int));
-extern int rl_copy_backward_word __P((int, int));
-extern int rl_yank __P((int, int));
-extern int rl_yank_pop __P((int, int));
-extern int rl_yank_nth_arg __P((int, int));
-extern int rl_yank_last_arg __P((int, int));
-/* Not available unless __CYGWIN32__ is defined. */
-#ifdef __CYGWIN32__
-extern int rl_paste_from_clipboard __P((int, int));
+READLINE_API extern int rl_kill_word __P((int, int));
+READLINE_API extern int rl_backward_kill_word __P((int, int));
+READLINE_API extern int rl_kill_line __P((int, int));
+READLINE_API extern int rl_backward_kill_line __P((int, int));
+READLINE_API extern int rl_kill_full_line __P((int, int));
+READLINE_API extern int rl_unix_word_rubout __P((int, int));
+READLINE_API extern int rl_unix_line_discard __P((int, int));
+READLINE_API extern int rl_copy_region_to_kill __P((int, int));
+READLINE_API extern int rl_kill_region __P((int, int));
+READLINE_API extern int rl_copy_forward_word __P((int, int));
+READLINE_API extern int rl_copy_backward_word __P((int, int));
+READLINE_API extern int rl_yank __P((int, int));
+READLINE_API extern int rl_yank_pop __P((int, int));
+READLINE_API extern int rl_yank_nth_arg __P((int, int));
+READLINE_API extern int rl_yank_last_arg __P((int, int));
+/* Not available unless __CYGWIN__ is defined. */
+#if defined(__CYGWIN__) || defined (__MINGW32__)
+READLINE_API extern int rl_paste_from_clipboard __P((int, int));
 #endif
 
 /* Bindable commands for incremental searching. */
-extern int rl_reverse_search_history __P((int, int));
-extern int rl_forward_search_history __P((int, int));
+READLINE_API extern int rl_reverse_search_history __P((int, int));
+READLINE_API extern int rl_forward_search_history __P((int, int));
 
 /* Bindable keyboard macro commands. */
-extern int rl_start_kbd_macro __P((int, int));
-extern int rl_end_kbd_macro __P((int, int));
-extern int rl_call_last_kbd_macro __P((int, int));
+READLINE_API extern int rl_start_kbd_macro __P((int, int));
+READLINE_API extern int rl_end_kbd_macro __P((int, int));
+READLINE_API extern int rl_call_last_kbd_macro __P((int, int));
 
 /* Bindable undo commands. */
-extern int rl_revert_line __P((int, int));
-extern int rl_undo_command __P((int, int));
+READLINE_API extern int rl_revert_line __P((int, int));
+READLINE_API extern int rl_undo_command __P((int, int));
 
 /* Bindable tilde expansion commands. */
-extern int rl_tilde_expand __P((int, int));
+READLINE_API extern int rl_tilde_expand __P((int, int));
 
 /* Bindable terminal control commands. */
-extern int rl_restart_output __P((int, int));
-extern int rl_stop_output __P((int, int));
+READLINE_API extern int rl_restart_output __P((int, int));
+READLINE_API extern int rl_stop_output __P((int, int));
 
 /* Miscellaneous bindable commands. */
-extern int rl_abort __P((int, int));
-extern int rl_tty_status __P((int, int));
+READLINE_API extern int rl_abort __P((int, int));
+READLINE_API extern int rl_tty_status __P((int, int));
 
 /* Bindable commands for incremental and non-incremental history searching. */
-extern int rl_history_search_forward __P((int, int));
-extern int rl_history_search_backward __P((int, int));
-extern int rl_noninc_forward_search __P((int, int));
-extern int rl_noninc_reverse_search __P((int, int));
-extern int rl_noninc_forward_search_again __P((int, int));
-extern int rl_noninc_reverse_search_again __P((int, int));
+READLINE_API extern int rl_history_search_forward __P((int, int));
+READLINE_API extern int rl_history_search_backward __P((int, int));
+READLINE_API extern int rl_noninc_forward_search __P((int, int));
+READLINE_API extern int rl_noninc_reverse_search __P((int, int));
+READLINE_API extern int rl_noninc_forward_search_again __P((int, int));
+READLINE_API extern int rl_noninc_reverse_search_again __P((int, int));
 
 /* Bindable command used when inserting a matching close character. */
-extern int rl_insert_close __P((int, int));
+READLINE_API extern int rl_insert_close __P((int, int));
 
 /* Not available unless READLINE_CALLBACKS is defined. */
-extern void rl_callback_handler_install __P((char *, VFunction *));
-extern void rl_callback_read_char __P((void));
-extern void rl_callback_handler_remove __P((void));
+READLINE_API extern void rl_callback_handler_install __P((const char *, rl_vcpfunc_t *));
+READLINE_API extern void rl_callback_read_char __P((void));
+READLINE_API extern void rl_callback_handler_remove __P((void));
 
 /* Things for vi mode. Not available unless readline is compiled -DVI_MODE. */
 /* VI-mode bindable commands. */
-extern int rl_vi_redo __P((int, int));
-extern int rl_vi_undo __P((int, int));
-extern int rl_vi_yank_arg __P((int, int));
-extern int rl_vi_fetch_history __P((int, int));
-extern int rl_vi_search_again __P((int, int));
-extern int rl_vi_search __P((int, int));
-extern int rl_vi_complete __P((int, int));
-extern int rl_vi_tilde_expand __P((int, int));
-extern int rl_vi_prev_word __P((int, int));
-extern int rl_vi_next_word __P((int, int));
-extern int rl_vi_end_word __P((int, int));
-extern int rl_vi_insert_beg __P((int, int));
-extern int rl_vi_append_mode __P((int, int));
-extern int rl_vi_append_eol __P((int, int));
-extern int rl_vi_eof_maybe __P((int, int));
-extern int rl_vi_insertion_mode __P((int, int));
-extern int rl_vi_movement_mode __P((int, int));
-extern int rl_vi_arg_digit __P((int, int));
-extern int rl_vi_change_case __P((int, int));
-extern int rl_vi_put __P((int, int));
-extern int rl_vi_column __P((int, int));
-extern int rl_vi_delete_to __P((int, int));
-extern int rl_vi_change_to __P((int, int));
-extern int rl_vi_yank_to __P((int, int));
-extern int rl_vi_delete __P((int, int));
-extern int rl_vi_back_to_indent __P((int, int));
-extern int rl_vi_first_print __P((int, int));
-extern int rl_vi_char_search __P((int, int));
-extern int rl_vi_match __P((int, int));
-extern int rl_vi_change_char __P((int, int));
-extern int rl_vi_subst __P((int, int));
-extern int rl_vi_overstrike __P((int, int));
-extern int rl_vi_overstrike_delete __P((int, int));
-extern int rl_vi_replace __P((int, int));
-extern int rl_vi_set_mark __P((int, int));
-extern int rl_vi_goto_mark __P((int, int));
+READLINE_API extern int rl_vi_redo __P((int, int));
+READLINE_API extern int rl_vi_undo __P((int, int));
+READLINE_API extern int rl_vi_yank_arg __P((int, int));
+READLINE_API extern int rl_vi_fetch_history __P((int, int));
+READLINE_API extern int rl_vi_search_again __P((int, int));
+READLINE_API extern int rl_vi_search __P((int, int));
+READLINE_API extern int rl_vi_complete __P((int, int));
+READLINE_API extern int rl_vi_tilde_expand __P((int, int));
+READLINE_API extern int rl_vi_prev_word __P((int, int));
+READLINE_API extern int rl_vi_next_word __P((int, int));
+READLINE_API extern int rl_vi_end_word __P((int, int));
+READLINE_API extern int rl_vi_insert_beg __P((int, int));
+READLINE_API extern int rl_vi_append_mode __P((int, int));
+READLINE_API extern int rl_vi_append_eol __P((int, int));
+READLINE_API extern int rl_vi_eof_maybe __P((int, int));
+READLINE_API extern int rl_vi_insertion_mode __P((int, int));
+READLINE_API extern int rl_vi_movement_mode __P((int, int));
+READLINE_API extern int rl_vi_arg_digit __P((int, int));
+READLINE_API extern int rl_vi_change_case __P((int, int));
+READLINE_API extern int rl_vi_put __P((int, int));
+READLINE_API extern int rl_vi_column __P((int, int));
+READLINE_API extern int rl_vi_delete_to __P((int, int));
+READLINE_API extern int rl_vi_change_to __P((int, int));
+READLINE_API extern int rl_vi_yank_to __P((int, int));
+READLINE_API extern int rl_vi_delete __P((int, int));
+READLINE_API extern int rl_vi_back_to_indent __P((int, int));
+READLINE_API extern int rl_vi_first_print __P((int, int));
+READLINE_API extern int rl_vi_char_search __P((int, int));
+READLINE_API extern int rl_vi_match __P((int, int));
+READLINE_API extern int rl_vi_change_char __P((int, int));
+READLINE_API extern int rl_vi_subst __P((int, int));
+READLINE_API extern int rl_vi_overstrike __P((int, int));
+READLINE_API extern int rl_vi_overstrike_delete __P((int, int));
+READLINE_API extern int rl_vi_replace __P((int, int));
+READLINE_API extern int rl_vi_set_mark __P((int, int));
+READLINE_API extern int rl_vi_goto_mark __P((int, int));
 
 /* VI-mode utility functions. */
-extern int rl_vi_check __P((void));
-extern int rl_vi_domove __P((int, int *));
-extern int rl_vi_bracktype __P((int));
+READLINE_API extern int rl_vi_check __P((void));
+READLINE_API extern int rl_vi_domove __P((int, int *));
+READLINE_API extern int rl_vi_bracktype __P((int));
 
 /* VI-mode pseudo-bindable commands, used as utility functions. */
-extern int rl_vi_fWord __P((int, int));
-extern int rl_vi_bWord __P((int, int));
-extern int rl_vi_eWord __P((int, int));
-extern int rl_vi_fword __P((int, int));
-extern int rl_vi_bword __P((int, int));
-extern int rl_vi_eword __P((int, int));
+READLINE_API extern int rl_vi_fWord __P((int, int));
+READLINE_API extern int rl_vi_bWord __P((int, int));
+READLINE_API extern int rl_vi_eWord __P((int, int));
+READLINE_API extern int rl_vi_fword __P((int, int));
+READLINE_API extern int rl_vi_bword __P((int, int));
+READLINE_API extern int rl_vi_eword __P((int, int));
 
 /* **************************************************************** */
 /*								    */
@@ -260,142 +268,172 @@ extern int rl_vi_eword __P((int, int));
 
 /* Readline functions. */
 /* Read a line of input.  Prompt with PROMPT.  A NULL PROMPT means none. */
-extern char *readline __P((char *));
+READLINE_API extern char *readline __P((const char *));
 
-extern int rl_initialize __P((void));
+READLINE_API extern int rl_set_prompt __P((const char *));
+READLINE_API extern int rl_expand_prompt __P((char *));
 
-extern int rl_discard_argument __P((void));
+READLINE_API extern int rl_initialize __P((void));
 
+/* Undocumented; unused by readline */
+READLINE_API extern int rl_discard_argument __P((void));
+
 /* Utility functions to bind keys to readline commands. */
-extern int rl_add_defun __P((char *, Function *, int));
-extern int rl_bind_key __P((int, Function *));
-extern int rl_bind_key_in_map __P((int, Function *, Keymap));
-extern int rl_unbind_key __P((int));
-extern int rl_unbind_key_in_map __P((int, Keymap));
-extern int rl_unbind_function_in_map __P((Function *, Keymap));
-extern int rl_unbind_command_in_map __P((char *, Keymap));
-extern int rl_set_key __P((char *, Function *, Keymap));
-extern int rl_generic_bind __P((int, char *, char *, Keymap));
-extern int rl_variable_bind __P((char *, char *));
+READLINE_API extern int rl_add_defun __P((const char *, rl_command_func_t *, int));
+READLINE_API extern int rl_bind_key __P((int, rl_command_func_t *));
+READLINE_API extern int rl_bind_key_in_map __P((int, rl_command_func_t *, Keymap));
+READLINE_API extern int rl_unbind_key __P((int));
+READLINE_API extern int rl_unbind_key_in_map __P((int, Keymap));
+READLINE_API extern int rl_unbind_function_in_map __P((rl_command_func_t *, Keymap));
+READLINE_API extern int rl_unbind_command_in_map __P((const char *, Keymap));
+READLINE_API extern int rl_set_key __P((const char *, rl_command_func_t *, Keymap));
+READLINE_API extern int rl_generic_bind __P((int, const char *, char *, Keymap));
+READLINE_API extern int rl_variable_bind __P((const char *, const char *));
 
 /* Backwards compatibility, use rl_generic_bind instead. */
-extern int rl_macro_bind __P((char *, char *, Keymap));
+READLINE_API extern int rl_macro_bind __P((const char *, const char *, Keymap));
 
 /* Undocumented in the texinfo manual; not really useful to programs. */
-extern int rl_translate_keyseq __P((char *, char *, int *));
-extern char *rl_untranslate_keyseq __P((int));
+READLINE_API extern int rl_translate_keyseq __P((const char *, char *, int *));
+READLINE_API extern char *rl_untranslate_keyseq __P((int));
 
-extern Function *rl_named_function __P((char *));
-extern Function *rl_function_of_keyseq __P((char *, Keymap, int *));
+READLINE_API extern rl_command_func_t *rl_named_function __P((const char *));
+READLINE_API extern rl_command_func_t *rl_function_of_keyseq __P((const char *, Keymap, int *));
 
-extern void rl_list_funmap_names __P((void));
-extern char **rl_invoking_keyseqs_in_map __P((Function *, Keymap));
-extern char **rl_invoking_keyseqs __P((Function *));
+READLINE_API extern void rl_list_funmap_names __P((void));
+READLINE_API extern char **rl_invoking_keyseqs_in_map __P((rl_command_func_t *, Keymap));
+READLINE_API extern char **rl_invoking_keyseqs __P((rl_command_func_t *));
  
-extern void rl_function_dumper __P((int));
-extern void rl_macro_dumper __P((int));
-extern void rl_variable_dumper __P((int));
+READLINE_API extern void rl_function_dumper __P((int));
+READLINE_API extern void rl_macro_dumper __P((int));
+READLINE_API extern void rl_variable_dumper __P((int));
 
-extern int rl_read_init_file __P((char *));
-extern int rl_parse_and_bind __P((char *));
+READLINE_API extern int rl_read_init_file __P((const char *));
+READLINE_API extern int rl_parse_and_bind __P((char *));
 
 /* Functions for manipulating keymaps. */
-extern Keymap rl_make_bare_keymap __P((void));
-extern Keymap rl_copy_keymap __P((Keymap));
-extern Keymap rl_make_keymap __P((void));
-extern void rl_discard_keymap __P((Keymap));
-
-extern Keymap rl_get_keymap_by_name __P((char *));
-extern char *rl_get_keymap_name __P((Keymap));
-extern void rl_set_keymap __P((Keymap));
-extern Keymap rl_get_keymap __P((void));
-extern void rl_set_keymap_from_edit_mode __P((void));
-extern char *rl_get_keymap_name_from_edit_mode __P((void));
+READLINE_API extern Keymap rl_make_bare_keymap __P((void));
+READLINE_API extern Keymap rl_copy_keymap __P((Keymap));
+READLINE_API extern Keymap rl_make_keymap __P((void));
+READLINE_API extern void rl_discard_keymap __P((Keymap));
+
+READLINE_API extern Keymap rl_get_keymap_by_name __P((const char *));
+READLINE_API extern char *rl_get_keymap_name __P((Keymap));
+READLINE_API extern void rl_set_keymap __P((Keymap));
+READLINE_API extern Keymap rl_get_keymap __P((void));
+/* Undocumented; used internally only. */
+READLINE_API extern void rl_set_keymap_from_edit_mode __P((void));
+READLINE_API extern char *rl_get_keymap_name_from_edit_mode __P((void));
 
 /* Functions for manipulating the funmap, which maps command names to functions. */
-extern int rl_add_funmap_entry __P((char *, Function *));
-extern void rl_initialize_funmap __P((void));
-extern char **rl_funmap_names __P((void));
+READLINE_API extern int rl_add_funmap_entry __P((const char *, rl_command_func_t *));
+READLINE_API extern const char **rl_funmap_names __P((void));
+/* Undocumented, only used internally -- there is only one funmap, and this
+   function may be called only once. */
+READLINE_API extern void rl_initialize_funmap __P((void));
 
 /* Utility functions for managing keyboard macros. */
-extern void rl_push_macro_input __P((char *));
+READLINE_API extern void rl_push_macro_input __P((char *));
 
 /* Functions for undoing, from undo.c */
-extern void rl_add_undo __P((enum undo_code, int, int, char *));
-extern void free_undo_list __P((void));
-extern int rl_do_undo __P((void));
-extern int rl_begin_undo_group __P((void));
-extern int rl_end_undo_group __P((void));
-extern int rl_modifying __P((int, int));
+READLINE_API extern void rl_add_undo __P((enum undo_code, int, int, char *));
+READLINE_API extern void rl_free_undo_list __P((void));
+READLINE_API extern int rl_do_undo __P((void));
+READLINE_API extern int rl_begin_undo_group __P((void));
+READLINE_API extern int rl_end_undo_group __P((void));
+READLINE_API extern int rl_modifying __P((int, int));
 
 /* Functions for redisplay. */
-extern void rl_redisplay __P((void));
-extern int rl_on_new_line __P((void));
-extern int rl_on_new_line_with_prompt __P((void));
-extern int rl_forced_update_display __P((void));
-extern int rl_clear_message __P((void));
-extern int rl_reset_line_state __P((void));
+READLINE_API extern void rl_redisplay __P((void));
+READLINE_API extern int rl_on_new_line __P((void));
+READLINE_API extern int rl_on_new_line_with_prompt __P((void));
+READLINE_API extern int rl_forced_update_display __P((void));
+READLINE_API extern int rl_clear_message __P((void));
+READLINE_API extern int rl_reset_line_state __P((void));
+READLINE_API extern int rl_crlf __P((void));
 
 #if (defined (__STDC__) || defined (__cplusplus)) && defined (USE_VARARGS) && defined (PREFER_STDARG)
-extern int rl_message (const char *, ...);
+READLINE_API extern int rl_message (const char *, ...);
 #else
-extern int rl_message ();
+READLINE_API extern int rl_message ();
 #endif
 
+READLINE_API extern int rl_show_char __P((int));
+
 /* Undocumented in texinfo manual. */
-extern int rl_show_char __P((int));
-extern int rl_character_len __P((int, int));
-extern int crlf __P((void));
+READLINE_API extern int rl_character_len __P((int, int));
 
 /* Save and restore internal prompt redisplay information. */
-extern void rl_save_prompt __P((void));
-extern void rl_restore_prompt __P((void));
+READLINE_API extern void rl_save_prompt __P((void));
+READLINE_API extern void rl_restore_prompt __P((void));
 
 /* Modifying text. */
-extern int rl_insert_text __P((char *));
-extern int rl_delete_text __P((int, int));
-extern int rl_kill_text __P((int, int));
-extern char *rl_copy_text __P((int, int));
+READLINE_API extern int rl_insert_text __P((const char *));
+READLINE_API extern int rl_delete_text __P((int, int));
+READLINE_API extern int rl_kill_text __P((int, int));
+READLINE_API extern char *rl_copy_text __P((int, int));
 
 /* Terminal and tty mode management. */
-extern void rl_prep_terminal __P((int));
-extern void rl_deprep_terminal __P((void));
-extern void rltty_set_default_bindings __P((Keymap));
+READLINE_API extern void rl_prep_terminal __P((int));
+READLINE_API extern void rl_deprep_terminal __P((void));
+READLINE_API extern void rl_tty_set_default_bindings __P((Keymap));
+
+READLINE_API extern int rl_reset_terminal __P((const char *));
+READLINE_API extern void rl_resize_terminal __P((void));
+READLINE_API extern void rl_set_screen_size __P((int, int));
+READLINE_API extern void rl_get_screen_size __P((int *, int *));
 
-extern int rl_reset_terminal __P((char *));
-extern void rl_resize_terminal __P((void));
+/* Functions for character input. */
+READLINE_API extern int rl_stuff_char __P((int));
+READLINE_API extern int rl_execute_next __P((int));
+READLINE_API extern int rl_clear_pending_input __P((void));
+READLINE_API extern int rl_read_key __P((void));
+READLINE_API extern int rl_getc __P((FILE *));
+READLINE_API extern int rl_set_keyboard_input_timeout __P((int));
 
 /* `Public' utility functions . */
-extern void rl_extend_line_buffer __P((int));
-extern int ding __P((void));
+READLINE_API extern void rl_extend_line_buffer __P((int));
+READLINE_API extern int rl_ding __P((void));
+READLINE_API extern int rl_alphabetic __P((int));
 
-/* Functions for character input. */
-extern int rl_stuff_char __P((int));
-extern int rl_execute_next __P((int));
-extern int rl_read_key __P((void));
-extern int rl_getc __P((FILE *));
-
 /* Readline signal handling, from signals.c */
-extern int rl_set_signals __P((void));
-extern int rl_clear_signals __P((void));
-extern void rl_cleanup_after_signal __P((void));
-extern void rl_reset_after_signal __P((void));
-extern void rl_free_line_state __P((void));
+READLINE_API extern int rl_set_signals __P((void));
+READLINE_API extern int rl_clear_signals __P((void));
+READLINE_API extern void rl_cleanup_after_signal __P((void));
+READLINE_API extern void rl_reset_after_signal __P((void));
+READLINE_API extern void rl_free_line_state __P((void));
  
 /* Undocumented. */
-extern int rl_expand_prompt __P((char *));
+READLINE_API extern int rl_set_paren_blink_timeout __P((int));
 
-extern int maybe_save_line __P((void));
-extern int maybe_unsave_line __P((void));
-extern int maybe_replace_line __P((void));
+/* Undocumented. */
+READLINE_API extern int rl_maybe_save_line __P((void));
+READLINE_API extern int rl_maybe_unsave_line __P((void));
+READLINE_API extern int rl_maybe_replace_line __P((void));
 
 /* Completion functions. */
-extern int rl_complete_internal __P((int));
-extern void rl_display_match_list __P((char **, int, int));
+READLINE_API extern int rl_complete_internal __P((int));
+READLINE_API extern void rl_display_match_list __P((char **, int, int));
 
-extern char **completion_matches __P((char *, CPFunction *));
-extern char *username_completion_function __P((char *, int));
-extern char *filename_completion_function __P((char *, int));
+READLINE_API extern char **rl_completion_matches __P((const char *, rl_compentry_func_t *));
+READLINE_API extern char *rl_username_completion_function __P((const char *, int));
+READLINE_API extern char *rl_filename_completion_function __P((const char *, int));
+
+#if 1
+/* Backwards compatibility (compat.c).  These will go away sometime. */
+READLINE_API extern void free_undo_list __P((void));
+READLINE_API extern int maybe_save_line __P((void));
+READLINE_API extern int maybe_unsave_line __P((void));
+READLINE_API extern int maybe_replace_line __P((void));
+
+READLINE_API extern int ding __P((void));
+READLINE_API extern int alphabetic __P((int));
+READLINE_API extern int crlf __P((void));
+
+READLINE_API extern char **completion_matches __P((const char *, rl_compentry_func_t *));
+READLINE_API extern char *username_completion_function __P((const char *, int));
+READLINE_API extern char *filename_completion_function __P((const char *, int));
+#endif
 
 /* **************************************************************** */
 /*								    */
@@ -404,100 +442,126 @@ extern char *filename_completion_functio
 /* **************************************************************** */
 
 /* The version of this incarnation of the readline library. */
-extern char *rl_library_version;
+READLINE_API extern const char *rl_library_version;
 
 /* True if this is real GNU readline. */
-extern int rl_gnu_readline_p;
+READLINE_API extern int rl_gnu_readline_p;
+
+/* Flags word encapsulating the current readline state. */
+READLINE_API extern int rl_readline_state;
 
+/* Says which editing mode readline is currently using.  1 means emacs mode;
+   0 means vi mode. */
+READLINE_API extern int rl_editing_mode;
+
 /* The name of the calling program.  You should initialize this to
    whatever was in argv[0].  It is used when parsing conditionals. */
-extern char *rl_readline_name;
+READLINE_API extern const char *rl_readline_name;
 
 /* The prompt readline uses.  This is set from the argument to
    readline (), and should not be assigned to directly. */
-extern char *rl_prompt;
+READLINE_API extern char *rl_prompt;
 
 /* The line buffer that is in use. */
-extern char *rl_line_buffer;
+READLINE_API extern char *rl_line_buffer;
 
 /* The location of point, and end. */
-extern int rl_point, rl_end;
+READLINE_API extern int rl_point;
+READLINE_API extern int rl_end;
 
 /* The mark, or saved cursor position. */
-extern int rl_mark;
+READLINE_API extern int rl_mark;
 
 /* Flag to indicate that readline has finished with the current input
    line and should return it. */
-extern int rl_done;
+READLINE_API extern int rl_done;
 
 /* If set to a character value, that will be the next keystroke read. */
-extern int rl_pending_input;
+READLINE_API extern int rl_pending_input;
 
 /* Non-zero if we called this function from _rl_dispatch().  It's present
    so functions can find out whether they were called from a key binding
    or directly from an application. */
-extern int rl_dispatching;
+READLINE_API extern int rl_dispatching;
+
+/* Non-zero if the user typed a numeric argument before executing the
+   current function. */
+READLINE_API extern int rl_explicit_arg;
+
+/* The current value of the numeric argument specified by the user. */
+READLINE_API extern int rl_numeric_arg;
 
+/* The address of the last command function Readline executed. */
+READLINE_API extern rl_command_func_t *rl_last_func;
+
 /* The name of the terminal to use. */
-extern char *rl_terminal_name;
+READLINE_API extern const char *rl_terminal_name;
 
 /* The input and output streams. */
-extern FILE *rl_instream, *rl_outstream;
+READLINE_API extern FILE *rl_instream;
+READLINE_API extern FILE *rl_outstream;
 
 /* If non-zero, then this is the address of a function to call just
    before readline_internal () prints the first prompt. */
-extern Function *rl_startup_hook;
+READLINE_API extern rl_hook_func_t *rl_startup_hook;
 
 /* If non-zero, this is the address of a function to call just before
    readline_internal_setup () returns and readline_internal starts
    reading input characters. */
-extern Function *rl_pre_input_hook;
+READLINE_API extern rl_hook_func_t *rl_pre_input_hook;
       
 /* The address of a function to call periodically while Readline is
    awaiting character input, or NULL, for no event handling. */
-extern Function *rl_event_hook;
+READLINE_API extern rl_hook_func_t *rl_event_hook;
+
+/* The address of the function to call to fetch a character from the current
+   Readline input stream */
+READLINE_API extern rl_getc_func_t *rl_getc_function;
 
-extern Function *rl_getc_function;
-extern VFunction *rl_redisplay_function;
-extern VFunction *rl_prep_term_function;
-extern VFunction *rl_deprep_term_function;
+READLINE_API extern rl_voidfunc_t *rl_redisplay_function;
 
+READLINE_API extern rl_vintfunc_t *rl_prep_term_function;
+READLINE_API extern rl_voidfunc_t *rl_deprep_term_function;
+
 /* Dispatch variables. */
-extern Keymap rl_executing_keymap;
-extern Keymap rl_binding_keymap;
+READLINE_API extern Keymap rl_executing_keymap;
+READLINE_API extern Keymap rl_binding_keymap;
 
 /* Display variables. */
 /* If non-zero, readline will erase the entire line, including any prompt,
    if the only thing typed on an otherwise-blank line is something bound to
    rl_newline. */
-extern int rl_erase_empty_line;
+READLINE_API extern int rl_erase_empty_line;
 
 /* If non-zero, the application has already printed the prompt (rl_prompt)
    before calling readline, so readline should not output it the first time
    redisplay is done. */
-extern int rl_already_prompted;
+READLINE_API extern int rl_already_prompted;
 
 /* A non-zero value means to read only this many characters rather than
    up to a character bound to accept-line. */
-extern int rl_num_chars_to_read;
+READLINE_API extern int rl_num_chars_to_read;
+
+/* The text of a currently-executing keyboard macro. */
+READLINE_API extern char *rl_executing_macro;
 
 /* Variables to control readline signal handling. */
 /* If non-zero, readline will install its own signal handlers for
    SIGINT, SIGTERM, SIGQUIT, SIGALRM, SIGTSTP, SIGTTIN, and SIGTTOU. */
-extern int rl_catch_signals;
+READLINE_API extern int rl_catch_signals;
 
 /* If non-zero, readline will install a signal handler for SIGWINCH
    that also attempts to call any calling application's SIGWINCH signal
    handler.  Note that the terminal is not cleaned up before the
    application's signal handler is called; use rl_cleanup_after_signal()
    to do that. */
-extern int rl_catch_sigwinch;
+READLINE_API extern int rl_catch_sigwinch;
 
 /* Completion variables. */
 /* Pointer to the generator function for completion_matches ().
    NULL means to use filename_entry_function (), the default filename
    completer. */
-extern Function *rl_completion_entry_function;
+READLINE_API extern rl_compentry_func_t *rl_completion_entry_function;
 
 /* If rl_ignore_some_completions_function is non-NULL it is the address
    of a function to call after all of the possible matches have been
@@ -505,7 +569,7 @@ extern Function *rl_completion_entry_fun
    The function is called with one argument; a NULL terminated array
    of (char *).  If your function removes any of the elements, they
    must be free()'ed. */
-extern Function *rl_ignore_some_completions_function;
+READLINE_API extern rl_compignore_func_t *rl_ignore_some_completions_function;
 
 /* Pointer to alternative function to create matches.
    Function is called with TEXT, START, and END.
@@ -514,39 +578,50 @@ extern Function *rl_ignore_some_completi
    If this function exists and returns NULL then call the value of
    rl_completion_entry_function to try to match, otherwise use the
    array of strings returned. */
-extern CPPFunction *rl_attempted_completion_function;
+READLINE_API extern rl_completion_func_t *rl_attempted_completion_function;
 
 /* The basic list of characters that signal a break between words for the
    completer routine.  The initial contents of this variable is what
    breaks words in the shell, i.e. "n\"\\'`@$>". */
-extern char *rl_basic_word_break_characters;
+READLINE_API extern const char *rl_basic_word_break_characters;
 
 /* The list of characters that signal a break between words for
    rl_complete_internal.  The default list is the contents of
    rl_basic_word_break_characters.  */
-extern char *rl_completer_word_break_characters;
+READLINE_API extern const char *rl_completer_word_break_characters;
 
 /* List of characters which can be used to quote a substring of the line.
    Completion occurs on the entire substring, and within the substring   
    rl_completer_word_break_characters are treated as any other character,
    unless they also appear within this list. */
-extern char *rl_completer_quote_characters;
+READLINE_API extern const char *rl_completer_quote_characters;
 
 /* List of quote characters which cause a word break. */
-extern char *rl_basic_quote_characters;
+READLINE_API extern const char *rl_basic_quote_characters;
 
 /* List of characters that need to be quoted in filenames by the completer. */
-extern char *rl_filename_quote_characters;
+READLINE_API extern const char *rl_filename_quote_characters;
 
 /* List of characters that are word break characters, but should be left
    in TEXT when it is passed to the completion function.  The shell uses
    this to help determine what kind of completing to do. */
-extern char *rl_special_prefixes;
+READLINE_API extern const char *rl_special_prefixes;
 
 /* If non-zero, then this is the address of a function to call when
    completing on a directory name.  The function is called with
-   the address of a string (the current directory name) as an arg. */
-extern Function *rl_directory_completion_hook;
+   the address of a string (the current directory name) as an arg.  It
+   changes what is displayed when the possible completions are printed
+   or inserted. */
+READLINE_API extern rl_icppfunc_t *rl_directory_completion_hook;
+
+/* If non-zero, this is the address of a function to call when completing
+   a directory name.  This function takes the address of the directory name
+   to be modified as an argument.  Unlike rl_directory_completion_hook, it
+   only modifies the directory name used in opendir(2), not what is displayed
+   when the possible completions are printed or inserted.  It is called
+   before rl_directory_completion_hook.  I'm not happy with how this works
+   yet, so it's undocumented. */
+READLINE_API extern rl_icppfunc_t *rl_directory_rewrite_hook;
 
 /* Backwards compatibility with previous versions of readline. */
 #define rl_symbolic_link_hook rl_directory_completion_hook
@@ -558,60 +633,60 @@ extern Function *rl_directory_completion
    where MATCHES is the array of strings that matched, NUM_MATCHES is the
    number of strings in that array, and MAX_LENGTH is the length of the
    longest string in that array. */
-extern VFunction *rl_completion_display_matches_hook;
+READLINE_API extern rl_compdisp_func_t *rl_completion_display_matches_hook;
 
 /* Non-zero means that the results of the matches are to be treated
    as filenames.  This is ALWAYS zero on entry, and can only be changed
    within a completion entry finder function. */
-extern int rl_filename_completion_desired;
+READLINE_API extern int rl_filename_completion_desired;
 
 /* Non-zero means that the results of the matches are to be quoted using
    double quotes (or an application-specific quoting mechanism) if the
    filename contains any characters in rl_word_break_chars.  This is
    ALWAYS non-zero on entry, and can only be changed within a completion
    entry finder function. */
-extern int rl_filename_quoting_desired;
+READLINE_API extern int rl_filename_quoting_desired;
 
 /* Set to a function to quote a filename in an application-specific fashion.
    Called with the text to quote, the type of match found (single or multiple)
    and a pointer to the quoting character to be used, which the function can
    reset if desired. */
-extern CPFunction *rl_filename_quoting_function;
+READLINE_API extern rl_quote_func_t *rl_filename_quoting_function;
 
 /* Function to call to remove quoting characters from a filename.  Called
    before completion is attempted, so the embedded quotes do not interfere
    with matching names in the file system. */
-extern CPFunction *rl_filename_dequoting_function;
+READLINE_API extern rl_dequote_func_t *rl_filename_dequoting_function;
 
 /* Function to call to decide whether or not a word break character is
    quoted.  If a character is quoted, it does not break words for the
    completer. */
-extern Function *rl_char_is_quoted_p;
+READLINE_API extern rl_linebuf_func_t *rl_char_is_quoted_p;
 
 /* Non-zero means to suppress normal filename completion after the
    user-specified completion function has been called. */
-extern int rl_attempted_completion_over;
+READLINE_API extern int rl_attempted_completion_over;
 
 /* Set to a character describing the type of completion being attempted by
    rl_complete_internal; available for use by application completion
    functions. */
-extern int rl_completion_type;
+READLINE_API extern int rl_completion_type;
 
 /* Character appended to completed words when at the end of the line.  The
    default is a space.  Nothing is added if this is '\0'. */
-extern int rl_completion_append_character;
+READLINE_API extern int rl_completion_append_character;
 
 /* Up to this many items will be displayed in response to a
    possible-completions call.  After that, we ask the user if she
    is sure she wants to see them all.  The default value is 100. */
-extern int rl_completion_query_items;
+READLINE_API extern int rl_completion_query_items;
 
 /* If non-zero, then disallow duplicates in the matches. */
-extern int rl_ignore_completion_duplicates;
+READLINE_API extern int rl_ignore_completion_duplicates;
 
 /* If this is non-zero, completion is (temporarily) inhibited, and the
    completion character will be inserted as any other. */
-extern int rl_inhibit_completion;
+READLINE_API extern int rl_inhibit_completion;
    
 /* Definitions available for use by readline clients. */
 #define RL_PROMPT_START_IGNORE	'\001'
@@ -623,11 +698,33 @@ extern int rl_inhibit_completion;
 #define SINGLE_MATCH    1
 #define MULT_MATCH      2
 
-#if 0
-#if !defined (savestring)
-extern char *savestring __P((char *));	/* XXX backwards compatibility */
-#endif
-#endif
+/* Possible state values for rl_readline_state */
+#define RL_STATE_NONE		0x00000		/* no state; before first call */
+
+#define RL_STATE_INITIALIZING	0x00001		/* initializing */
+#define RL_STATE_INITIALIZED	0x00002		/* initialization done */
+#define RL_STATE_TERMPREPPED	0x00004		/* terminal is prepped */
+#define RL_STATE_READCMD	0x00008		/* reading a command key */
+#define RL_STATE_METANEXT	0x00010		/* reading input after ESC */
+#define RL_STATE_DISPATCHING	0x00020		/* dispatching to a command */
+#define RL_STATE_MOREINPUT	0x00040		/* reading more input in a command function */
+#define RL_STATE_ISEARCH	0x00080		/* doing incremental search */
+#define RL_STATE_NSEARCH	0x00100		/* doing non-inc search */
+#define RL_STATE_SEARCH		0x00200		/* doing a history search */
+#define RL_STATE_NUMERICARG	0x00400		/* reading numeric argument */
+#define RL_STATE_MACROINPUT	0x00800		/* getting input from a macro */
+#define RL_STATE_MACRODEF	0x01000		/* defining keyboard macro */
+#define RL_STATE_OVERWRITE	0x02000		/* overwrite mode */
+#define RL_STATE_COMPLETING	0x04000		/* doing completion */
+#define RL_STATE_SIGHANDLER	0x08000		/* in readline sighandler */
+#define RL_STATE_UNDOING	0x10000		/* doing an undo */
+#define RL_STATE_INPUTPENDING	0x20000		/* rl_execute_next called */
+
+#define RL_STATE_DONE		0x80000		/* done; accepted line */
+
+#define RL_SETSTATE(x)		(rl_readline_state |= (x))
+#define RL_UNSETSTATE(x)	(rl_readline_state &= ~(x))
+#define RL_ISSTATE(x)		(rl_readline_state & (x))
 
 #ifdef __cplusplus
 }
Index: readline/rldefs.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rldefs.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rldefs.h
--- readline/rldefs.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/rldefs.h	2003/02/17 12:47:10
@@ -30,6 +30,8 @@
 #  include "config.h"
 #endif
 
+#include "rlstdc.h"
+
 #if defined (_POSIX_VERSION) && !defined (TERMIOS_MISSING)
 #  define TERMIOS_TTY_DRIVER
 #else
@@ -70,8 +72,12 @@ extern char *strchr (), *strrchr ();
 #if defined (HAVE_STRCASECMP)
 #define _rl_stricmp strcasecmp
 #define _rl_strnicmp strncasecmp
+#elif defined (__MINGW32__)
+#define _rl_stricmp stricmp
+#define _rl_strnicmp strnicmp
 #else
-extern int _rl_stricmp (), _rl_strnicmp ();
+extern int _rl_stricmp __P((char *, char *);
+extern int _rl_strnicmp __P((char *, char *));
 #endif
 
 #if !defined (emacs_mode)
@@ -87,14 +93,14 @@ extern int _rl_stricmp (), _rl_strnicmp 
    This is not what is wanted. */
 #if defined (CRAY)
 #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)((int)map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(Function *)((int)(data))
+#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)((int)(data))
 #else
 #  define FUNCTION_TO_KEYMAP(map, key)	(Keymap)(map[key].function)
-#  define KEYMAP_TO_FUNCTION(data)	(Function *)(data)
+#  define KEYMAP_TO_FUNCTION(data)	(rl_command_func_t *)(data)
 #endif
 
 #ifndef savestring
-extern char *xmalloc ();
+extern char *xmalloc __P((int));
 #define savestring(x) strcpy (xmalloc (1 + strlen (x)), (x))
 #endif
 
@@ -130,6 +136,27 @@ extern char *xmalloc ();
 #  define FREE(x)	if (x) free (x)
 #endif
 
+#if defined (__MINGW32__)
+#define WAIT_FOR_INPUT 200	/* milliseconds to suspend maximally 
+ 				   when waiting for input */
+#define FOR_INPUT	1	/* flags for open state of the console  */
+#define FOR_OUTPUT	2
+#define INITIALIZED	4
+
+/* undefine this when readline / history should not look into the registry
+   for the path to their init files  */
+#define INITFILES_IN_REGISTRY 1
+ 
+#if defined (INITFILES_IN_REGISTRY)
+/* We also try to get the .inputrc and .history file paths from the registry,
+   define what to look for */
+#define READLINE_REGKEY	"Software\\Free Software Foundation\\libreadline"
+#define INPUTRC_REGVAL	"inputrc-file"
+#define HISTFILE_REGVAL	"history-file"
+#endif
+ 
+#endif	/* __MINGW32__  */
+ 
 /* CONFIGURATION SECTION */
 #include "rlconf.h"
 
Index: readline/rlprivate.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rlprivate.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rlprivate.h
--- readline/rlprivate.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/rlprivate.h	2003/02/17 12:47:10
@@ -24,6 +24,14 @@
 #if !defined (_RL_PRIVATE_H_)
 #define _RL_PRIVATE_H_
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 #include "rlconf.h"	/* for VISIBLE_STATS */
 #include "rlstdc.h"
 #include "posixjmp.h" /* defines procenv_t */
@@ -35,7 +43,7 @@
  *************************************************************************/
 
 /* terminal.c */
-extern char *rl_get_termcap __P((char *));
+READLINE_API extern char *rl_get_termcap __P((const char *));
 
 /*************************************************************************
  *									 *
@@ -44,27 +52,23 @@ extern char *rl_get_termcap __P((char *)
  *************************************************************************/
 
 /* complete.c */
-extern int rl_complete_with_tilde_expansion;
+READLINE_API extern int rl_complete_with_tilde_expansion;
 #if defined (VISIBLE_STATS)
-extern int rl_visible_stats;
+READLINE_API extern int rl_visible_stats;
 #endif /* VISIBLE_STATS */
 
 /* readline.c */
-extern int rl_line_buffer_len;
-extern int rl_numeric_arg;
-extern int rl_arg_sign;
-extern int rl_explicit_arg;
-extern int rl_editing_mode;
-extern int rl_visible_prompt_length;
-extern Function *rl_last_func;
-extern int readline_echoing_p;
-extern int rl_key_sequence_length;
+READLINE_API extern int rl_line_buffer_len;
+READLINE_API extern int rl_arg_sign;
+READLINE_API extern int rl_visible_prompt_length;
+READLINE_API extern int readline_echoing_p;
+READLINE_API extern int rl_key_sequence_length;
 
 /* display.c */
-extern int rl_display_fixed;
+READLINE_API extern int rl_display_fixed;
 
 /* parens.c */
-extern int rl_blink_matching_paren;
+READLINE_API extern int rl_blink_matching_paren;
 
 /*************************************************************************
  *									 *
@@ -73,25 +77,25 @@ extern int rl_blink_matching_paren;
  *************************************************************************/
 
 /* bind.c */
-extern char *rl_untranslate_keyseq __P((int));
+READLINE_API extern char *rl_untranslate_keyseq __P((int));
 
 /* kill.c */
-extern int rl_set_retained_kills __P((int));
+READLINE_API extern int rl_set_retained_kills __P((int));
 
 /* readline.c */
-extern int rl_discard_argument __P((void));
+READLINE_API extern int rl_discard_argument __P((void));
 
 /* rltty.c */
-extern int rl_stop_output __P((int, int));
+READLINE_API extern int rl_stop_output __P((int, int));
 
 /* terminal.c */
-extern void _rl_set_screen_size __P((int, int));
+READLINE_API extern void _rl_set_screen_size __P((int, int));
 
 /* undo.c */
-extern int _rl_fix_last_undo_of_type __P((int, int, int));
+READLINE_API extern int _rl_fix_last_undo_of_type __P((int, int, int));
 
 /* util.c */
-extern char *_rl_savestring __P((char *));
+READLINE_API extern char *_rl_savestring __P((const char *));
 
 /*************************************************************************
  *									 *
@@ -111,161 +115,163 @@ extern char *_rl_savestring __P((char *)
 #if defined(READLINE_CALLBACKS)
 
 /* readline.c */
-extern void readline_internal_setup __P((void));
-extern char *readline_internal_teardown __P((int));
-extern int readline_internal_char __P((void));
+READLINE_API extern void readline_internal_setup __P((void));
+READLINE_API extern char *readline_internal_teardown __P((int));
+READLINE_API extern int readline_internal_char __P((void));
 
 #endif /* READLINE_CALLBACKS */
 
 /* bind.c */
-extern void _rl_bind_if_unbound __P((char *, Function *));
+READLINE_API extern void _rl_bind_if_unbound __P((const char *, rl_command_func_t *));
 
 /* display.c */
-extern char *_rl_strip_prompt __P((char *));
-extern void _rl_move_cursor_relative __P((int, char *));
-extern void _rl_move_vert __P((int));
-extern void _rl_save_prompt __P((void));
-extern void _rl_restore_prompt __P((void));
-extern char *_rl_make_prompt_for_search __P((int));
-extern void _rl_erase_at_end_of_line __P((int));
-extern void _rl_clear_to_eol __P((int));
-extern void _rl_clear_screen __P((void));
-extern void _rl_update_final __P((void));
-extern void _rl_redisplay_after_sigwinch __P((void));
-extern void _rl_clean_up_for_exit __P((void));
-extern void _rl_erase_entire_line __P((void));
-extern int _rl_currentb_display_line __P((void));
+READLINE_API extern char *_rl_strip_prompt __P((char *));
+READLINE_API extern void _rl_move_cursor_relative __P((int, const char *));
+READLINE_API extern void _rl_move_vert __P((int));
+READLINE_API extern void _rl_save_prompt __P((void));
+READLINE_API extern void _rl_restore_prompt __P((void));
+READLINE_API extern char *_rl_make_prompt_for_search __P((int));
+READLINE_API extern void _rl_erase_at_end_of_line __P((int));
+READLINE_API extern void _rl_clear_to_eol __P((int));
+READLINE_API extern void _rl_clear_screen __P((void));
+READLINE_API extern void _rl_update_final __P((void));
+READLINE_API extern void _rl_redisplay_after_sigwinch __P((void));
+READLINE_API extern void _rl_clean_up_for_exit __P((void));
+READLINE_API extern void _rl_erase_entire_line __P((void));
+READLINE_API extern int _rl_current_display_line __P((void));
 
 /* input.c */
-extern int _rl_any_typein __P((void));
-extern int _rl_input_available __P((void));
-extern void _rl_insert_typein __P((int));
+READLINE_API extern int _rl_any_typein __P((void));
+READLINE_API extern int _rl_input_available __P((void));
+READLINE_API extern void _rl_insert_typein __P((int));
 
 /* macro.c */
-extern void _rl_with_macro_input __P((char *));
-extern int _rl_next_macro_key __P((void));
-extern void _rl_push_executing_macro __P((void));
-extern void _rl_pop_executing_macro __P((void));
-extern void _rl_add_macro_char __P((int));
-extern void _rl_kill_kbd_macro __P((void));
+READLINE_API extern void _rl_with_macro_input __P((char *));
+READLINE_API extern int _rl_next_macro_key __P((void));
+READLINE_API extern void _rl_push_executing_macro __P((void));
+READLINE_API extern void _rl_pop_executing_macro __P((void));
+READLINE_API extern void _rl_add_macro_char __P((int));
+READLINE_API extern void _rl_kill_kbd_macro __P((void));
 
 /* nls.c */
-extern int _rl_init_eightbit __P((void));
+READLINE_API extern int _rl_init_eightbit __P((void));
 
 /* parens.c */
-extern void _rl_enable_paren_matching __P((int));
+READLINE_API extern void _rl_enable_paren_matching __P((int));
 
 /* readline.c */
-extern void _rl_init_line_state __P((void));
-extern void _rl_set_the_line __P((void));
-extern int _rl_dispatch __P((int, Keymap));
-extern int _rl_init_argument __P((void));
-extern void _rl_fix_point __P((int));
-extern void _rl_replace_text __P((char *, int, int));
-extern int _rl_char_search_internal __P((int, int, int));
-extern int _rl_set_mark_at_pos __P((int));
+READLINE_API extern void _rl_init_line_state __P((void));
+READLINE_API extern void _rl_set_the_line __P((void));
+READLINE_API extern int _rl_dispatch __P((int, Keymap));
+READLINE_API extern int _rl_init_argument __P((void));
+READLINE_API extern void _rl_fix_point __P((int));
+READLINE_API extern void _rl_replace_text __P((const char *, int, int));
+READLINE_API extern int _rl_char_search_internal __P((int, int, int));
+READLINE_API extern int _rl_set_mark_at_pos __P((int));
+READLINE_API extern int _rl_free_saved_history_line __P((void));
 
 /* rltty.c */
-extern int _rl_disable_tty_signals __P((void));
-extern int _rl_restore_tty_signals __P((void));
+READLINE_API extern int _rl_disable_tty_signals __P((void));
+READLINE_API extern int _rl_restore_tty_signals __P((void));
 
 /* terminal.c */
-extern void _rl_get_screen_size __P((int, int));
-extern int _rl_init_terminal_io __P((char *));
+READLINE_API extern void _rl_get_screen_size __P((int, int));
+READLINE_API extern int _rl_init_terminal_io __P((const char *));
 #ifdef _MINIX
-extern void _rl_output_character_function __P((int));
+READLINE_API extern void _rl_output_character_function __P((int));
 #else
-extern int _rl_output_character_function __P((int));
+READLINE_API extern int _rl_output_character_function __P((int));
 #endif
-extern void _rl_output_some_chars __P((char *, int));
-extern int _rl_backspace __P((int));
-extern void _rl_enable_meta_key __P((void));
-extern void _rl_control_keypad __P((int));
+READLINE_API extern void _rl_output_some_chars __P((const char *, int));
+READLINE_API extern int _rl_backspace __P((int));
+READLINE_API extern void _rl_enable_meta_key __P((void));
+READLINE_API extern void _rl_control_keypad __P((int));
 
 /* util.c */
-extern int alphabetic __P((int));
-extern int _rl_abort_internal __P((void));
-extern char *_rl_strindex __P((char *, char *));
-extern int _rl_qsort_string_compare __P((char **, char **));
-extern int (_rl_uppercase_p) __P((int));
-extern int (_rl_lowercase_p) __P((int));
-extern int (_rl_pure_alphabetic) __P((int));
-extern int (_rl_digit_p) __P((int));
-extern int (_rl_to_lower) __P((int));
-extern int (_rl_to_upper) __P((int));
-extern int (_rl_digit_value) __P((int));
+READLINE_API extern int rl_alphabetic __P((int));
+READLINE_API extern int _rl_abort_internal __P((void));
+READLINE_API extern char *_rl_strindex __P((const char *, const char *));
+READLINE_API extern char *_rl_strpbrk __P((const char *, const char *));
+READLINE_API extern int _rl_qsort_string_compare __P((char **, char **));
+READLINE_API extern int (_rl_uppercase_p) __P((int));
+READLINE_API extern int (_rl_lowercase_p) __P((int));
+READLINE_API extern int (_rl_pure_alphabetic) __P((int));
+READLINE_API extern int (_rl_digit_p) __P((int));
+READLINE_API extern int (_rl_to_lower) __P((int));
+READLINE_API extern int (_rl_to_upper) __P((int));
+READLINE_API extern int (_rl_digit_value) __P((int));
 
 /* vi_mode.c */
-extern void _rl_vi_initialize_line __P((void));
-extern void _rl_vi_reset_last __P((void));
-extern void _rl_vi_set_last __P((int, int, int));
-extern int _rl_vi_textmod_command __P((int));
-extern void _rl_vi_done_inserting __P((void));
+READLINE_API extern void _rl_vi_initialize_line __P((void));
+READLINE_API extern void _rl_vi_reset_last __P((void));
+READLINE_API extern void _rl_vi_set_last __P((int, int, int));
+READLINE_API extern int _rl_vi_textmod_command __P((int));
+READLINE_API extern void _rl_vi_done_inserting __P((void));
 
 /*************************************************************************
  * Undocumented private variables					 *
  *************************************************************************/
 
+/* bind.c */
+READLINE_API extern const char *_rl_possible_control_prefixes[];
+READLINE_API extern const char *_rl_possible_meta_prefixes[];
+
 /* complete.c */
-extern int _rl_complete_show_all;
-extern int _rl_complete_mark_directories;
-extern int _rl_print_completions_horizontally;
-extern int _rl_completion_case_fold;
+READLINE_API extern int _rl_complete_show_all;
+READLINE_API extern int _rl_complete_mark_directories;
+READLINE_API extern int _rl_print_completions_horizontally;
+READLINE_API extern int _rl_completion_case_fold;
 
 /* display.c */
-extern int _rl_vis_botlin;
-extern int _rl_last_c_pos;
-extern int _rl_suppress_redisplay;
-extern char *rl_display_prompt;
-
-/* funmap.c */
-extern char *possible_control_prefixes[];
-extern char *possible_meta_prefixes[];
+READLINE_API extern int _rl_vis_botlin;
+READLINE_API extern int _rl_last_c_pos;
+READLINE_API extern int _rl_suppress_redisplay;
+READLINE_API extern char *rl_display_prompt;
 
 /* isearch.c */
-extern unsigned char *_rl_isearch_terminators;
+READLINE_API extern unsigned char *_rl_isearch_terminators;
 
 /* macro.c */
-extern int _rl_defining_kbd_macro;
-extern char *_rl_executing_macro;
+READLINE_API extern int _rl_defining_kbd_macro;
+READLINE_API extern char *_rl_executing_macro;
 
 /* readline.c */
-extern int _rl_horizontal_scroll_mode;
-extern int _rl_mark_modified_lines;
-extern int _rl_bell_preference;
-extern int _rl_meta_flag;
-extern int _rl_convert_meta_chars_to_ascii;
-extern int _rl_output_meta_chars;
-extern char *_rl_comment_begin;
-extern unsigned char _rl_parsing_conditionalized_out;
-extern Keymap _rl_keymap;
-extern FILE *_rl_in_stream;
-extern FILE *_rl_out_stream;
-extern int _rl_last_command_was_kill;
-extern int _rl_eof_char;
-extern procenv_t readline_top_level;
+READLINE_API extern int _rl_horizontal_scroll_mode;
+READLINE_API extern int _rl_mark_modified_lines;
+READLINE_API extern int _rl_bell_preference;
+READLINE_API extern int _rl_meta_flag;
+READLINE_API extern int _rl_convert_meta_chars_to_ascii;
+READLINE_API extern int _rl_output_meta_chars;
+READLINE_API extern char *_rl_comment_begin;
+READLINE_API extern unsigned char _rl_parsing_conditionalized_out;
+READLINE_API extern Keymap _rl_keymap;
+READLINE_API extern FILE *_rl_in_stream;
+READLINE_API extern FILE *_rl_out_stream;
+READLINE_API extern int _rl_last_command_was_kill;
+READLINE_API extern int _rl_eof_char;
+READLINE_API extern procenv_t readline_top_level;
 
 /* terminal.c */
-extern int _rl_enable_keypad;
-extern int _rl_enable_meta;
-extern char *term_clreol;
-extern char *term_clrpag;
-extern char *term_im;
-extern char *term_ic;
-extern char *term_ei;
-extern char *term_DC;
-extern char *term_up;
-extern char *term_dc;
-extern char *term_cr;
-extern char *term_IC;
-extern int screenheight;
-extern int screenwidth;
-extern int screenchars;
-extern int terminal_can_insert;
-extern int _rl_term_autowrap;
+READLINE_API extern int _rl_enable_keypad;
+READLINE_API extern int _rl_enable_meta;
+READLINE_API extern char *_rl_term_clreol;
+READLINE_API extern char *_rl_term_clrpag;
+READLINE_API extern char *_rl_term_im;
+READLINE_API extern char *_rl_term_ic;
+READLINE_API extern char *_rl_term_ei;
+READLINE_API extern char *_rl_term_DC;
+READLINE_API extern char *_rl_term_up;
+READLINE_API extern char *_rl_term_dc;
+READLINE_API extern char *_rl_term_cr;
+READLINE_API extern char *_rl_term_IC;
+READLINE_API extern int _rl_screenheight;
+READLINE_API extern int _rl_screenwidth;
+READLINE_API extern int _rl_screenchars;
+READLINE_API extern int _rl_terminal_can_insert;
+READLINE_API extern int _rl_term_autowrap;
 
 /* undo.c */
-extern int _rl_doing_an_undo;
-extern int _rl_undo_group_level;
+READLINE_API extern int _rl_doing_an_undo;
+READLINE_API extern int _rl_undo_group_level;
 
 #endif /* _RL_PRIVATE_H_ */
Index: readline/rlshell.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rlshell.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rlshell.h
--- readline/rlshell.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/rlshell.h	2000/11/08 15:51:03
@@ -25,10 +25,10 @@
 
 #include "rlstdc.h"
 
-extern char *single_quote __P((char *));
-extern void set_lines_and_columns __P((int, int));
-extern char *get_env_value __P((char *));
-extern char *get_home_dir __P((void));
-extern int unset_nodelay_mode __P((int));
+extern char *sh_single_quote __P((char *));
+extern void sh_set_lines_and_columns __P((int, int));
+extern char *sh_get_env_value __P((const char *));
+extern char *sh_get_home_dir __P((void));
+extern int sh_unset_nodelay_mode __P((int));
 
 #endif /* _RL_SHELL_H_ */
Index: readline/rlstdc.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rlstdc.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rlstdc.h
--- readline/rlstdc.h	2003/02/16 21:36:31	1.1.1.1
+++ readline/rlstdc.h	2000/09/13 18:10:14
@@ -36,4 +36,16 @@
 #  endif
 #endif
 
+#if !defined (__STDC__) && !defined (__cplusplus)
+#  if defined (__GNUC__)	/* gcc with -traditional */
+#    if !defined (const)
+#      define const __const
+#    endif /* !const */
+#  else /* !__GNUC__ */
+#    if !defined (const)
+#      define const
+#    endif /* !const */
+#  endif /* !__GNUC__ */
+#endif /* !__STDC__ && !__cplusplus */
+
 #endif /* !_RL_STDC_H_ */
Index: readline/rltty.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rltty.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rltty.c
--- readline/rltty.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/rltty.c	2003/02/17 12:47:10
@@ -26,6 +26,8 @@
 #  include <config.h>
 #endif
 
+#if !defined (__MINGW32__)	/* for native Win32 environments this is hard stuff  */
+
 #include <sys/types.h>
 #include <signal.h>
 #include <errno.h>
@@ -42,6 +44,10 @@
 #endif /* GWINSZ_IN_SYS_IOCTL */
 
 #include "rltty.h"
+#else	/* __MINGW32__ */
+#include "rldefs.h"
+#include <stdio.h>
+#endif	/* __MINGW32__ */
 #include "readline.h"
 #include "rlprivate.h"
 
@@ -49,9 +55,10 @@
 extern int errno;
 #endif /* !errno */
 
-VFunction *rl_prep_term_function = rl_prep_terminal;
-VFunction *rl_deprep_term_function = rl_deprep_terminal;
+rl_vintfunc_t *rl_prep_term_function = rl_prep_terminal;
+rl_voidfunc_t *rl_deprep_term_function = rl_deprep_terminal;
 
+#ifndef __MINGW32__
 /* **************************************************************** */
 /*								    */
 /*			   Signal Management			    */
@@ -214,28 +221,27 @@ get_tty_settings (tty, tiop)
      int tty;
      TIOTYPE *tiop;
 {
-#if defined (TIOCGWINSZ)
   set_winsize (tty);
-#endif
 
   tiop->flags = tiop->lflag = 0;
 
-  ioctl (tty, TIOCGETP, &(tiop->sgttyb));
+  if (ioctl (tty, TIOCGETP, &(tiop->sgttyb)) < 0)
+    return -1;
   tiop->flags |= SGTTY_SET;
 
 #if defined (TIOCLGET)
-  ioctl (tty, TIOCLGET, &(tiop->lflag));
-  tiop->flags |= LFLAG_SET;
+  if (ioctl (tty, TIOCLGET, &(tiop->lflag)) == 0)
+    tiop->flags |= LFLAG_SET;
 #endif
 
 #if defined (TIOCGETC)
-  ioctl (tty, TIOCGETC, &(tiop->tchars));
-  tiop->flags |= TCHARS_SET;
+  if (ioctl (tty, TIOCGETC, &(tiop->tchars)) == 0)
+    tiop->flags |= TCHARS_SET;
 #endif
 
 #if defined (TIOCGLTC)
-  ioctl (tty, TIOCGLTC, &(tiop->ltchars));
-  tiop->flags |= LTCHARS_SET;
+  if (ioctl (tty, TIOCGLTC, &(tiop->ltchars)) == 0)
+    tiop->flags |= LTCHARS_SET;
 #endif
 
   return 0;
@@ -281,23 +287,23 @@ set_tty_settings (tty, tiop)
 }
 
 static void
-prepare_terminal_settings (meta_flag, otio, tiop)
+prepare_terminal_settings (meta_flag, oldtio, tiop)
      int meta_flag;
-     TIOTYPE otio, *tiop;
+     TIOTYPE oldtio, *tiop;
 {
-  readline_echoing_p = (otio.sgttyb.sg_flags & ECHO);
+  readline_echoing_p = (oldtio.sgttyb.sg_flags & ECHO);
 
   /* Copy the original settings to the structure we're going to use for
      our settings. */
-  tiop->sgttyb = otio.sgttyb;
-  tiop->lflag = otio.lflag;
+  tiop->sgttyb = oldtio.sgttyb;
+  tiop->lflag = oldtio.lflag;
 #if defined (TIOCGETC)
-  tiop->tchars = otio.tchars;
+  tiop->tchars = oldtio.tchars;
 #endif
 #if defined (TIOCGLTC)
-  tiop->ltchars = otio.ltchars;
+  tiop->ltchars = oldtio.ltchars;
 #endif
-  tiop->flags = otio.flags;
+  tiop->flags = oldtio.flags;
 
   /* First, the basic settings to put us into character-at-a-time, no-echo
      input mode. */
@@ -310,8 +316,8 @@ prepare_terminal_settings (meta_flag, ot
 #if !defined (ANYP)
 #  define ANYP (EVENP | ODDP)
 #endif
-  if (((otio.sgttyb.sg_flags & ANYP) == ANYP) ||
-      ((otio.sgttyb.sg_flags & ANYP) == 0))
+  if (((oldtio.sgttyb.sg_flags & ANYP) == ANYP) ||
+      ((oldtio.sgttyb.sg_flags & ANYP) == 0))
     {
       tiop->sgttyb.sg_flags |= ANYP;
 
@@ -330,13 +336,13 @@ prepare_terminal_settings (meta_flag, ot
   tiop->tchars.t_startc = -1; /* C-q */
 
   /* If there is an XON character, bind it to restart the output. */
-  if (otio.tchars.t_startc != -1)
-    rl_bind_key (otio.tchars.t_startc, rl_restart_output);
+  if (oldtio.tchars.t_startc != -1)
+    rl_bind_key (oldtio.tchars.t_startc, rl_restart_output);
 #  endif /* USE_XON_XOFF */
 
   /* If there is an EOF char, bind _rl_eof_char to it. */
-  if (otio.tchars.t_eofc != -1)
-    _rl_eof_char = otio.tchars.t_eofc;
+  if (oldtio.tchars.t_eofc != -1)
+    _rl_eof_char = oldtio.tchars.t_eofc;
 
 #  if defined (NO_KILL_INTR)
   /* Get rid of terminal-generated SIGQUIT and SIGINT. */
@@ -375,7 +381,7 @@ prepare_terminal_settings (meta_flag, ot
 #  define TIOTYPE struct termio
 #  define DRAIN_OUTPUT(fd)
 #  define GETATTR(tty, tiop)	(ioctl (tty, TCGETA, tiop))
-#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETA, tiop))
+#  define SETATTR(tty, tiop)	(ioctl (tty, TCSETAW, tiop))
 #endif /* !TERMIOS_TTY_DRIVER */
 
 static TIOTYPE otio;
@@ -491,9 +497,7 @@ get_tty_settings (tty, tiop)
      int tty;
      TIOTYPE *tiop;
 {
-#if defined (TIOCGWINSZ)
   set_winsize (tty);
-#endif
 
   if (_get_tty_settings (tty, tiop) < 0)
     return -1;
@@ -549,16 +553,16 @@ set_tty_settings (tty, tiop)
 }
 
 static void
-prepare_terminal_settings (meta_flag, otio, tiop)
+prepare_terminal_settings (meta_flag, oldtio, tiop)
      int meta_flag;
-     TIOTYPE otio, *tiop;
+     TIOTYPE oldtio, *tiop;
 {
-  readline_echoing_p = (otio.c_lflag & ECHO);
+  readline_echoing_p = (oldtio.c_lflag & ECHO);
 
   tiop->c_lflag &= ~(ICANON | ECHO);
 
-  if ((unsigned char) otio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
-    _rl_eof_char = otio.c_cc[VEOF];
+  if ((unsigned char) oldtio.c_cc[VEOF] != (unsigned char) _POSIX_VDISABLE)
+    _rl_eof_char = oldtio.c_cc[VEOF];
 
 #if defined (USE_XON_XOFF)
 #if defined (IXANY)
@@ -589,7 +593,7 @@ prepare_terminal_settings (meta_flag, ot
   if (OUTPUT_BEING_FLUSHED (tiop))
     {
       tiop->c_lflag &= ~FLUSHO;
-      otio.c_lflag &= ~FLUSHO;
+      oldtio.c_lflag &= ~FLUSHO;
     }
 #endif
 
@@ -649,6 +653,7 @@ rl_prep_terminal (meta_flag)
 
   fflush (rl_outstream);
   terminal_prepped = 1;
+  RL_SETSTATE(RL_STATE_TERMPREPPED);
 
   release_sigint ();
 }
@@ -679,6 +684,7 @@ rl_deprep_terminal ()
     }
 
   terminal_prepped = 0;
+  RL_UNSETSTATE(RL_STATE_TERMPREPPED);
 
   release_sigint ();
 }
@@ -755,6 +761,9 @@ rl_stop_output (count, key)
 /*			Default Key Bindings			    */
 /*								    */
 /* **************************************************************** */
+
+/* Set the system's default editing characters to their readline equivalents
+   in KMAP.  Should be static, now that we have rl_tty_set_default_bindings. */
 void
 rltty_set_default_bindings (kmap)
      Keymap kmap;
@@ -817,6 +826,124 @@ rltty_set_default_bindings (kmap)
 #  endif /* VWERASE && TERMIOS_TTY_DRIVER */
     }
 #endif /* !NEW_TTY_DRIVER */
+}
+
+#else /* __MING32__ */
+
+/* **************************************************************** */
+/*								    */
+/*		Default Key Bindings for Win32 Console              */
+/*								    */
+/* **************************************************************** */
+
+#include <windows.h>
+
+#define CONSOLE_MODE	ENABLE_PROCESSED_INPUT | ENABLE_MOUSE_INPUT
+
+/* global vars used by other modules */
+
+int	haveConsole	= 0;	/* remember init result of the console  */
+HANDLE	hStdout, hStdin;	/* these are different from stdin, stdout  */
+
+COORD	rlScreenOrigin;		/* readline origin in frame buffer coordinates */
+int	rlScreenStart = 0;	/* readline origin as frame screen buffer offset */
+COORD	rlScreenEnd;		/* end of line in frame buffer coordinates */
+int	rlScreenMax = 0;	/* end of line as linear frame buffer offset */
+
+static DWORD savedConsoleMode = 0;	/* to restore console on exit */
+
+void
+rltty_set_default_bindings (kmap)
+     Keymap kmap;
+{
+  /* I bet this is required on Win32 ;-) */
+  {
+    char buf[40]; strcpy(buf,"set bell-style none");
+    rl_parse_and_bind(buf);
+  }
+  rl_set_key ("\\M-\\&", rl_get_previous_history, kmap);
+  rl_set_key ("\\M-\\(", rl_get_next_history, kmap);
+  rl_set_key ("\\M-\\'", rl_forward, kmap);
+  rl_set_key ("\\M-\\%", rl_backward, kmap);
+  
+  rl_set_key ("\\M-\\$", rl_beg_of_line, kmap);
+  rl_set_key ("\\M-\\#", rl_end_of_line, kmap);
+  rl_set_key ("\\M-\\%", rl_backward_word, kmap);
+  rl_set_key ("\\M-\\'", rl_forward_word, kmap);
+  
+  rl_set_key ("\\M-\\-", rl_paste_from_clipboard, kmap);
+  rl_set_key ("\\M-\\.", rl_delete, kmap);
+  rl_set_key ("", rl_unix_word_rubout, kmap);
+}
+
+/* Query and set up a Window Console */
+
+void
+rl_prep_terminal (meta_flag)
+     int meta_flag;
+{
+  readline_echoing_p = 1;
+  
+  if ( !(haveConsole & INITIALIZED) )
+    {
+      if ( !(haveConsole & FOR_INPUT)
+	   && ((hStdin = GetStdHandle(STD_INPUT_HANDLE)) != INVALID_HANDLE_VALUE) )
+        {
+          DWORD dummy;
+          INPUT_RECORD irec;
+          if ( PeekConsoleInput(hStdin, &irec, 1, &dummy) )
+            {
+              haveConsole |= FOR_INPUT;
+              if ( GetConsoleMode(hStdin, &savedConsoleMode) )
+                SetConsoleMode(hStdin, CONSOLE_MODE);
+            }
+        }
+      if ( (hStdout = GetStdHandle(STD_OUTPUT_HANDLE)) != INVALID_HANDLE_VALUE)
+        {
+          CONSOLE_SCREEN_BUFFER_INFO csbi;
+          if ( GetConsoleScreenBufferInfo(hStdout, &csbi) 
+               && (csbi.dwSize.X > 0) && (csbi.dwSize.Y > 0) )
+            {
+              haveConsole |= FOR_OUTPUT;
+              rlScreenOrigin = csbi.dwCursorPosition;
+              rlScreenStart = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+		+ (int)csbi.dwCursorPosition.X;
+            }
+        }
+      haveConsole |= INITIALIZED;
+    }
+}
+
+/* Restore the consoles's normal settings and modes. */
+void
+rl_deprep_terminal ()
+{
+  SetConsoleMode(hStdin, savedConsoleMode);
+  haveConsole = 0;
+}
+
+int
+rl_restart_output (count, key)
+     int count, key;
+{
+  return 0;
+}
+
+int
+rl_stop_output (count, key)
+     int count, key;
+{
+  return 0;
+}
+#endif /* __MINGW32__ */
+
+/* New public way to set the system default editing chars to their readline
+   equivalents. */
+void
+rl_tty_set_default_bindings (kmap)
+     Keymap kmap;
+{
+  rltty_set_default_bindings (kmap);
 }
 
 #if defined (HANDLE_SIGNALS)
Index: readline/rltty.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/rltty.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rltty.h
--- readline/rltty.h	2003/02/16 21:36:32	1.1.1.1
+++ readline/rltty.h	2003/02/17 12:47:10
@@ -38,7 +38,7 @@
 #endif /* TERMIO_TTY_DRIVER */
 
 /* Other (BSD) machines use sgtty. */
-#if defined (NEW_TTY_DRIVER)
+#if defined (NEW_TTY_DRIVER) && !defined (__MINGW32__)
 #  include <sgtty.h>
 #endif
 
Index: readline/savestring.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/savestring.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 savestring.c
--- readline/savestring.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/savestring.c	2000/09/14 18:58:41
@@ -27,7 +27,7 @@ extern char *xmalloc ();
    all `public' readline header files. */
 char *
 savestring (s)
-     char *s;
+     const char *s;
 {
   return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
 }
Index: readline/search.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/search.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 search.c
--- readline/search.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/search.c	2000/11/02 18:13:25
@@ -51,7 +51,7 @@
 #endif
 #define abs(x)		(((x) >= 0) ? (x) : -(x))
 
-extern HIST_ENTRY *saved_line_for_history;
+extern HIST_ENTRY *_rl_saved_line_for_history;
 
 /* Functions imported from the rest of the library. */
 extern int _rl_free_history_entry __P((HIST_ENTRY *));
@@ -83,9 +83,9 @@ make_history_line_current (entry)
   rl_undo_list = (UNDO_LIST *)entry->data;
   rl_end = line_len;
 
-  if (saved_line_for_history)
-    _rl_free_history_entry (saved_line_for_history);
-  saved_line_for_history = (HIST_ENTRY *)NULL;
+  if (_rl_saved_line_for_history)
+    _rl_free_history_entry (_rl_saved_line_for_history);
+  _rl_saved_line_for_history = (HIST_ENTRY *)NULL;
 }
 
 /* Search the history list for STRING starting at absolute history position
@@ -100,13 +100,19 @@ noninc_search_from_pos (string, pos, dir
 {
   int ret, old;
 
+  if (pos < 0)
+    return -1;
+
   old = where_history ();
-  history_set_pos (pos);
+  if (history_set_pos (pos) == 0)
+    return -1;
 
+  RL_SETSTATE(RL_STATE_SEARCH);
   if (*string == '^')
     ret = history_search_prefix (string + 1, dir);
   else
     ret = history_search (string, dir);
+  RL_UNSETSTATE(RL_STATE_SEARCH);
 
   if (ret != -1)
     ret = where_history ();
@@ -128,7 +134,7 @@ noninc_dosearch (string, dir)
 
   if (string == 0 || *string == '\0' || noninc_history_pos < 0)
     {
-      ding ();
+      rl_ding ();
       return;
     }
 
@@ -136,10 +142,10 @@ noninc_dosearch (string, dir)
   if (pos == -1)
     {
       /* Search failed, current history position unchanged. */
-      maybe_unsave_line ();
+      rl_maybe_unsave_line ();
       rl_clear_message ();
       rl_point = 0;
-      ding ();
+      rl_ding ();
       return;
     }
 
@@ -172,7 +178,7 @@ noninc_search (dir, pchar)
   int saved_point, c;
   char *p;
 
-  maybe_save_line ();
+  rl_maybe_save_line ();
   saved_point = rl_point;
 
   /* Use the line buffer to read the search string. */
@@ -183,18 +189,26 @@ noninc_search (dir, pchar)
   rl_message (p, 0, 0);
   free (p);
 
-#define SEARCH_RETURN rl_restore_prompt (); return
+#define SEARCH_RETURN rl_restore_prompt (); RL_UNSETSTATE(RL_STATE_NSEARCH); return
 
+  RL_SETSTATE(RL_STATE_NSEARCH);
   /* Read the search string. */
-  while (c = rl_read_key ())
+  while (1)
     {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
+      c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
+      if (c == 0)
+	break;
+
       switch (c)
 	{
 	case CTRL('H'):
 	case RUBOUT:
 	  if (rl_point == 0)
 	    {
-	      maybe_unsave_line ();
+	      rl_maybe_unsave_line ();
 	      rl_clear_message ();
 	      rl_point = saved_point;
 	      SEARCH_RETURN;
@@ -218,10 +232,10 @@ noninc_search (dir, pchar)
 
 	case CTRL('C'):
 	case CTRL('G'):
-	  maybe_unsave_line ();
+	  rl_maybe_unsave_line ();
 	  rl_clear_message ();
 	  rl_point = saved_point;
-	  ding ();
+	  rl_ding ();
 	  SEARCH_RETURN;
 
 	default:
@@ -239,7 +253,7 @@ noninc_search (dir, pchar)
     {
       if (!noninc_search_string)
 	{
-	  ding ();
+	  rl_ding ();
 	  SEARCH_RETURN;
 	}
     }
@@ -253,6 +267,7 @@ noninc_search (dir, pchar)
 
   rl_restore_prompt ();
   noninc_dosearch (noninc_search_string, dir);
+  RL_UNSETSTATE(RL_STATE_NSEARCH);
 }
 
 /* Search forward through the history list for a string.  If the vi-mode
@@ -283,7 +298,7 @@ rl_noninc_forward_search_again (count, k
 {
   if (!noninc_search_string)
     {
-      ding ();
+      rl_ding ();
       return (-1);
     }
   noninc_dosearch (noninc_search_string, 1);
@@ -298,7 +313,7 @@ rl_noninc_reverse_search_again (count, k
 {
   if (!noninc_search_string)
     {
-      ding ();
+      rl_ding ();
       return (-1);
     }
   noninc_dosearch (noninc_search_string, -1);
@@ -312,7 +327,7 @@ rl_history_search_internal (count, dir)
   HIST_ENTRY *temp;
   int ret, oldpos;
 
-  maybe_save_line ();
+  rl_maybe_save_line ();
   temp = (HIST_ENTRY *)NULL;
 
   /* Search COUNT times through the history for a line whose prefix
@@ -341,8 +356,8 @@ rl_history_search_internal (count, dir)
   /* If we didn't find anything at all, return. */
   if (temp == 0)
     {
-      maybe_unsave_line ();
-      ding ();
+      rl_maybe_unsave_line ();
+      rl_ding ();
       /* If you don't want the saved history line (last match) to show up
          in the line buffer after the search fails, change the #if 0 to
          #if 1 */
@@ -353,7 +368,7 @@ rl_history_search_internal (count, dir)
           rl_line_buffer[rl_end] = '\0';
         }
 #else
-      rl_point = rl_history_search_len;	/* maybe_unsave_line changes it */
+      rl_point = rl_history_search_len;	/* rl_maybe_unsave_line changes it */
 #endif
       return 1;
     }
@@ -382,6 +397,7 @@ rl_history_search_reinit ()
       strncpy (history_search_string + 1, rl_line_buffer, rl_point);
       history_search_string[rl_point + 1] = '\0';
     }
+  _rl_free_saved_history_line ();
 }
 
 /* Search forward in the history for the string of characters
Index: readline/shell.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/shell.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 shell.c
--- readline/shell.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/shell.c	2003/02/17 12:47:10
@@ -27,7 +27,6 @@
 #endif
 
 #include <sys/types.h>
-#include <stdio.h>
 
 #if defined (HAVE_UNISTD_H)
 #  include <unistd.h>
@@ -46,15 +45,20 @@
 #endif /* !HAVE_STRING_H */
 
 #include <fcntl.h>
+#ifndef __MINGW32__
 #include <pwd.h>
+#else
+#include <windows.h>
+#endif
 
 #include <stdio.h>
 
+#include "rlstdc.h"
 #include "rlshell.h"
 #include "xmalloc.h"
 
 #if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid ();
+extern struct passwd *getpwuid __P((uid_t));
 #endif /* !HAVE_GETPW_DECLS */
 
 #ifndef NULL
@@ -66,7 +70,7 @@ extern struct passwd *getpwuid ();
 
 /* Does shell-like quoting using single quotes. */
 char *
-single_quote (string)
+sh_single_quote (string)
      char *string;
 {
   register int c;
@@ -97,7 +101,7 @@ single_quote (string)
 /* Set the environment variables LINES and COLUMNS to lines and cols,
    respectively. */
 void
-set_lines_and_columns (lines, cols)
+sh_set_lines_and_columns (lines, cols)
      int lines, cols;
 {
   char *b;
@@ -122,22 +126,26 @@ set_lines_and_columns (lines, cols)
 }
 
 char *
-get_env_value (varname)
-     char *varname;
+sh_get_env_value (varname)
+     const char *varname;
 {
   return ((char *)getenv (varname));
 }
 
 char *
-get_home_dir ()
+sh_get_home_dir ()
 {
   char *home_dir;
+#ifndef __MINGW32__
   struct passwd *entry;
 
   home_dir = (char *)NULL;
   entry = getpwuid (getuid ());
   if (entry)
     home_dir = entry->pw_dir;
+#else
+  home_dir = sh_get_env_value ("HOME");
+#endif
   return (home_dir);
 }
 
@@ -147,8 +155,9 @@ get_home_dir ()
 #  endif
 #endif
 
+#ifndef __MINGW32__
 int
-unset_nodelay_mode (fd)
+sh_unset_nodelay_mode (fd)
      int fd;
 {
   int flags, bflags;
@@ -174,3 +183,30 @@ unset_nodelay_mode (fd)
 
   return 0;
 }
+
+#else	/* __MINGW32__  */
+char *
+get_user_registry_string(char *keyName, char* valName)
+{
+  char *result = NULL;
+  HKEY	subKey;
+  if ( keyName && (RegOpenKeyEx(HKEY_CURRENT_USER, keyName, 0, KEY_READ, &subKey)
+                   == ERROR_SUCCESS) )
+    {
+      DWORD type;
+      char *chtry = NULL;
+      DWORD bufSize = 0;
+      
+      if ( (RegQueryValueExA(subKey, valName, NULL, &type, chtry, &bufSize)
+	    == ERROR_SUCCESS) && (type == REG_SZ) )
+        {
+	  if ( (chtry = (char *)xmalloc(bufSize))
+	       && (RegQueryValueExA(subKey, valName, NULL, &type, chtry, &bufSize) 
+		   == ERROR_SUCCESS) )
+	    result = chtry;
+        }
+    }
+  return result;
+}
+#endif	/* __MINGW32__  */
+
Index: readline/signals.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/signals.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 signals.c
--- readline/signals.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/signals.c	2003/02/17 12:47:10
@@ -61,7 +61,7 @@
 #  define SIGHANDLER_RETURN return (0)
 #endif
 
-/* This typedef is equivalant to the one for Function; it allows us
+/* This typedef is equivalent to the one for Function; it allows us
    to say SigHandler *foo = signal (SIGKILL, SIG_IGN); */
 typedef RETSIGTYPE SigHandler ();
 
@@ -73,7 +73,9 @@ typedef struct { SigHandler *sa_handler;
 #  define sigemptyset(m)
 #endif /* !HAVE_POSIX_SIGNALS */
 
+#ifndef __MINGW32__
 static SigHandler *rl_set_sighandler __P((int, SigHandler *, sighandler_cxt *));
+#endif
 
 /* Exported variables for use by applications. */
 
@@ -87,10 +89,9 @@ int rl_catch_sigwinch = 1;
 #endif
 
 static int signals_set_flag;
-#ifdef SIGWINCH
 static int sigwinch_set_flag;
-#endif
 
+#ifndef __MINGW32__
 /* **************************************************************** */
 /*					        		    */
 /*			   Signal Handling                          */
@@ -121,6 +122,8 @@ rl_signal_handler (sig)
 #  endif /* !HAVE_BSD_SIGNALS */
 #endif /* !HAVE_POSIX_SIGNALS */
 
+  RL_SETSTATE(RL_STATE_SIGHANDLER);
+
 #if !defined (HAVE_BSD_SIGNALS) && !defined (HAVE_POSIX_SIGNALS)
   /* Since the signal will not be blocked while we are in the signal
      handler, ignore it until rl_clear_signals resets the catcher. */
@@ -171,6 +174,7 @@ rl_signal_handler (sig)
       rl_reset_after_signal ();
     }
 
+  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
   SIGHANDLER_RETURN;
 }
 
@@ -191,6 +195,7 @@ rl_sigwinch_handler (sig)
   rl_set_sighandler (SIGWINCH, rl_sigwinch_handler, &dummy_winch);
 #endif
 
+  RL_SETSTATE(RL_STATE_SIGHANDLER);
   rl_resize_terminal ();
 
   /* If another sigwinch handler has been installed, call it. */
@@ -198,6 +203,7 @@ rl_sigwinch_handler (sig)
   if (oh &&  oh != (SigHandler *)SIG_IGN && oh != (SigHandler *)SIG_DFL)
     (*oh) (sig);
 
+  RL_UNSETSTATE(RL_STATE_SIGHANDLER);
   SIGHANDLER_RETURN;
 }
 #endif  /* SIGWINCH */
@@ -351,6 +357,7 @@ rl_clear_signals ()
 
   return 0;
 }
+#endif /* !__MINGW32__ */
 
 /* Clean up the terminal and readline state after catching a signal, before
    resending it to the calling application. */
@@ -360,7 +367,7 @@ rl_cleanup_after_signal ()
   _rl_clean_up_for_exit ();
   (*rl_deprep_term_function) ();
   rl_clear_signals ();
-  rl_pending_input = 0;
+  rl_clear_pending_input ();
 }
 
 /* Reset the terminal and readline state after a signal handler returns. */
@@ -380,7 +387,7 @@ rl_free_line_state ()
 {
   register HIST_ENTRY *entry;
 
-  free_undo_list ();
+  rl_free_undo_list ();
 
   entry = current_history ();
   if (entry)
@@ -391,4 +398,50 @@ rl_free_line_state ()
   _rl_init_argument ();
 }
 
+#if defined (__MINGW32__)
+
+#include <windows.h>
+#include <signal.h>
+#include <stdio.h>
+
+/* Handling of CTRL_C_EVENT, CTRL_CLOSE_EVENT, CTRL_BREAK_EVENT, 
+ * CTRL_LOGOFF_EVENT, CTRL_SHUTDOWN_EVENT,
+ * WINDOW_BUFFER_SIZE_EVENTs are handled separately see input.c
+ */
+
+BOOL CtrlEventHandler(DWORD dwEventType)
+{
+  if (dwEventType == CTRL_C_EVENT)
+    rl_free_line_state ();
+  rl_cleanup_after_signal ();
+  if (dwEventType == CTRL_C_EVENT)	/* special treatment */
+    {
+      if (rl_catch_signals == 1)	/* > 1: handled only locally */
+	{
+	  raise(SIGINT);		/* pass to program signal hadler */
+	  rl_reset_after_signal();	/* on return goon */
+	}
+      return TRUE;			/* don't pass to upstream handlers */
+    }
+  return FALSE; 			/* pass other events to handler chain */
+}
+
+int
+rl_set_signals ()
+{
+  if (rl_catch_signals && signals_set_flag == 0)
+    signals_set_flag = SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlEventHandler, TRUE);
+  return signals_set_flag;
+}
+
+int
+rl_clear_signals ()
+{
+  if ( signals_set_flag )
+    if ( SetConsoleCtrlHandler( (PHANDLER_ROUTINE) CtrlEventHandler, FALSE) )
+      signals_set_flag = 0;
+  return signals_set_flag;
+}
+
+#endif	/* __MINGW32__  */
 #endif  /* HANDLE_SIGNALS */
Index: readline/terminal.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/terminal.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 terminal.c
--- readline/terminal.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/terminal.c	2003/02/17 12:47:10
@@ -51,12 +51,16 @@
 /* System-specific feature definitions and include files. */
 #include "rldefs.h"
 
+#if defined (__MINGW32__)
+# include <windows.h>
+extern int haveConsole;	/* imported from rltty.c  */
+extern HANDLE hStdout, hStdin;
+extern COORD	rlScreenEnd;
+extern int	rlScreenMax;
+#else /* !__MINGW32__ */
 #if defined (GWINSZ_IN_SYS_IOCTL) && !defined (TIOCGWINSZ)
 #  include <sys/ioctl.h>
 #endif /* GWINSZ_IN_SYS_IOCTL && !TIOCGWINSZ */
-
-#ifdef __MSDOS__
-# include <pc.h>
 #endif
 
 #include "rltty.h"
@@ -75,15 +79,12 @@
 /*								    */
 /* **************************************************************** */
 
-#ifndef __MSDOS__
+#ifndef __MINGW32__
 static char *term_buffer = (char *)NULL;
 static char *term_string_buffer = (char *)NULL;
 
-/* Non-zero means this terminal can't really do anything. */
-static int dumb_term;
-#endif /* !__MSDOS__ */
-
 static int tcap_initialized;
+#endif
 
 #if !defined (__linux__)
 #  if defined (__EMX__) || defined (NEED_EXTERN_PC)
@@ -93,27 +94,36 @@ char PC, *BC, *UP;
 #endif /* __linux__ */
 
 /* Some strings to control terminal actions.  These are output by tputs (). */
-char *term_goto, *term_clreol, *term_cr, *term_clrpag, *term_backspace;
-char *term_pc;
+char *_rl_term_clreol;
+char *_rl_term_clrpag;
+char *_rl_term_cr;
+char *_rl_term_backspace;
+char *_rl_term_goto;
+char *_rl_term_pc;
 
 /* Non-zero if we determine that the terminal can do character insertion. */
-int terminal_can_insert = 0;
+int _rl_terminal_can_insert = 0;
 
 /* How to insert characters. */
-char *term_im, *term_ei, *term_ic, *term_ip, *term_IC;
+char *_rl_term_im;
+char *_rl_term_ei;
+char *_rl_term_ic;
+char *_rl_term_ip;
+char *_rl_term_IC;
 
 /* How to delete characters. */
-char *term_dc, *term_DC;
+char *_rl_term_dc;
+char *_rl_term_DC;
 
 #if defined (HACK_TERMCAP_MOTION)
-char *term_forward_char;
+char *_rl_term_forward_char;
 #endif  /* HACK_TERMCAP_MOTION */
 
 /* How to go up a line. */
-char *term_up;
+char *_rl_term_up;
 
-/* A visible bell, if the terminal can be made to flash the screen. */
-static char *visible_bell;
+/* A visible bell; char if the terminal can be made to flash the screen. */
+static char *_rl_visible_bell;
 
 /* Non-zero means the terminal can auto-wrap lines. */
 int _rl_term_autowrap;
@@ -122,20 +132,26 @@ int _rl_term_autowrap;
 static int term_has_meta;
 
 /* The sequences to write to turn on and off the meta key, if this
-   terminal    has one. */
-static char *term_mm, *term_mo;
+   terminal has one. */
+static char *_rl_term_mm;
+static char *_rl_term_mo;
 
 /* The key sequences output by the arrow keys, if this terminal has any. */
-static char *term_ku, *term_kd, *term_kr, *term_kl;
+static char *_rl_term_ku;
+static char *_rl_term_kd;
+static char *_rl_term_kr;
+static char *_rl_term_kl;
 
 /* How to initialize and reset the arrow keys, if this terminal has any. */
-static char *term_ks, *term_ke;
+static char *_rl_term_ks;
+static char *_rl_term_ke;
 
 /* The key sequences sent by the Home and End keys, if any. */
-static char *term_kh, *term_kH;
+static char *_rl_term_kh;
+static char *_rl_term_kH;
 
 /* Variables that hold the screen dimensions, used by the display code. */
-int screenwidth, screenheight, screenchars;
+int _rl_screenwidth, _rl_screenheight, _rl_screenchars;
 
 /* Non-zero means the user wants to enable the keypad. */
 int _rl_enable_keypad;
@@ -163,6 +179,7 @@ _emx_get_screensize (swp, shp)
    to the terminal.  If IGNORE_ENV is true, we do not pay attention to the
    values of $LINES and $COLUMNS.  The tests for TERM_STRING_BUFFER being
    non-null serve to check whether or not we have initialized termcap. */
+#ifndef __MINGW32__
 void
 _rl_get_screen_size (tty, ignore_env)
      int tty, ignore_env;
@@ -175,79 +192,115 @@ _rl_get_screen_size (tty, ignore_env)
 #if defined (TIOCGWINSZ)
   if (ioctl (tty, TIOCGWINSZ, &window_size) == 0)
     {
-      screenwidth = (int) window_size.ws_col;
-      screenheight = (int) window_size.ws_row;
+      _rl_screenwidth = (int) window_size.ws_col;
+      _rl_screenheight = (int) window_size.ws_row;
     }
 #endif /* TIOCGWINSZ */
 
 #if defined (__EMX__)
-  _emx_get_screensize (&screenwidth, &screenheight);
+  _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
 #endif
 
   /* Environment variable COLUMNS overrides setting of "co" if IGNORE_ENV
      is unset. */
-  if (screenwidth <= 0)
+  if (_rl_screenwidth <= 0)
     {
-      if (ignore_env == 0 && (ss = get_env_value ("COLUMNS")))
-	screenwidth = atoi (ss);
+      if (ignore_env == 0 && (ss = sh_get_env_value ("COLUMNS")))
+	_rl_screenwidth = atoi (ss);
 
-#if defined (__DJGPP__)
-      if (screenwidth <= 0)
-	screenwidth = ScreenCols ();
-#else
-      if (screenwidth <= 0 && term_string_buffer)
-	screenwidth = tgetnum ("co");
+#if !defined (__DJGPP__)
+      if (_rl_screenwidth <= 0 && term_string_buffer)
+	_rl_screenwidth = tgetnum ("co");
 #endif
     }
 
   /* Environment variable LINES overrides setting of "li" if IGNORE_ENV
      is unset. */
-  if (screenheight <= 0)
+  if (_rl_screenheight <= 0)
     {
-      if (ignore_env == 0 && (ss = get_env_value ("LINES")))
-	screenheight = atoi (ss);
+      if (ignore_env == 0 && (ss = sh_get_env_value ("LINES")))
+	_rl_screenheight = atoi (ss);
 
-#if defined (__DJGPP__)
-      if (screenheight <= 0)
-	screenheight = ScreenRows ();
-#else
-      if (screenheight <= 0 && term_string_buffer)
-	screenheight = tgetnum ("li");
+#if !defined (__DJGPP__)
+      if (_rl_screenheight <= 0 && term_string_buffer)
+	_rl_screenheight = tgetnum ("li");
 #endif
     }
 
   /* If all else fails, default to 80x24 terminal. */
-  if (screenwidth <= 1)
-    screenwidth = 80;
+  if (_rl_screenwidth <= 1)
+    _rl_screenwidth = 80;
 
-  if (screenheight <= 0)
-    screenheight = 24;
+  if (_rl_screenheight <= 0)
+    _rl_screenheight = 24;
 
   /* If we're being compiled as part of bash, set the environment
      variables $LINES and $COLUMNS to new values.  Otherwise, just
      do a pair of putenv () or setenv () calls. */
-  set_lines_and_columns (screenheight, screenwidth);
+  sh_set_lines_and_columns (_rl_screenheight, _rl_screenwidth);
 
   if (_rl_term_autowrap == 0)
-    screenwidth--;
+    _rl_screenwidth--;
 
-  screenchars = screenwidth * screenheight;
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+}
+
+#else	/* __MINGW32__*/
+
+void
+_rl_get_screen_size (tty, ignore_env)
+     int tty, ignore_env;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      _rl_screenwidth = csbi.dwSize.X;
+      _rl_screenheight = csbi.dwSize.Y;
+    }
+  else
+    {
+      _rl_screenwidth = 80;
+      _rl_screenheight = 24;
+    }
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
 }
+#endif	/* __MINGW32__  */
 
 void
 _rl_set_screen_size (rows, cols)
      int rows, cols;
 {
-  screenheight = rows;
-  screenwidth = cols;
+  if (rows == 0 || cols == 0)
+    return;
 
+  _rl_screenheight = rows;
+  _rl_screenwidth = cols;
+
   if (_rl_term_autowrap == 0)
-    screenwidth--;
+    _rl_screenwidth--;
 
-  screenchars = screenwidth * screenheight;
+  _rl_screenchars = _rl_screenwidth * _rl_screenheight;
 }
 
 void
+rl_set_screen_size (rows, cols)
+     int rows, cols;
+{
+  _rl_set_screen_size (rows, cols);
+}
+
+void
+rl_get_screen_size (rows, cols)
+     int *rows, *cols;
+{
+  if (rows)
+    *rows = _rl_screenheight;
+  if (cols)
+    *cols = _rl_screenwidth;
+}
+     
+void
 rl_resize_terminal ()
 {
   if (readline_echoing_p)
@@ -257,8 +310,9 @@ rl_resize_terminal ()
     }
 }
 
+#ifndef __MINGW32__
 struct _tc_string {
-     char *tc_var;
+     const char *tc_var;
      char **tc_value;
 };
 
@@ -266,32 +320,32 @@ struct _tc_string {
    search algorithm to something smarter. */
 static struct _tc_string tc_strings[] =
 {
-  { "DC", &term_DC },
-  { "IC", &term_IC },
-  { "ce", &term_clreol },
-  { "cl", &term_clrpag },
-  { "cr", &term_cr },
-  { "dc", &term_dc },
-  { "ei", &term_ei },
-  { "ic", &term_ic },
-  { "im", &term_im },
-  { "kd", &term_kd },
-  { "kh", &term_kh },	/* home */
-  { "kH", &term_kH },	/* end */
-  { "kl", &term_kl },
-  { "kr", &term_kr },
-  { "ku", &term_ku },
-  { "ks", &term_ks },
-  { "ke", &term_ke },
-  { "le", &term_backspace },
-  { "mm", &term_mm },
-  { "mo", &term_mo },
+  { "DC", &_rl_term_DC },
+  { "IC", &_rl_term_IC },
+  { "ce", &_rl_term_clreol },
+  { "cl", &_rl_term_clrpag },
+  { "cr", &_rl_term_cr },
+  { "dc", &_rl_term_dc },
+  { "ei", &_rl_term_ei },
+  { "ic", &_rl_term_ic },
+  { "im", &_rl_term_im },
+  { "kd", &_rl_term_kd },
+  { "kh", &_rl_term_kh },	/* home */
+  { "kH", &_rl_term_kH },	/* end */
+  { "kl", &_rl_term_kl },
+  { "kr", &_rl_term_kr },
+  { "ku", &_rl_term_ku },
+  { "ks", &_rl_term_ks },
+  { "ke", &_rl_term_ke },
+  { "le", &_rl_term_backspace },
+  { "mm", &_rl_term_mm },
+  { "mo", &_rl_term_mo },
 #if defined (HACK_TERMCAP_MOTION)
-  { "nd", &term_forward_char },
+  { "nd", &_rl_term_forward_char },
 #endif
-  { "pc", &term_pc },
-  { "up", &term_up },
-  { "vb", &visible_bell },
+  { "pc", &_rl_term_pc },
+  { "up", &_rl_term_up },
+  { "vb", &_rl_visible_bell },
 };
 
 #define NUM_TC_STRINGS (sizeof (tc_strings) / sizeof (struct _tc_string))
@@ -310,36 +364,53 @@ get_term_capabilities (bp)
 #endif
   tcap_initialized = 1;
 }
+#endif /* __MINGW32__ */
 
 #define CUSTOM_REDISPLAY_FUNC() (rl_redisplay_function != rl_redisplay)
 #define CUSTOM_INPUT_FUNC() (rl_getc_function != rl_getc)
 
 int
 _rl_init_terminal_io (terminal_name)
-     char *terminal_name;
+     const char *terminal_name;
 {
-  char *term, *buffer;
+#ifdef __MINGW32__
+  _rl_term_cr = "\r";						/* any value != 0  */
+  _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;	/* !! we emulate insertion  */
+  _rl_term_up = "y";						/* any value != 0  */
+  _rl_term_dc = _rl_term_DC =  (char *)NULL;			/* !! we emulate deletion  */
+  _rl_visible_bell = (char *)NULL;
+ 
+  _rl_get_screen_size (0, 1);
+   
+  /* Let Windows handle meta keys!  */
+  term_has_meta = 0;
+  _rl_term_mm = _rl_term_mo = (char *)NULL;
+ 
+  /* It probably has arrow keys, but I don't know what they are. */
+  _rl_term_ku = _rl_term_kd = _rl_term_kr = _rl_term_kl = (char *)NULL;
+  
+#if defined (HACK_TERMCAP_MOTION)
+  _rl_term_forward_char = (char *)NULL;
+#endif /* HACK_TERMCAP_MOTION */
+ 
+  _rl_terminal_can_insert = 0;
+  _rl_term_autowrap = 1;
+
+#else /* !__MINGW32__ */
+
+  const char *term;
+  char *buffer;
   int tty, tgetent_ret;
   Keymap xkeymap;
 
-  term = terminal_name ? terminal_name : get_env_value ("TERM");
-  term_clrpag = term_cr = term_clreol = (char *)NULL;
+  term = terminal_name ? terminal_name : sh_get_env_value ("TERM");
+  _rl_term_clrpag = _rl_term_cr = _rl_term_clreol = (char *)NULL;
   tty = rl_instream ? fileno (rl_instream) : 0;
-  screenwidth = screenheight = 0;
+  _rl_screenwidth = _rl_screenheight = 0;
 
   if (term == 0)
     term = "dumb";
 
-#ifdef __MSDOS__
-  term_im = term_ei = term_ic = term_IC = (char *)NULL;
-  term_up = term_dc = term_DC = visible_bell = (char *)NULL;
-  term_ku = term_kd = term_kl = term_kr = (char *)NULL;
-  term_mm = term_mo = (char *)NULL;
-  terminal_can_insert = term_has_meta = _rl_term_autowrap = 0;
-  term_cr = "\r";
-
-  _rl_get_screen_size (tty, 0);
-#else  /* !__MSDOS__ */
   /* I've separated this out for later work on not calling tgetent at all
      if the calling application has supplied a custom redisplay function,
      (and possibly if the application has supplied a custom input function). */
@@ -366,41 +437,40 @@ _rl_init_terminal_io (terminal_name)
       FREE (term_buffer);
       buffer = term_buffer = term_string_buffer = (char *)NULL;
 
-      dumb_term = 1;
       _rl_term_autowrap = 0;	/* used by _rl_get_screen_size */
 
 #if defined (__EMX__)
-      _emx_get_screensize (&screenwidth, &screenheight);
-      screenwidth--;
+      _emx_get_screensize (&_rl_screenwidth, &_rl_screenheight);
+      _rl_screenwidth--;
 #else /* !__EMX__ */
       _rl_get_screen_size (tty, 0);
 #endif /* !__EMX__ */
 
       /* Defaults. */
-      if (screenwidth <= 0 || screenheight <= 0)
+      if (_rl_screenwidth <= 0 || _rl_screenheight <= 0)
         {
-	  screenwidth = 79;
-	  screenheight = 24;
+	  _rl_screenwidth = 79;
+	  _rl_screenheight = 24;
         }
 
       /* Everything below here is used by the redisplay code (tputs). */
-      screenchars = screenwidth * screenheight;
-      term_cr = "\r";
-      term_im = term_ei = term_ic = term_IC = (char *)NULL;
-      term_up = term_dc = term_DC = visible_bell = (char *)NULL;
-      term_ku = term_kd = term_kl = term_kr = (char *)NULL;
-      term_mm = term_mo = (char *)NULL;
+      _rl_screenchars = _rl_screenwidth * _rl_screenheight;
+      _rl_term_cr = "\r";
+      _rl_term_im = _rl_term_ei = _rl_term_ic = _rl_term_IC = (char *)NULL;
+      _rl_term_up = _rl_term_dc = _rl_term_DC = _rl_visible_bell = (char *)NULL;
+      _rl_term_ku = _rl_term_kd = _rl_term_kl = _rl_term_kr = (char *)NULL;
+      _rl_term_mm = _rl_term_mo = (char *)NULL;
 #if defined (HACK_TERMCAP_MOTION)
-      term_forward_char = (char *)NULL;
+      _rl_term_forward_char = (char *)NULL;
 #endif
-      terminal_can_insert = term_has_meta = 0;
+      _rl_terminal_can_insert = term_has_meta = 0;
 
       /* Reasonable defaults for tgoto().  Readline currently only uses
-         tgoto if term_IC or term_DC is defined, but just in case we
+         tgoto if _rl_term_IC or _rl_term_DC is defined, but just in case we
          change that later... */
       PC = '\0';
-      BC = term_backspace = "\b";
-      UP = term_up;
+      BC = _rl_term_backspace = "\b";
+      UP = _rl_term_up;
 
       return 0;
     }
@@ -409,12 +479,12 @@ _rl_init_terminal_io (terminal_name)
 
   /* Set up the variables that the termcap library expects the application
      to provide. */
-  PC = term_pc ? *term_pc : 0;
-  BC = term_backspace;
-  UP = term_up;
+  PC = _rl_term_pc ? *_rl_term_pc : 0;
+  BC = _rl_term_backspace;
+  UP = _rl_term_up;
 
-  if (!term_cr)
-    term_cr = "\r";
+  if (!_rl_term_cr)
+    _rl_term_cr = "\r";
 
   _rl_term_autowrap = tgetflag ("am") && tgetflag ("xn");
 
@@ -424,48 +494,48 @@ _rl_init_terminal_io (terminal_name)
       character insertion if *any one of* the capabilities `IC',
       `im', `ic' or `ip' is provided."  But we can't do anything if
       only `ip' is provided, so... */
-  terminal_can_insert = (term_IC || term_im || term_ic);
+  _rl_terminal_can_insert = (_rl_term_IC || _rl_term_im || _rl_term_ic);
 
   /* Check to see if this terminal has a meta key and clear the capability
      variables if there is none. */
   term_has_meta = (tgetflag ("km") || tgetflag ("MT"));
   if (!term_has_meta)
-    term_mm = term_mo = (char *)NULL;
+    _rl_term_mm = _rl_term_mo = (char *)NULL;
 
-#endif /* !__MSDOS__ */
-
   /* Attempt to find and bind the arrow keys.  Do not override already
      bound keys in an overzealous attempt, however. */
   xkeymap = _rl_keymap;
 
   _rl_keymap = emacs_standard_keymap;
-  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (term_kr, rl_forward);
-  _rl_bind_if_unbound (term_kl, rl_backward);
+  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
+  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
 
-  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
 
 #if defined (VI_MODE)
   _rl_keymap = vi_movement_keymap;
-  _rl_bind_if_unbound (term_ku, rl_get_previous_history);
-  _rl_bind_if_unbound (term_kd, rl_get_next_history);
-  _rl_bind_if_unbound (term_kr, rl_forward);
-  _rl_bind_if_unbound (term_kl, rl_backward);
+  _rl_bind_if_unbound (_rl_term_ku, rl_get_previous_history);
+  _rl_bind_if_unbound (_rl_term_kd, rl_get_next_history);
+  _rl_bind_if_unbound (_rl_term_kr, rl_forward);
+  _rl_bind_if_unbound (_rl_term_kl, rl_backward);
 
-  _rl_bind_if_unbound (term_kh, rl_beg_of_line);	/* Home */
-  _rl_bind_if_unbound (term_kH, rl_end_of_line);	/* End */
+  _rl_bind_if_unbound (_rl_term_kh, rl_beg_of_line);	/* Home */
+  _rl_bind_if_unbound (_rl_term_kH, rl_end_of_line);	/* End */
 #endif /* VI_MODE */
 
   _rl_keymap = xkeymap;
 
+#endif /* !__MINGW32__ */
   return 0;
 }
 
+#ifndef __MINGW32__
 char *
 rl_get_termcap (cap)
-     char *cap;
+     const char *cap;
 {
   register int i;
 
@@ -478,17 +548,19 @@ rl_get_termcap (cap)
     }
   return ((char *)NULL);
 }
+#endif
 
 /* Re-initialize the terminal considering that the TERM/TERMCAP variable
    has changed. */
 int
 rl_reset_terminal (terminal_name)
-     char *terminal_name;
+     const char *terminal_name;
 {
   _rl_init_terminal_io (terminal_name);
   return 0;
 }
 
+#ifndef __MINGW32__
 /* A function for the use of tputs () */
 #ifdef _MINIX
 void
@@ -509,7 +581,7 @@ _rl_output_character_function (c)
 /* Write COUNT characters from STRING to the output stream. */
 void
 _rl_output_some_chars (string, count)
-     char *string;
+     const char *string;
      int count;
 {
   fwrite (string, 1, count, _rl_out_stream);
@@ -522,12 +594,10 @@ _rl_backspace (count)
 {
   register int i;
 
-#ifndef __MSDOS__
-  if (term_backspace)
+  if (_rl_term_backspace)
     for (i = 0; i < count; i++)
-      tputs (term_backspace, 1, _rl_output_character_function);
+      tputs (_rl_term_backspace, 1, _rl_output_character_function);
   else
-#endif
     for (i = 0; i < count; i++)
       putc ('\b', _rl_out_stream);
   return 0;
@@ -535,11 +605,11 @@ _rl_backspace (count)
 
 /* Move to the start of the next line. */
 int
-crlf ()
+rl_crlf ()
 {
 #if defined (NEW_TTY_DRIVER)
-  if (term_cr)
-    tputs (term_cr, 1, _rl_output_character_function);
+  if (_rl_term_cr)
+    tputs (_rl_term_cr, 1, _rl_output_character_function);
 #endif /* NEW_TTY_DRIVER */
   putc ('\n', _rl_out_stream);
   return 0;
@@ -547,7 +617,7 @@ crlf ()
 
 /* Ring the terminal bell. */
 int
-ding ()
+rl_ding ()
 {
   if (readline_echoing_p)
     {
@@ -557,16 +627,11 @@ ding ()
 	default:
 	  break;
 	case VISIBLE_BELL:
-#ifdef __MSDOS__
-	  ScreenVisualBell ();
-	  break;
-#else
-	  if (visible_bell)
+	  if (_rl_visible_bell)
 	    {
-	      tputs (visible_bell, 1, _rl_output_character_function);
+	      tputs (_rl_visible_bell, 1, _rl_output_character_function);
 	      break;
 	    }
-#endif
 	  /* FALLTHROUGH */
 	case AUDIBLE_BELL:
 	  fprintf (stderr, "\007");
@@ -578,6 +643,80 @@ ding ()
   return (-1);
 }
 
+#else	/* __MINGW32__ */
+
+/* Write COUNT characters from STRING to the output stream. */
+void
+_rl_output_some_chars (string, count)
+     const char *string;
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+  fwrite (string, 1, count, _rl_out_stream);
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      int linear_pos = (int)csbi.dwCursorPosition.Y * (int)csbi.dwSize.X
+			+ (int)csbi.dwCursorPosition.X;
+      if (linear_pos > rlScreenMax)
+        {
+          rlScreenEnd = csbi.dwCursorPosition;
+          rlScreenMax = linear_pos;
+        }
+    }
+}
+
+/* This is used to collect all putc output */
+int
+_rl_output_character_function (c)
+     int c;
+{
+  _rl_output_some_chars ((char *)&c, 1);
+  return 1;
+}
+
+/* Move the cursor back. */
+int
+_rl_backspace (count)
+     int count;
+{
+  CONSOLE_SCREEN_BUFFER_INFO	csbi;
+
+  if ( (haveConsole & FOR_OUTPUT) && GetConsoleScreenBufferInfo(hStdout, &csbi) )
+    {
+      while (count > csbi.dwCursorPosition.X)
+        {
+          --csbi.dwCursorPosition.Y;
+          count -= csbi.dwCursorPosition.X + 1;
+          csbi.dwCursorPosition.X = csbi.dwSize.X - 1;
+        }
+      csbi.dwCursorPosition.X -= count;
+      SetConsoleCursorPosition(hStdout, csbi.dwCursorPosition);
+    }
+  return 0;
+}
+
+/* Move to the start of the next line. */
+int
+rl_crlf ()
+{
+  _rl_output_some_chars ("\n", 1);
+  return 0;
+}
+
+/* Ring the terminal bell. */
+int
+rl_ding ()
+{
+  if (readline_echoing_p)
+    {
+      if (_rl_bell_preference != NO_BELL)
+	MessageBeep(MB_OK);
+      return (0);
+    }
+  return (-1);
+}
+#endif	/* __MINGW32__ */
+
 /* **************************************************************** */
 /*								    */
 /*	 	Controlling the Meta Key and Keypad		    */
@@ -587,9 +726,9 @@ ding ()
 void
 _rl_enable_meta_key ()
 {
-#if !defined (__DJGPP__)
-  if (term_has_meta && term_mm)
-    tputs (term_mm, 1, _rl_output_character_function);
+#if !defined (__DJGPP__) && !defined (__MINGW32__)
+  if (term_has_meta && _rl_term_mm)
+    tputs (_rl_term_mm, 1, _rl_output_character_function);
 #endif
 }
 
@@ -597,10 +736,10 @@ void
 _rl_control_keypad (on)
      int on;
 {
-#if !defined (__DJGPP__)
-  if (on && term_ks)
-    tputs (term_ks, 1, _rl_output_character_function);
-  else if (!on && term_ke)
-    tputs (term_ke, 1, _rl_output_character_function);
+#if !defined (__DJGPP__) && !defined (__MINGW32__)
+  if (on && _rl_term_ks)
+    tputs (_rl_term_ks, 1, _rl_output_character_function);
+  else if (!on && _rl_term_ke)
+    tputs (_rl_term_ke, 1, _rl_output_character_function);
 #endif
 }
Index: readline/tilde.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/tilde.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 tilde.c
--- readline/tilde.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/tilde.c	2003/02/17 12:47:10
@@ -43,23 +43,24 @@
 #endif /* HAVE_STDLIB_H */
 
 #include <sys/types.h>
+#ifndef __MINGW32__
 #include <pwd.h>
+#else
+#include <windows.h>
+#endif
 
 #include "tilde.h"
 
 #if defined (TEST) || defined (STATIC_MALLOC)
 static char *xmalloc (), *xrealloc ();
 #else
-#  if defined __STDC__
-extern char *xmalloc (int);
-extern char *xrealloc (void *, int);
-#  else
-extern char *xmalloc (), *xrealloc ();
-#  endif /* !__STDC__ */
+extern char *xmalloc __P((int));
+extern char *xrealloc __P((void *, int));
 #endif /* TEST || STATIC_MALLOC */
 
 #if !defined (HAVE_GETPW_DECLS)
-extern struct passwd *getpwuid (), *getpwnam ();
+extern struct passwd *getpwuid __P((uid_t));
+extern struct passwd *getpwnam __P((const char *));
 #endif /* !HAVE_GETPW_DECLS */
 
 #if !defined (savestring)
@@ -80,42 +81,42 @@ extern char *strcpy ();
 /* If being compiled as part of bash, these will be satisfied from
    variables.o.  If being compiled as part of readline, they will
    be satisfied from shell.o. */
-extern char *get_home_dir __P((void));
-extern char *get_env_value __P((char *));
+extern char *sh_get_home_dir __P((void));
+extern char *sh_get_env_value __P((const char *));
 
 /* The default value of tilde_additional_prefixes.  This is set to
    whitespace preceding a tilde so that simple programs which do not
    perform any word separation get desired behaviour. */
-static char *default_prefixes[] =
-  { " ~", "\t~", (char *)NULL };
+static const char *default_prefixes[] =
+  { " ~", "\t~", (const char *)NULL };
 
 /* The default value of tilde_additional_suffixes.  This is set to
    whitespace or newline so that simple programs which do not
    perform any word separation get desired behaviour. */
-static char *default_suffixes[] =
-  { " ", "\n", (char *)NULL };
+static const char *default_suffixes[] =
+  { " ", "\n", (const char *)NULL };
 
 /* If non-null, this contains the address of a function that the application
    wants called before trying the standard tilde expansions.  The function
    is called with the text sans tilde, and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if the expansion fails. */
-CPFunction *tilde_expansion_preexpansion_hook = (CPFunction *)NULL;
+tilde_hook_func_t *tilde_expansion_preexpansion_hook = (tilde_hook_func_t *)NULL;
 
 /* If non-null, this contains the address of a function to call if the
    standard meaning for expanding a tilde fails.  The function is called
    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if there is no expansion. */
-CPFunction *tilde_expansion_failure_hook = (CPFunction *)NULL;
+tilde_hook_func_t *tilde_expansion_failure_hook = (tilde_hook_func_t *)NULL;
 
 /* When non-null, this is a NULL terminated array of strings which
    are duplicates for a tilde prefix.  Bash uses this to expand
    `=~' and `:~'. */
-char **tilde_additional_prefixes = default_prefixes;
+char **tilde_additional_prefixes = (char **)default_prefixes;
 
 /* When non-null, this is a NULL terminated array of strings which match
    the end of a username, instead of just "/".  Bash sets this to
    `:' and `=~'. */
-char **tilde_additional_suffixes = default_suffixes;
+char **tilde_additional_suffixes = (char **)default_suffixes;
 
 /* Find the start of a tilde expansion in STRING, and return the index of
    the tilde which starts the expansion.  Place the length of the text
@@ -186,7 +187,7 @@ tilde_find_suffix (string)
 /* Return a new string which is the result of tilde expanding STRING. */
 char *
 tilde_expand (string)
-     char *string;
+     const char *string;
 {
   char *result;
   int result_size, result_index;
@@ -235,9 +236,9 @@ tilde_expand (string)
       free (tilde_word);
 
       len = strlen (expansion);
-#ifdef __CYGWIN32__
+#ifdef __CYGWIN__
       /* Fix for Cygwin to prevent ~user/xxx from expanding to //xxx when
-         $HOME for `user' is /.  On cygwin, // denotes a network drive. */
+	 $HOME for `user' is /.  On cygwin, // denotes a network drive. */
       if (len > 1 || *expansion != '/' || *string != '/')
 #endif
 	{
@@ -303,11 +304,16 @@ glue_prefix_and_suffix (prefix, suffix, 
    This always returns a newly-allocated string, never static storage. */
 char *
 tilde_expand_word (filename)
-     char *filename;
+     const char *filename;
 {
   char *dirname, *expansion, *username;
   int user_len;
+#ifndef __MINGW32__
   struct passwd *user_entry;
+#else
+  char UserName[256];
+  unsigned long UserLen = 256;
+#endif
 
   if (filename == 0)
     return ((char *)NULL);
@@ -321,12 +327,12 @@ tilde_expand_word (filename)
   if (filename[1] == '\0' || filename[1] == '/')
     {
       /* Prefix $HOME to the rest of the string. */
-      expansion = get_env_value ("HOME");
+      expansion = sh_get_env_value ("HOME");
 
       /* If there is no HOME variable, look up the directory in
 	 the password database. */
       if (expansion == 0)
-	expansion = get_home_dir ();
+	expansion = sh_get_home_dir ();
 
       return (glue_prefix_and_suffix (expansion, filename, 1));
     }
@@ -348,6 +354,7 @@ tilde_expand_word (filename)
   /* No preexpansion hook, or the preexpansion hook failed.  Look in the
      password database. */
   dirname = (char *)NULL;
+#ifndef __MINGW32__
   user_entry = getpwnam (username);
   if (user_entry == 0)
     {
@@ -375,6 +382,16 @@ tilde_expand_word (filename)
     }
 
   endpwent ();
+#else /* __MINGW32__ */
+  if (GetUserName (UserName, &UserLen))
+    {
+      if (!stricmp (username, UserName))
+	dirname = glue_prefix_and_suffix (sh_get_home_dir (), filename, user_len);
+      else if (dirname == 0)
+	dirname = savestring (filename);
+    }
+  free (username);
+#endif
   return (dirname);
 }
 
Index: readline/tilde.h
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/tilde.h,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 tilde.h
--- readline/tilde.h	2003/02/16 21:36:32	1.1.1.1
+++ readline/tilde.h	2003/02/17 12:47:10
@@ -28,6 +28,14 @@
 extern "C" {
 #endif
 
+#if __READLINE_EXPORT__
+# define READLINE_API __declspec (dllexport)
+#elif __READLINE_IMPORT__
+# define READLINE_API __declspec (dllimport)
+#else
+# define READLINE_API
+#endif
+
 /* A function can be defined using prototypes and compile on both ANSI C
    and traditional C compilers with something like this:
 	extern char *func __P((char *, char *, int)); */
@@ -39,44 +47,49 @@ extern "C" {
 #    define __P(protos) ()
 #  endif
 #endif
+
+#if !defined (__STDC__) && !defined (__cplusplus)
+#  if defined (__GNUC__)	/* gcc with -traditional */
+#    if !defined (const)
+#      define const __const
+#    endif /* !const */
+#  else /* !__GNUC__ */
+#    if !defined (const)
+#      define const
+#    endif /* !const */
+#  endif /* !__GNUC__ */
+#endif /* !__STDC__ && !__cplusplus */
 
-/* Function pointers can be declared as (Function *)foo. */
-#if !defined (_FUNCTION_DEF)
-#  define _FUNCTION_DEF
-typedef int Function ();
-typedef void VFunction ();
-typedef char *CPFunction ();
-typedef char **CPPFunction ();
-#endif /* _FUNCTION_DEF */
+typedef char *tilde_hook_func_t __P((char *));
 
 /* If non-null, this contains the address of a function that the application
    wants called before trying the standard tilde expansions.  The function
    is called with the text sans tilde, and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if the expansion fails. */
-extern CPFunction *tilde_expansion_preexpansion_hook;
+READLINE_API extern tilde_hook_func_t *tilde_expansion_preexpansion_hook;
 
 /* If non-null, this contains the address of a function to call if the
    standard meaning for expanding a tilde fails.  The function is called
    with the text (sans tilde, as in "foo"), and returns a malloc()'ed string
    which is the expansion, or a NULL pointer if there is no expansion. */
-extern CPFunction *tilde_expansion_failure_hook;
+READLINE_API extern tilde_hook_func_t *tilde_expansion_failure_hook;
 
 /* When non-null, this is a NULL terminated array of strings which
    are duplicates for a tilde prefix.  Bash uses this to expand
    `=~' and `:~'. */
-extern char **tilde_additional_prefixes;
+READLINE_API extern char **tilde_additional_prefixes;
 
 /* When non-null, this is a NULL terminated array of strings which match
    the end of a username, instead of just "/".  Bash sets this to
    `:' and `=~'. */
-extern char **tilde_additional_suffixes;
+READLINE_API extern char **tilde_additional_suffixes;
 
 /* Return a new string which is the result of tilde expanding STRING. */
-extern char *tilde_expand __P((char *));
+READLINE_API extern char *tilde_expand __P((const char *));
 
 /* Do the work of tilde expansion on FILENAME.  FILENAME starts with a
    tilde.  If there is no expansion, call tilde_expansion_failure_hook. */
-extern char *tilde_expand_word __P((char *));
+READLINE_API extern char *tilde_expand_word __P((const char *));
 
 #ifdef __cplusplus
 }
Index: readline/undo.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/undo.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 undo.c
--- readline/undo.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/undo.c	2001/02/06 19:14:45
@@ -86,7 +86,7 @@ rl_add_undo (what, start, end, text)
 
 /* Free the existing undo list. */
 void
-free_undo_list ()
+rl_free_undo_list ()
 {
   while (rl_undo_list)
     {
@@ -107,17 +107,18 @@ int
 rl_do_undo ()
 {
   UNDO_LIST *release;
-  int waiting_for_begin = 0;
-  int start, end;
+  int waiting_for_begin, start, end;
 
 #define TRANS(i) ((i) == -1 ? rl_point : ((i) == -2 ? rl_end : (i)))
 
+  start = end = waiting_for_begin = 0;
   do
     {
       if (!rl_undo_list)
 	return (0);
 
       _rl_doing_an_undo = 1;
+      RL_SETSTATE(RL_STATE_UNDOING);
 
       /* To better support vi-mode, a start or end value of -1 means
 	 rl_point, and a value of -2 means rl_end. */
@@ -152,11 +153,12 @@ rl_do_undo ()
 	  if (waiting_for_begin)
 	    waiting_for_begin--;
 	  else
-	    ding ();
+	    rl_ding ();
 	  break;
 	}
 
       _rl_doing_an_undo = 0;
+      RL_UNSETSTATE(RL_STATE_UNDOING);
 
       release = rl_undo_list;
       rl_undo_list = rl_undo_list->next;
@@ -231,7 +233,7 @@ rl_revert_line (count, key)
      int count, key;
 {
   if (!rl_undo_list)
-    ding ();
+    rl_ding ();
   else
     {
       while (rl_undo_list)
@@ -254,7 +256,7 @@ rl_undo_command (count, key)
 	count--;
       else
 	{
-	  ding ();
+	  rl_ding ();
 	  break;
 	}
     }
Index: readline/util.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/util.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 util.c
--- readline/util.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/util.c	2003/02/17 12:47:10
@@ -67,10 +67,10 @@
    in words, or 1 if it is. */
 
 int _rl_allow_pathname_alphabetic_chars = 0;
-static char *pathname_alphabetic_chars = "/-_=~.#$";
+static const char *pathname_alphabetic_chars = "/-_=~.#$";
 
 int
-alphabetic (c)
+rl_alphabetic (c)
      int c;
 {
   if (ALPHABETIC (c))
@@ -84,16 +84,16 @@ alphabetic (c)
 int
 _rl_abort_internal ()
 {
-  ding ();
+  rl_ding ();
   rl_clear_message ();
   _rl_init_argument ();
-  rl_pending_input = 0;
+  rl_clear_pending_input ();
 
   _rl_defining_kbd_macro = 0;
-  while (_rl_executing_macro)
+  while (rl_executing_macro)
     _rl_pop_executing_macro ();
 
-  rl_last_func = (Function *)NULL;
+  rl_last_func = (rl_command_func_t *)NULL;
   longjmp (readline_top_level, 1);
   return (0);
 }
@@ -113,7 +113,7 @@ rl_tty_status (count, key)
   ioctl (1, TIOCSTAT, (char *)0);
   rl_refresh_line (count, key);
 #else
-  ding ();
+  rl_ding ();
 #endif
   return 0;
 }
@@ -215,17 +215,36 @@ rl_tilde_expand (ignore, key)
    match in s1.  The compare is case insensitive. */
 char *
 _rl_strindex (s1, s2)
-     register char *s1, *s2;
+     register const char *s1, *s2;
 {
   register int i, l, len;
 
   for (i = 0, l = strlen (s2), len = strlen (s1); (len - i) >= l; i++)
     if (_rl_strnicmp (s1 + i, s2, l) == 0)
-      return (s1 + i);
+      return ((char *) (s1 + i));
   return ((char *)NULL);
 }
 
-#if !defined (HAVE_STRCASECMP)
+/* Find the first occurrence in STRING1 of any character from STRING2.
+   Return a pointer to the character in STRING1. */
+char *
+_rl_strpbrk (string1, string2)
+     const char *string1, *string2;
+{
+  register const char *scan;
+
+  for (; *string1; string1++)
+    {
+      for (scan = string2; *scan; scan++)
+	{
+	  if (*string1 == *scan)
+	    return ((char *)string1);
+	}
+    }
+  return ((char *)NULL);
+}
+
+#if !defined (HAVE_STRCASECMP) && !defined (__MINGW32__)
 /* Compare at most COUNT characters from string1 to string2.  Case
    doesn't matter. */
 int
@@ -345,7 +364,7 @@ _rl_digit_value (c)
 #undef _rl_savestring
 char *
 _rl_savestring (s)
-     char *s;
+     const char *s;
 {
-  return ((char *)strcpy (xmalloc (1 + (int)strlen (s)), (s)));
+  return (strcpy (xmalloc (1 + (int)strlen (s)), (s)));
 }
Index: readline/vi_keymap.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/vi_keymap.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 vi_keymap.c
--- readline/vi_keymap.c	2003/02/16 21:36:32	1.1.1.1
+++ readline/vi_keymap.c	2000/10/30 16:55:52
@@ -33,429 +33,429 @@ extern KEYMAP_ENTRY_ARRAY vi_escape_keym
 /* The keymap arrays for handling vi mode. */
 KEYMAP_ENTRY_ARRAY vi_movement_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
-  { ISFUNC, rl_emacs_editing_mode },	/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, rl_abort },			/* Control-g */
-  { ISFUNC, rl_backward },		/* Control-h */
-  { ISFUNC, (Function *)0x0 },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, rl_clear_screen },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_get_next_history },	/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, rl_get_previous_history },	/* Control-p */
-  { ISFUNC, rl_quoted_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISFUNC, (Function *)0x0 },		/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-
-  { ISFUNC, (Function *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
+  { ISFUNC, rl_emacs_editing_mode },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, rl_abort },				/* Control-g */
+  { ISFUNC, rl_backward },			/* Control-h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, rl_clear_screen },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_get_next_history },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, rl_get_previous_history },		/* Control-p */
+  { ISFUNC, rl_quoted_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-[ */	/* vi_escape_keymap */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_forward },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, rl_insert_comment },	/* # */
-  { ISFUNC, rl_end_of_line },		/* $ */
-  { ISFUNC, rl_vi_match },		/* % */
-  { ISFUNC, rl_vi_tilde_expand },	/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, (Function *)0x0 },		/* ( */
-  { ISFUNC, (Function *)0x0 },		/* ) */
-  { ISFUNC, rl_vi_complete },		/* * */
-  { ISFUNC, rl_get_next_history},	/* + */
-  { ISFUNC, rl_vi_char_search },	/* , */
-  { ISFUNC, rl_get_previous_history },	/* - */
-  { ISFUNC, rl_vi_redo },		/* . */
-  { ISFUNC, rl_vi_search },		/* / */
+  { ISFUNC, rl_forward },			/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, rl_insert_comment },		/* # */
+  { ISFUNC, rl_end_of_line },			/* $ */
+  { ISFUNC, rl_vi_match },			/* % */
+  { ISFUNC, rl_vi_tilde_expand },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
+  { ISFUNC, rl_vi_complete },			/* * */
+  { ISFUNC, rl_get_next_history},		/* + */
+  { ISFUNC, rl_vi_char_search },		/* , */
+  { ISFUNC, rl_get_previous_history },		/* - */
+  { ISFUNC, rl_vi_redo },			/* . */
+  { ISFUNC, rl_vi_search },			/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_beg_of_line },		/* 0 */
-  { ISFUNC, rl_vi_arg_digit },		/* 1 */
-  { ISFUNC, rl_vi_arg_digit },		/* 2 */
-  { ISFUNC, rl_vi_arg_digit },		/* 3 */
-  { ISFUNC, rl_vi_arg_digit },		/* 4 */
-  { ISFUNC, rl_vi_arg_digit },		/* 5 */
-  { ISFUNC, rl_vi_arg_digit },		/* 6 */
-  { ISFUNC, rl_vi_arg_digit },		/* 7 */
-  { ISFUNC, rl_vi_arg_digit },		/* 8 */
-  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+  { ISFUNC, rl_beg_of_line },			/* 0 */
+  { ISFUNC, rl_vi_arg_digit },			/* 1 */
+  { ISFUNC, rl_vi_arg_digit },			/* 2 */
+  { ISFUNC, rl_vi_arg_digit },			/* 3 */
+  { ISFUNC, rl_vi_arg_digit },			/* 4 */
+  { ISFUNC, rl_vi_arg_digit },			/* 5 */
+  { ISFUNC, rl_vi_arg_digit },			/* 6 */
+  { ISFUNC, rl_vi_arg_digit },			/* 7 */
+  { ISFUNC, rl_vi_arg_digit },			/* 8 */
+  { ISFUNC, rl_vi_arg_digit },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* : */
-  { ISFUNC, rl_vi_char_search },	/* ; */
-  { ISFUNC, (Function *)0x0 },		/* < */
-  { ISFUNC, rl_vi_complete },		/* = */
-  { ISFUNC, (Function *)0x0 },		/* > */
-  { ISFUNC, rl_vi_search },		/* ? */
-  { ISFUNC, (Function *)0x0 },		/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, rl_vi_char_search },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, rl_vi_complete },			/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, rl_vi_search },			/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_vi_append_eol },		/* A */
-  { ISFUNC, rl_vi_prev_word},		/* B */
-  { ISFUNC, rl_vi_change_to },		/* C */
-  { ISFUNC, rl_vi_delete_to },		/* D */
-  { ISFUNC, rl_vi_end_word },		/* E */
-  { ISFUNC, rl_vi_char_search },	/* F */
-  { ISFUNC, rl_vi_fetch_history },	/* G */
-  { ISFUNC, (Function *)0x0 },		/* H */
-  { ISFUNC, rl_vi_insert_beg },		/* I */
-  { ISFUNC, (Function *)0x0 },		/* J */
-  { ISFUNC, (Function *)0x0 },		/* K */
-  { ISFUNC, (Function *)0x0 },		/* L */
-  { ISFUNC, (Function *)0x0 },		/* M */
-  { ISFUNC, rl_vi_search_again },	/* N */
-  { ISFUNC, (Function *)0x0 },		/* O */
-  { ISFUNC, rl_vi_put },		/* P */
-  { ISFUNC, (Function *)0x0 },		/* Q */
-  { ISFUNC, rl_vi_replace },		/* R */
-  { ISFUNC, rl_vi_subst },		/* S */
-  { ISFUNC, rl_vi_char_search },	/* T */
-  { ISFUNC, rl_revert_line },		/* U */
-  { ISFUNC, (Function *)0x0 },		/* V */
-  { ISFUNC, rl_vi_next_word },		/* W */
-  { ISFUNC, rl_rubout },		/* X */
-  { ISFUNC, rl_vi_yank_to },		/* Y */
-  { ISFUNC, (Function *)0x0 },		/* Z */
+  { ISFUNC, rl_vi_append_eol },			/* A */
+  { ISFUNC, rl_vi_prev_word},			/* B */
+  { ISFUNC, rl_vi_change_to },			/* C */
+  { ISFUNC, rl_vi_delete_to },			/* D */
+  { ISFUNC, rl_vi_end_word },			/* E */
+  { ISFUNC, rl_vi_char_search },		/* F */
+  { ISFUNC, rl_vi_fetch_history },		/* G */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* H */
+  { ISFUNC, rl_vi_insert_beg },			/* I */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* J */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* K */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* L */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* M */
+  { ISFUNC, rl_vi_search_again },		/* N */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* O */
+  { ISFUNC, rl_vi_put },			/* P */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Q */
+  { ISFUNC, rl_vi_replace },			/* R */
+  { ISFUNC, rl_vi_subst },			/* S */
+  { ISFUNC, rl_vi_char_search },		/* T */
+  { ISFUNC, rl_revert_line },			/* U */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* V */
+  { ISFUNC, rl_vi_next_word },			/* W */
+  { ISFUNC, rl_rubout },			/* X */
+  { ISFUNC, rl_vi_yank_to },			/* Y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* [ */
-  { ISFUNC, rl_vi_complete },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, rl_vi_first_print },	/* ^ */
-  { ISFUNC, rl_vi_yank_arg },		/* _ */
-  { ISFUNC, rl_vi_goto_mark },		/* ` */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* [ */
+  { ISFUNC, rl_vi_complete },			/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, rl_vi_first_print },		/* ^ */
+  { ISFUNC, rl_vi_yank_arg },			/* _ */
+  { ISFUNC, rl_vi_goto_mark },			/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_vi_append_mode },	/* a */
-  { ISFUNC, rl_vi_prev_word },		/* b */
-  { ISFUNC, rl_vi_change_to },		/* c */
-  { ISFUNC, rl_vi_delete_to },		/* d */
-  { ISFUNC, rl_vi_end_word },		/* e */
-  { ISFUNC, rl_vi_char_search },	/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, rl_backward },		/* h */
-  { ISFUNC, rl_vi_insertion_mode },	/* i */
-  { ISFUNC, rl_get_next_history },	/* j */
-  { ISFUNC, rl_get_previous_history },	/* k */
-  { ISFUNC, rl_forward },		/* l */
-  { ISFUNC, rl_vi_set_mark },		/* m */
-  { ISFUNC, rl_vi_search_again },	/* n */
-  { ISFUNC, (Function *)0x0 },		/* o */
-  { ISFUNC, rl_vi_put },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, rl_vi_change_char },	/* r */
-  { ISFUNC, rl_vi_subst },		/* s */
-  { ISFUNC, rl_vi_char_search },	/* t */
-  { ISFUNC, rl_vi_undo },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, rl_vi_next_word },		/* w */
-  { ISFUNC, rl_vi_delete },		/* x */
-  { ISFUNC, rl_vi_yank_to },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, rl_vi_append_mode },		/* a */
+  { ISFUNC, rl_vi_prev_word },			/* b */
+  { ISFUNC, rl_vi_change_to },			/* c */
+  { ISFUNC, rl_vi_delete_to },			/* d */
+  { ISFUNC, rl_vi_end_word },			/* e */
+  { ISFUNC, rl_vi_char_search },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, rl_backward },			/* h */
+  { ISFUNC, rl_vi_insertion_mode },		/* i */
+  { ISFUNC, rl_get_next_history },		/* j */
+  { ISFUNC, rl_get_previous_history },		/* k */
+  { ISFUNC, rl_forward },			/* l */
+  { ISFUNC, rl_vi_set_mark },			/* m */
+  { ISFUNC, rl_vi_search_again },		/* n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* o */
+  { ISFUNC, rl_vi_put },			/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, rl_vi_change_char },		/* r */
+  { ISFUNC, rl_vi_subst },			/* s */
+  { ISFUNC, rl_vi_char_search },		/* t */
+  { ISFUNC, rl_vi_undo },			/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, rl_vi_next_word },			/* w */
+  { ISFUNC, rl_vi_delete },			/* x */
+  { ISFUNC, rl_vi_yank_to },			/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, rl_vi_column },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, rl_vi_change_case },	/* ~ */
-  { ISFUNC, (Function *)0x0 },		/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, rl_vi_column },			/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, rl_vi_change_case },		/* ~ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 
 
 KEYMAP_ENTRY_ARRAY vi_insertion_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, rl_insert },		/* Control-a */
-  { ISFUNC, rl_insert },		/* Control-b */
-  { ISFUNC, rl_insert },		/* Control-c */
-  { ISFUNC, rl_vi_eof_maybe },		/* Control-d */
-  { ISFUNC, rl_insert },		/* Control-e */
-  { ISFUNC, rl_insert },		/* Control-f */
-  { ISFUNC, rl_insert },		/* Control-g */
-  { ISFUNC, rl_rubout },		/* Control-h */
-  { ISFUNC, rl_complete },		/* Control-i */
-  { ISFUNC, rl_newline },		/* Control-j */
-  { ISFUNC, rl_insert },		/* Control-k */
-  { ISFUNC, rl_insert },		/* Control-l */
-  { ISFUNC, rl_newline },		/* Control-m */
-  { ISFUNC, rl_insert },		/* Control-n */
-  { ISFUNC, rl_insert },		/* Control-o */
-  { ISFUNC, rl_insert },		/* Control-p */
-  { ISFUNC, rl_insert },		/* Control-q */
-  { ISFUNC, rl_reverse_search_history }, /* Control-r */
-  { ISFUNC, rl_forward_search_history }, /* Control-s */
-  { ISFUNC, rl_transpose_chars },	/* Control-t */
-  { ISFUNC, rl_unix_line_discard },	/* Control-u */
-  { ISFUNC, rl_quoted_insert },		/* Control-v */
-  { ISFUNC, rl_unix_word_rubout },	/* Control-w */
-  { ISFUNC, rl_insert },		/* Control-x */
-  { ISFUNC, rl_yank },			/* Control-y */
-  { ISFUNC, rl_insert },		/* Control-z */
-
-  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
-  { ISFUNC, rl_insert },		/* Control-\ */
-  { ISFUNC, rl_insert },		/* Control-] */
-  { ISFUNC, rl_insert },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, rl_insert },			/* Control-a */
+  { ISFUNC, rl_insert },			/* Control-b */
+  { ISFUNC, rl_insert },			/* Control-c */
+  { ISFUNC, rl_vi_eof_maybe },			/* Control-d */
+  { ISFUNC, rl_insert },			/* Control-e */
+  { ISFUNC, rl_insert },			/* Control-f */
+  { ISFUNC, rl_insert },			/* Control-g */
+  { ISFUNC, rl_rubout },			/* Control-h */
+  { ISFUNC, rl_complete },			/* Control-i */
+  { ISFUNC, rl_newline },			/* Control-j */
+  { ISFUNC, rl_insert },			/* Control-k */
+  { ISFUNC, rl_insert },			/* Control-l */
+  { ISFUNC, rl_newline },			/* Control-m */
+  { ISFUNC, rl_insert },			/* Control-n */
+  { ISFUNC, rl_insert },			/* Control-o */
+  { ISFUNC, rl_insert },			/* Control-p */
+  { ISFUNC, rl_insert },			/* Control-q */
+  { ISFUNC, rl_reverse_search_history },	/* Control-r */
+  { ISFUNC, rl_forward_search_history },	/* Control-s */
+  { ISFUNC, rl_transpose_chars },		/* Control-t */
+  { ISFUNC, rl_unix_line_discard },		/* Control-u */
+  { ISFUNC, rl_quoted_insert },			/* Control-v */
+  { ISFUNC, rl_unix_word_rubout },		/* Control-w */
+  { ISFUNC, rl_insert },			/* Control-x */
+  { ISFUNC, rl_yank },				/* Control-y */
+  { ISFUNC, rl_insert },			/* Control-z */
+
+  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
+  { ISFUNC, rl_insert },			/* Control-\ */
+  { ISFUNC, rl_insert },			/* Control-] */
+  { ISFUNC, rl_insert },			/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, rl_insert },		/* SPACE */
-  { ISFUNC, rl_insert },		/* ! */
-  { ISFUNC, rl_insert },		/* " */
-  { ISFUNC, rl_insert },		/* # */
-  { ISFUNC, rl_insert },		/* $ */
-  { ISFUNC, rl_insert },		/* % */
-  { ISFUNC, rl_insert },		/* & */
-  { ISFUNC, rl_insert },		/* ' */
-  { ISFUNC, rl_insert },		/* ( */
-  { ISFUNC, rl_insert },		/* ) */
-  { ISFUNC, rl_insert },		/* * */
-  { ISFUNC, rl_insert },		/* + */
-  { ISFUNC, rl_insert },		/* , */
-  { ISFUNC, rl_insert },		/* - */
-  { ISFUNC, rl_insert },		/* . */
-  { ISFUNC, rl_insert },		/* / */
+  { ISFUNC, rl_insert },			/* SPACE */
+  { ISFUNC, rl_insert },			/* ! */
+  { ISFUNC, rl_insert },			/* " */
+  { ISFUNC, rl_insert },			/* # */
+  { ISFUNC, rl_insert },			/* $ */
+  { ISFUNC, rl_insert },			/* % */
+  { ISFUNC, rl_insert },			/* & */
+  { ISFUNC, rl_insert },			/* ' */
+  { ISFUNC, rl_insert },			/* ( */
+  { ISFUNC, rl_insert },			/* ) */
+  { ISFUNC, rl_insert },			/* * */
+  { ISFUNC, rl_insert },			/* + */
+  { ISFUNC, rl_insert },			/* , */
+  { ISFUNC, rl_insert },			/* - */
+  { ISFUNC, rl_insert },			/* . */
+  { ISFUNC, rl_insert },			/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_insert },		/* 0 */
-  { ISFUNC, rl_insert },		/* 1 */
-  { ISFUNC, rl_insert },		/* 2 */
-  { ISFUNC, rl_insert },		/* 3 */
-  { ISFUNC, rl_insert },		/* 4 */
-  { ISFUNC, rl_insert },		/* 5 */
-  { ISFUNC, rl_insert },		/* 6 */
-  { ISFUNC, rl_insert },		/* 7 */
-  { ISFUNC, rl_insert },		/* 8 */
-  { ISFUNC, rl_insert },		/* 9 */
+  { ISFUNC, rl_insert },			/* 0 */
+  { ISFUNC, rl_insert },			/* 1 */
+  { ISFUNC, rl_insert },			/* 2 */
+  { ISFUNC, rl_insert },			/* 3 */
+  { ISFUNC, rl_insert },			/* 4 */
+  { ISFUNC, rl_insert },			/* 5 */
+  { ISFUNC, rl_insert },			/* 6 */
+  { ISFUNC, rl_insert },			/* 7 */
+  { ISFUNC, rl_insert },			/* 8 */
+  { ISFUNC, rl_insert },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, rl_insert },		/* : */
-  { ISFUNC, rl_insert },		/* ; */
-  { ISFUNC, rl_insert },		/* < */
-  { ISFUNC, rl_insert },		/* = */
-  { ISFUNC, rl_insert },		/* > */
-  { ISFUNC, rl_insert },		/* ? */
-  { ISFUNC, rl_insert },		/* @ */
+  { ISFUNC, rl_insert },			/* : */
+  { ISFUNC, rl_insert },			/* ; */
+  { ISFUNC, rl_insert },			/* < */
+  { ISFUNC, rl_insert },			/* = */
+  { ISFUNC, rl_insert },			/* > */
+  { ISFUNC, rl_insert },			/* ? */
+  { ISFUNC, rl_insert },			/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_insert },		/* A */
-  { ISFUNC, rl_insert },		/* B */
-  { ISFUNC, rl_insert },		/* C */
-  { ISFUNC, rl_insert },		/* D */
-  { ISFUNC, rl_insert },		/* E */
-  { ISFUNC, rl_insert },		/* F */
-  { ISFUNC, rl_insert },		/* G */
-  { ISFUNC, rl_insert },		/* H */
-  { ISFUNC, rl_insert },		/* I */
-  { ISFUNC, rl_insert },		/* J */
-  { ISFUNC, rl_insert },		/* K */
-  { ISFUNC, rl_insert },		/* L */
-  { ISFUNC, rl_insert },		/* M */
-  { ISFUNC, rl_insert },		/* N */
-  { ISFUNC, rl_insert },		/* O */
-  { ISFUNC, rl_insert },		/* P */
-  { ISFUNC, rl_insert },		/* Q */
-  { ISFUNC, rl_insert },		/* R */
-  { ISFUNC, rl_insert },		/* S */
-  { ISFUNC, rl_insert },		/* T */
-  { ISFUNC, rl_insert },		/* U */
-  { ISFUNC, rl_insert },		/* V */
-  { ISFUNC, rl_insert },		/* W */
-  { ISFUNC, rl_insert },		/* X */
-  { ISFUNC, rl_insert },		/* Y */
-  { ISFUNC, rl_insert },		/* Z */
+  { ISFUNC, rl_insert },			/* A */
+  { ISFUNC, rl_insert },			/* B */
+  { ISFUNC, rl_insert },			/* C */
+  { ISFUNC, rl_insert },			/* D */
+  { ISFUNC, rl_insert },			/* E */
+  { ISFUNC, rl_insert },			/* F */
+  { ISFUNC, rl_insert },			/* G */
+  { ISFUNC, rl_insert },			/* H */
+  { ISFUNC, rl_insert },			/* I */
+  { ISFUNC, rl_insert },			/* J */
+  { ISFUNC, rl_insert },			/* K */
+  { ISFUNC, rl_insert },			/* L */
+  { ISFUNC, rl_insert },			/* M */
+  { ISFUNC, rl_insert },			/* N */
+  { ISFUNC, rl_insert },			/* O */
+  { ISFUNC, rl_insert },			/* P */
+  { ISFUNC, rl_insert },			/* Q */
+  { ISFUNC, rl_insert },			/* R */
+  { ISFUNC, rl_insert },			/* S */
+  { ISFUNC, rl_insert },			/* T */
+  { ISFUNC, rl_insert },			/* U */
+  { ISFUNC, rl_insert },			/* V */
+  { ISFUNC, rl_insert },			/* W */
+  { ISFUNC, rl_insert },			/* X */
+  { ISFUNC, rl_insert },			/* Y */
+  { ISFUNC, rl_insert },			/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_insert },		/* [ */
-  { ISFUNC, rl_insert },		/* \ */
-  { ISFUNC, rl_insert },		/* ] */
-  { ISFUNC, rl_insert },		/* ^ */
-  { ISFUNC, rl_insert },		/* _ */
-  { ISFUNC, rl_insert },		/* ` */
+  { ISFUNC, rl_insert },			/* [ */
+  { ISFUNC, rl_insert },			/* \ */
+  { ISFUNC, rl_insert },			/* ] */
+  { ISFUNC, rl_insert },			/* ^ */
+  { ISFUNC, rl_insert },			/* _ */
+  { ISFUNC, rl_insert },			/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, rl_insert },		/* a */
-  { ISFUNC, rl_insert },		/* b */
-  { ISFUNC, rl_insert },		/* c */
-  { ISFUNC, rl_insert },		/* d */
-  { ISFUNC, rl_insert },		/* e */
-  { ISFUNC, rl_insert },		/* f */
-  { ISFUNC, rl_insert },		/* g */
-  { ISFUNC, rl_insert },		/* h */
-  { ISFUNC, rl_insert },		/* i */
-  { ISFUNC, rl_insert },		/* j */
-  { ISFUNC, rl_insert },		/* k */
-  { ISFUNC, rl_insert },		/* l */
-  { ISFUNC, rl_insert },		/* m */
-  { ISFUNC, rl_insert },		/* n */
-  { ISFUNC, rl_insert },		/* o */
-  { ISFUNC, rl_insert },		/* p */
-  { ISFUNC, rl_insert },		/* q */
-  { ISFUNC, rl_insert },		/* r */
-  { ISFUNC, rl_insert },		/* s */
-  { ISFUNC, rl_insert },		/* t */
-  { ISFUNC, rl_insert },		/* u */
-  { ISFUNC, rl_insert },		/* v */
-  { ISFUNC, rl_insert },		/* w */
-  { ISFUNC, rl_insert },		/* x */
-  { ISFUNC, rl_insert },		/* y */
-  { ISFUNC, rl_insert },		/* z */
+  { ISFUNC, rl_insert },			/* a */
+  { ISFUNC, rl_insert },			/* b */
+  { ISFUNC, rl_insert },			/* c */
+  { ISFUNC, rl_insert },			/* d */
+  { ISFUNC, rl_insert },			/* e */
+  { ISFUNC, rl_insert },			/* f */
+  { ISFUNC, rl_insert },			/* g */
+  { ISFUNC, rl_insert },			/* h */
+  { ISFUNC, rl_insert },			/* i */
+  { ISFUNC, rl_insert },			/* j */
+  { ISFUNC, rl_insert },			/* k */
+  { ISFUNC, rl_insert },			/* l */
+  { ISFUNC, rl_insert },			/* m */
+  { ISFUNC, rl_insert },			/* n */
+  { ISFUNC, rl_insert },			/* o */
+  { ISFUNC, rl_insert },			/* p */
+  { ISFUNC, rl_insert },			/* q */
+  { ISFUNC, rl_insert },			/* r */
+  { ISFUNC, rl_insert },			/* s */
+  { ISFUNC, rl_insert },			/* t */
+  { ISFUNC, rl_insert },			/* u */
+  { ISFUNC, rl_insert },			/* v */
+  { ISFUNC, rl_insert },			/* w */
+  { ISFUNC, rl_insert },			/* x */
+  { ISFUNC, rl_insert },			/* y */
+  { ISFUNC, rl_insert },			/* z */
 
   /* Final punctuation. */
-  { ISFUNC, rl_insert },		/* { */
-  { ISFUNC, rl_insert },		/* | */
-  { ISFUNC, rl_insert },		/* } */
-  { ISFUNC, rl_insert },		/* ~ */
-  { ISFUNC, rl_rubout },		/* RUBOUT */
+  { ISFUNC, rl_insert },			/* { */
+  { ISFUNC, rl_insert },			/* | */
+  { ISFUNC, rl_insert },			/* } */
+  { ISFUNC, rl_insert },			/* ~ */
+  { ISFUNC, rl_rubout },			/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Pure 8-bit characters (128 - 159).
@@ -598,280 +598,280 @@ KEYMAP_ENTRY_ARRAY vi_insertion_keymap =
 #if 0
 KEYMAP_ENTRY_ARRAY vi_escape_keymap = {
   /* The regular control keys come first. */
-  { ISFUNC, (Function *)0x0 },		/* Control-@ */
-  { ISFUNC, (Function *)0x0 },		/* Control-a */
-  { ISFUNC, (Function *)0x0 },		/* Control-b */
-  { ISFUNC, (Function *)0x0 },		/* Control-c */
-  { ISFUNC, (Function *)0x0 },		/* Control-d */
-  { ISFUNC, (Function *)0x0 },		/* Control-e */
-  { ISFUNC, (Function *)0x0 },		/* Control-f */
-  { ISFUNC, (Function *)0x0 },		/* Control-g */
-  { ISFUNC, (Function *)0x0 },		/* Control-h */
-  { ISFUNC, rl_tab_insert},		/* Control-i */
-  { ISFUNC, rl_emacs_editing_mode},	/* Control-j */
-  { ISFUNC, rl_kill_line },		/* Control-k */
-  { ISFUNC, (Function *)0x0 },		/* Control-l */
-  { ISFUNC, rl_emacs_editing_mode},	/* Control-m */
-  { ISFUNC, (Function *)0x0 },		/* Control-n */
-  { ISFUNC, (Function *)0x0 },		/* Control-o */
-  { ISFUNC, (Function *)0x0 },		/* Control-p */
-  { ISFUNC, (Function *)0x0 },		/* Control-q */
-  { ISFUNC, (Function *)0x0 },		/* Control-r */
-  { ISFUNC, (Function *)0x0 },		/* Control-s */
-  { ISFUNC, (Function *)0x0 },		/* Control-t */
-  { ISFUNC, (Function *)0x0 },		/* Control-u */
-  { ISFUNC, (Function *)0x0 },		/* Control-v */
-  { ISFUNC, (Function *)0x0 },		/* Control-w */
-  { ISFUNC, (Function *)0x0 },		/* Control-x */
-  { ISFUNC, (Function *)0x0 },		/* Control-y */
-  { ISFUNC, (Function *)0x0 },		/* Control-z */
-
-  { ISFUNC, rl_vi_movement_mode },	/* Control-[ */
-  { ISFUNC, (Function *)0x0 },		/* Control-\ */
-  { ISFUNC, (Function *)0x0 },		/* Control-] */
-  { ISFUNC, (Function *)0x0 },		/* Control-^ */
-  { ISFUNC, rl_vi_undo },		/* Control-_ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-@ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-h */
+  { ISFUNC, rl_tab_insert},			/* Control-i */
+  { ISFUNC, rl_emacs_editing_mode},		/* Control-j */
+  { ISFUNC, rl_kill_line },			/* Control-k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-l */
+  { ISFUNC, rl_emacs_editing_mode},		/* Control-m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-n */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-z */
+
+  { ISFUNC, rl_vi_movement_mode },		/* Control-[ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-\ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* Control-^ */
+  { ISFUNC, rl_vi_undo },			/* Control-_ */
 
   /* The start of printing characters. */
-  { ISFUNC, (Function *)0x0 },		/* SPACE */
-  { ISFUNC, (Function *)0x0 },		/* ! */
-  { ISFUNC, (Function *)0x0 },		/* " */
-  { ISFUNC, (Function *)0x0 },		/* # */
-  { ISFUNC, (Function *)0x0 },		/* $ */
-  { ISFUNC, (Function *)0x0 },		/* % */
-  { ISFUNC, (Function *)0x0 },		/* & */
-  { ISFUNC, (Function *)0x0 },		/* ' */
-  { ISFUNC, (Function *)0x0 },		/* ( */
-  { ISFUNC, (Function *)0x0 },		/* ) */
-  { ISFUNC, (Function *)0x0 },		/* * */
-  { ISFUNC, (Function *)0x0 },		/* + */
-  { ISFUNC, (Function *)0x0 },		/* , */
-  { ISFUNC, (Function *)0x0 },		/* - */
-  { ISFUNC, (Function *)0x0 },		/* . */
-  { ISFUNC, (Function *)0x0 },		/* / */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* SPACE */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ! */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* " */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* # */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* $ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* % */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* & */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ' */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ( */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ) */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* * */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* + */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* , */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* - */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* . */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* / */
 
   /* Regular digits. */
-  { ISFUNC, rl_vi_arg_digit },		/* 0 */
-  { ISFUNC, rl_vi_arg_digit },		/* 1 */
-  { ISFUNC, rl_vi_arg_digit },		/* 2 */
-  { ISFUNC, rl_vi_arg_digit },		/* 3 */
-  { ISFUNC, rl_vi_arg_digit },		/* 4 */
-  { ISFUNC, rl_vi_arg_digit },		/* 5 */
-  { ISFUNC, rl_vi_arg_digit },		/* 6 */
-  { ISFUNC, rl_vi_arg_digit },		/* 7 */
-  { ISFUNC, rl_vi_arg_digit },		/* 8 */
-  { ISFUNC, rl_vi_arg_digit },		/* 9 */
+  { ISFUNC, rl_vi_arg_digit },			/* 0 */
+  { ISFUNC, rl_vi_arg_digit },			/* 1 */
+  { ISFUNC, rl_vi_arg_digit },			/* 2 */
+  { ISFUNC, rl_vi_arg_digit },			/* 3 */
+  { ISFUNC, rl_vi_arg_digit },			/* 4 */
+  { ISFUNC, rl_vi_arg_digit },			/* 5 */
+  { ISFUNC, rl_vi_arg_digit },			/* 6 */
+  { ISFUNC, rl_vi_arg_digit },			/* 7 */
+  { ISFUNC, rl_vi_arg_digit },			/* 8 */
+  { ISFUNC, rl_vi_arg_digit },			/* 9 */
 
   /* A little more punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* : */
-  { ISFUNC, (Function *)0x0 },		/* ; */
-  { ISFUNC, (Function *)0x0 },		/* < */
-  { ISFUNC, (Function *)0x0 },		/* = */
-  { ISFUNC, (Function *)0x0 },		/* > */
-  { ISFUNC, (Function *)0x0 },		/* ? */
-  { ISFUNC, (Function *)0x0 },		/* @ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* : */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ; */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* < */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* = */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* > */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ? */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* @ */
 
   /* Uppercase alphabet. */
-  { ISFUNC, rl_do_lowercase_version },	/* A */
-  { ISFUNC, rl_do_lowercase_version },	/* B */
-  { ISFUNC, rl_do_lowercase_version },	/* C */
-  { ISFUNC, rl_do_lowercase_version },	/* D */
-  { ISFUNC, rl_do_lowercase_version },	/* E */
-  { ISFUNC, rl_do_lowercase_version },	/* F */
-  { ISFUNC, rl_do_lowercase_version },	/* G */
-  { ISFUNC, rl_do_lowercase_version },	/* H */
-  { ISFUNC, rl_do_lowercase_version },	/* I */
-  { ISFUNC, rl_do_lowercase_version },	/* J */
-  { ISFUNC, rl_do_lowercase_version },	/* K */
-  { ISFUNC, rl_do_lowercase_version },	/* L */
-  { ISFUNC, rl_do_lowercase_version },	/* M */
-  { ISFUNC, rl_do_lowercase_version },	/* N */
-  { ISFUNC, rl_do_lowercase_version },	/* O */
-  { ISFUNC, rl_do_lowercase_version },	/* P */
-  { ISFUNC, rl_do_lowercase_version },	/* Q */
-  { ISFUNC, rl_do_lowercase_version },	/* R */
-  { ISFUNC, rl_do_lowercase_version },	/* S */
-  { ISFUNC, rl_do_lowercase_version },	/* T */
-  { ISFUNC, rl_do_lowercase_version },	/* U */
-  { ISFUNC, rl_do_lowercase_version },	/* V */
-  { ISFUNC, rl_do_lowercase_version },	/* W */
-  { ISFUNC, rl_do_lowercase_version },	/* X */
-  { ISFUNC, rl_do_lowercase_version },	/* Y */
-  { ISFUNC, rl_do_lowercase_version },	/* Z */
+  { ISFUNC, rl_do_lowercase_version },		/* A */
+  { ISFUNC, rl_do_lowercase_version },		/* B */
+  { ISFUNC, rl_do_lowercase_version },		/* C */
+  { ISFUNC, rl_do_lowercase_version },		/* D */
+  { ISFUNC, rl_do_lowercase_version },		/* E */
+  { ISFUNC, rl_do_lowercase_version },		/* F */
+  { ISFUNC, rl_do_lowercase_version },		/* G */
+  { ISFUNC, rl_do_lowercase_version },		/* H */
+  { ISFUNC, rl_do_lowercase_version },		/* I */
+  { ISFUNC, rl_do_lowercase_version },		/* J */
+  { ISFUNC, rl_do_lowercase_version },		/* K */
+  { ISFUNC, rl_do_lowercase_version },		/* L */
+  { ISFUNC, rl_do_lowercase_version },		/* M */
+  { ISFUNC, rl_do_lowercase_version },		/* N */
+  { ISFUNC, rl_do_lowercase_version },		/* O */
+  { ISFUNC, rl_do_lowercase_version },		/* P */
+  { ISFUNC, rl_do_lowercase_version },		/* Q */
+  { ISFUNC, rl_do_lowercase_version },		/* R */
+  { ISFUNC, rl_do_lowercase_version },		/* S */
+  { ISFUNC, rl_do_lowercase_version },		/* T */
+  { ISFUNC, rl_do_lowercase_version },		/* U */
+  { ISFUNC, rl_do_lowercase_version },		/* V */
+  { ISFUNC, rl_do_lowercase_version },		/* W */
+  { ISFUNC, rl_do_lowercase_version },		/* X */
+  { ISFUNC, rl_do_lowercase_version },		/* Y */
+  { ISFUNC, rl_do_lowercase_version },		/* Z */
 
   /* Some more punctuation. */
-  { ISFUNC, rl_arrow_keys },		/* [ */
-  { ISFUNC, (Function *)0x0 },		/* \ */
-  { ISFUNC, (Function *)0x0 },		/* ] */
-  { ISFUNC, (Function *)0x0 },		/* ^ */
-  { ISFUNC, (Function *)0x0 },		/* _ */
-  { ISFUNC, (Function *)0x0 },		/* ` */
+  { ISFUNC, rl_arrow_keys },			/* [ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* \ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ] */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ^ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* _ */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ` */
 
   /* Lowercase alphabet. */
-  { ISFUNC, (Function *)0x0 },		/* a */
-  { ISFUNC, (Function *)0x0 },		/* b */
-  { ISFUNC, (Function *)0x0 },		/* c */
-  { ISFUNC, (Function *)0x0 },		/* d */
-  { ISFUNC, (Function *)0x0 },		/* e */
-  { ISFUNC, (Function *)0x0 },		/* f */
-  { ISFUNC, (Function *)0x0 },		/* g */
-  { ISFUNC, (Function *)0x0 },		/* h */
-  { ISFUNC, (Function *)0x0 },		/* i */
-  { ISFUNC, (Function *)0x0 },		/* j */
-  { ISFUNC, (Function *)0x0 },		/* k */
-  { ISFUNC, (Function *)0x0 },		/* l */
-  { ISFUNC, (Function *)0x0 },		/* m */
-  { ISFUNC, (Function *)0x0 },		/* n */
-  { ISFUNC, rl_arrow_keys },		/* o */
-  { ISFUNC, (Function *)0x0 },		/* p */
-  { ISFUNC, (Function *)0x0 },		/* q */
-  { ISFUNC, (Function *)0x0 },		/* r */
-  { ISFUNC, (Function *)0x0 },		/* s */
-  { ISFUNC, (Function *)0x0 },		/* t */
-  { ISFUNC, (Function *)0x0 },		/* u */
-  { ISFUNC, (Function *)0x0 },		/* v */
-  { ISFUNC, (Function *)0x0 },		/* w */
-  { ISFUNC, (Function *)0x0 },		/* x */
-  { ISFUNC, (Function *)0x0 },		/* y */
-  { ISFUNC, (Function *)0x0 },		/* z */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* a */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* b */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* c */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* d */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* e */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* f */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* g */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* h */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* i */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* j */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* k */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* l */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* m */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* n */
+  { ISFUNC, rl_arrow_keys },			/* o */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* p */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* q */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* r */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* s */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* t */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* u */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* v */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* w */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* x */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* y */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* z */
 
   /* Final punctuation. */
-  { ISFUNC, (Function *)0x0 },		/* { */
-  { ISFUNC, (Function *)0x0 },		/* | */
-  { ISFUNC, (Function *)0x0 },		/* } */
-  { ISFUNC, (Function *)0x0 },		/* ~ */
-  { ISFUNC, rl_backward_kill_word },	/* RUBOUT */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* { */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* | */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* } */
+  { ISFUNC, (rl_command_func_t *)0x0 },		/* ~ */
+  { ISFUNC, rl_backward_kill_word },		/* RUBOUT */
 
 #if KEYMAP_SIZE > 128
   /* Undefined keys. */
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 },
-  { ISFUNC, (Function *)0x0 }
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 },
+  { ISFUNC, (rl_command_func_t *)0x0 }
 #endif /* KEYMAP_SIZE > 128 */
 };
 #endif
Index: readline/vi_mode.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/vi_mode.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 vi_mode.c
--- readline/vi_mode.c	2003/02/16 21:36:33	1.1.1.1
+++ readline/vi_mode.c	2000/11/08 16:47:02
@@ -81,7 +81,7 @@
 static int _rl_vi_doing_insert;
 
 /* Command keys which do movement for xxx_to commands. */
-static char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
+static const char *vi_motion = " hl^$0ftFt;,%wbeWBE|";
 
 /* Keymap used for vi replace characters.  Created dynamically since
    rarely used. */
@@ -109,7 +109,7 @@ static int _rl_vi_last_key_before_insert
 static int vi_redoing;
 
 /* Text modification commands.  These are the `redoable' commands. */
-static char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
+static const char *vi_textmod = "_*\\AaIiCcDdPpYyRrSsXx~";
 
 /* Arrays for the saved marks. */
 static int vi_mark_chars[27];
@@ -274,7 +274,7 @@ rl_vi_search (count, key)
       break;
 
     default:
-      ding ();
+      rl_ding ();
       break;
     }
   return (0);
@@ -330,7 +330,7 @@ rl_vi_prev_word (count, key)
 
   if (rl_point == 0)
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
@@ -352,7 +352,7 @@ rl_vi_next_word (count, key)
 
   if (rl_point >= (rl_end - 1))
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
@@ -370,7 +370,7 @@ rl_vi_end_word (count, key)
 {
   if (count < 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -744,7 +744,9 @@ rl_vi_domove (key, nextkey)
   int old_end;
 
   rl_mark = rl_point;
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   c = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
   *nextkey = c;
 
   if (!member (c, vi_motion))
@@ -755,7 +757,9 @@ rl_vi_domove (key, nextkey)
 	  rl_numeric_arg = _rl_digit_value (c);
 	  rl_digit_loop1 ();
 	  rl_numeric_arg *= save;
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
 	  c = rl_read_key ();	/* real command */
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
 	  *nextkey = c;
 	}
       else if (key == c && (key == 'd' || key == 'y' || key == 'c'))
@@ -825,16 +829,28 @@ rl_vi_domove (key, nextkey)
 }
 
 /* A simplified loop for vi. Don't dispatch key at end.
-   Don't recognize minus sign? */
+   Don't recognize minus sign?
+   Should this do rl_save_prompt/rl_restore_prompt? */
 static int
 rl_digit_loop1 ()
 {
   int key, c;
 
+  RL_SETSTATE(RL_STATE_NUMERICARG);
   while (1)
     {
+      if (rl_numeric_arg > 1000000)
+	{
+	  rl_explicit_arg = rl_numeric_arg = 0;
+	  rl_ding ();
+	  rl_clear_message ();
+	  RL_UNSETSTATE(RL_STATE_NUMERICARG);
+	  return 1;
+	}
       rl_message ("(arg: %d) ", rl_arg_sign * rl_numeric_arg, 0);
+      RL_SETSTATE(RL_STATE_MOREINPUT);
       key = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
 
       if (_rl_keymap[c].type == ISFUNC &&
 	  _rl_keymap[c].function == rl_universal_argument)
@@ -859,6 +875,8 @@ rl_digit_loop1 ()
 	  break;
 	}
     }
+
+  RL_UNSETSTATE(RL_STATE_NUMERICARG);
   return (0);
 }
 
@@ -875,7 +893,7 @@ rl_vi_delete_to (count, key)
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -903,7 +921,7 @@ rl_vi_change_to (count, key)
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -953,7 +971,7 @@ rl_vi_yank_to (count, key)
 
   if (rl_vi_domove (key, &c))
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -979,7 +997,7 @@ rl_vi_delete (count, key)
 
   if (rl_end == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
@@ -1026,7 +1044,11 @@ rl_vi_char_search (count, key)
       if (vi_redoing)
 	target = _rl_vi_last_search_char;
       else
-	_rl_vi_last_search_char = target = (*rl_getc_function) (rl_instream);
+	{
+	  RL_SETSTATE(RL_STATE_MOREINPUT);
+	  _rl_vi_last_search_char = target = rl_read_key ();
+	  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+	}
 
       switch (key)
         {
@@ -1068,7 +1090,7 @@ rl_vi_match (ignore, key)
       if (brack <= 0)
 	{
 	  rl_point = pos;
-	  ding ();
+	  rl_ding ();
 	  return -1;
 	}
     }
@@ -1089,7 +1111,7 @@ rl_vi_match (ignore, key)
 	    }
 	  else
 	    {
-	      ding ();
+	      rl_ding ();
 	      return -1;
 	    }
 	}
@@ -1108,7 +1130,7 @@ rl_vi_match (ignore, key)
 	    }
 	  else
 	    {
-	      ding ();
+	      rl_ding ();
 	      return -1;
 	    }
 	}
@@ -1142,7 +1164,11 @@ rl_vi_change_char (count, key)
   if (vi_redoing)
     c = _rl_vi_last_replacement;
   else
-    _rl_vi_last_replacement = c = (*rl_getc_function) (rl_instream);
+    {
+      RL_SETSTATE(RL_STATE_MOREINPUT);
+      _rl_vi_last_replacement = c = rl_read_key ();
+      RL_UNSETSTATE(RL_STATE_MOREINPUT);
+    }
 
   if (c == '\033' || c == CTRL ('C'))
     return -1;
@@ -1238,7 +1264,7 @@ rl_vi_overstrike_delete (count, key)
     {
       if (vi_replace_count == 0)
 	{
-	  ding ();
+	  rl_ding ();
 	  break;
 	}
       s = rl_point;
@@ -1308,7 +1334,7 @@ rl_vi_possible_completions()
     }
   else if (rl_line_buffer[rl_point - 1] == ';')
     {
-      ding ();
+      rl_ding ();
       return (0);
     }
 
@@ -1326,10 +1352,13 @@ rl_vi_set_mark (count, key)
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (_rl_lowercase_p (ch) == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   ch -= 'a';
@@ -1343,7 +1372,10 @@ rl_vi_goto_mark (count, key)
 {
   int ch;
 
+  RL_SETSTATE(RL_STATE_MOREINPUT);
   ch = rl_read_key ();
+  RL_UNSETSTATE(RL_STATE_MOREINPUT);
+
   if (ch == '`')
     {
       rl_point = rl_mark;
@@ -1351,14 +1383,14 @@ rl_vi_goto_mark (count, key)
     }
   else if (_rl_lowercase_p (ch) == 0)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
 
   ch -= 'a';
   if (vi_mark_chars[ch] == -1)
     {
-      ding ();
+      rl_ding ();
       return -1;
     }
   rl_point = vi_mark_chars[ch];
Index: readline/doc/Makefile.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/Makefile.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 Makefile.in
--- readline/doc/Makefile.in	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/Makefile.in	2001/03/06 14:05:46
@@ -63,13 +63,13 @@ GROFF       = groff
 
 DVIOBJ = readline.dvi history.dvi rluserman.dvi
 INFOOBJ = readline.info history.info rluserman.info
-PSOBJ = readline.ps history.ps rluserman.ps
+PSOBJ = readline.ps history.ps rluserman.ps readline_3.ps history_3.ps
 HTMLOBJ = readline.html history.html rluserman.html
-TEXTOBJ = readline.0
+TEXTOBJ = readline.0 history.0
 
 INTERMEDIATE_OBJ = rlman.dvi hist.dvi rluserman.dvi
 
-CREATED_DOCS = $(DVIOBJ) $(INFOOBJ) $(PSOBJ) $(HTMLOBJ) $(TEXTOBJ)
+DIST_DOCS = $(DVIOBJ) $(PSOBJ) $(HTMLOBJ) $(INFOOBJ) $(TEXTOBJ)
 
 .SUFFIXES:      .0 .3 .ps .txt .dvi
 
@@ -133,19 +133,28 @@ text:	$(TEXTOBJ)
 
 readline.0: readline.3
 
+readline_3.ps: readline.3
+	${RM} $@
+	${GROFF} -man < $(srcdir)/readline.3 > $@ 
+
+history.0: history.3
+
+history_3.ps: history.3
+	${RM} $@
+	${GROFF} -man < $(srcdir)/history.3 > $@ 
+
 clean:
 	$(RM) *.aux *.cp *.fn *.ky *.log *.pg *.toc *.tp *.vr *.cps *.pgs \
 	      *.fns *.kys *.tps *.vrs *.bt *.bts *.o core
 
 distclean: clean
-	$(RM) $(CREATED_DOCS)
 	$(RM) $(INTERMEDIATE_OBJ)
 	$(RM) Makefile
 
 mostlyclean: clean
 
 maintainer-clean: clean
-	$(RM) $(CREATED_DOCS)
+	$(RM) $(DIST_DOCS)
 	$(RM) $(INTERMEDIATE_OBJ)
 	$(RM) Makefile
 
@@ -173,9 +182,11 @@ install:	installdirs
 		install-info --dir-file=$(infodir)/dir $(infodir)/history.info ; \
 	else true; fi
 	-${INSTALL_DATA} $(srcdir)/readline.3 $(man3dir)/readline.3
+	-${INSTALL_DATA} $(srcdir)/history.3 $(man3dir)/history.3
 
 uninstall:
 	$(RM) $(infodir)/readline.info
 	$(RM) $(infodir)/rluserman.info
 	$(RM) $(infodir)/history.info
 	$(RM) $(man3dir)/readline.3
+	$(RM) $(man3dir)/history.3
Index: readline/doc/hist.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/hist.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 hist.texinfo
--- readline/doc/hist.texinfo	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/hist.texinfo	2001/02/02 16:37:12
@@ -18,7 +18,7 @@ This document describes the GNU History 
 provides a consistent user interface for recalling lines of previously
 typed input.
 
-Copyright (C) 1988-1999 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
@@ -73,7 +73,7 @@ except that this permission notice may b
 by the Free Software Foundation.
 
 @vskip 0pt plus 1filll
-Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
+Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
 @end titlepage
 
 @ifinfo
Index: readline/doc/hstech.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/hstech.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 hstech.texinfo
--- readline/doc/hstech.texinfo	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/hstech.texinfo	2001/03/12 10:37:38
@@ -1,7 +1,7 @@
 @ignore
 This file documents the user interface to the GNU History library.
 
-Copyright (C) 1988, 1991, 1994, 1996 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 Authored by Brian Fox and Chet Ramey.
 
 Permission is granted to make and distribute verbatim copies of this manual
@@ -27,9 +27,9 @@ into another language, under the above c
 @chapter Programming with GNU History
 
 This chapter describes how to interface programs that you write
-with the GNU History Library.
+with the @sc{gnu} History Library.
 It should be considered a technical guide.
-For information on the interactive use of GNU History, @pxref{Using
+For information on the interactive use of @sc{gnu} History, @pxref{Using
 History Interactively}.
 
 @menu
@@ -43,10 +43,10 @@ History Interactively}.
 @node Introduction to History
 @section Introduction to History
 
-Many programs read input from the user a line at a time.  The GNU History
-library is able to keep track of those lines, associate arbitrary data with
-each line, and utilize information from previous lines in composing new
-ones.
+Many programs read input from the user a line at a time.  The @sc{gnu}
+History library is able to keep track of those lines, associate arbitrary
+data with each line, and utilize information from previous lines in
+composing new ones. 
 
 The programmer using the History library has available functions
 for remembering lines on a history list, associating arbitrary data
@@ -80,9 +80,11 @@ The history list is an array of history 
 declared as follows:
 
 @example
+typedef void *histdata_t;
+
 typedef struct _hist_entry @{
   char *line;
-  char *data;
+  histdata_t data;
 @} HIST_ENTRY;
 @end example
 
@@ -95,12 +97,14 @@ HIST_ENTRY **the_history_list;
 The state of the History library is encapsulated into a single structure:
 
 @example
-/* A structure used to pass the current state of the history stuff around. */
+/*
+ * A structure used to pass around the current state of the history.
+ */
 typedef struct _hist_state @{
-  HIST_ENTRY **entries;         /* Pointer to the entries themselves. */
-  int offset;                   /* The location pointer within this array. */
-  int length;                   /* Number of elements within this array. */
-  int size;                     /* Number of slots allocated to this array. */
+  HIST_ENTRY **entries; /* Pointer to the entries themselves. */
+  int offset;           /* The location pointer within this array. */
+  int length;           /* Number of elements within this array. */
+  int size;             /* Number of slots allocated to this array. */
   int flags;
 @} HISTORY_STATE;
 @end example
@@ -112,7 +116,7 @@ stifled.
 @section History Functions
 
 This section describes the calling sequence for the various functions
-present in GNU History.
+exported by the @sc{gnu} History library.
 
 @menu
 * Initializing History and State Management::	Functions to call when you
@@ -139,12 +143,12 @@ This section describes functions used to
 the state of the History library when you want to use the history
 functions in your program.
 
-@deftypefun void using_history ()
+@deftypefun void using_history (void)
 Begin a session in which the history functions might be used.  This
 initializes the interactive variables.
 @end deftypefun
 
-@deftypefun {HISTORY_STATE *} history_get_history_state ()
+@deftypefun {HISTORY_STATE *} history_get_history_state (void)
 Return a structure describing the current state of the input history.
 @end deftypefun
 
@@ -158,7 +162,7 @@ Set the state of the history list accord
 These functions manage individual entries on the history list, or set
 parameters managing the list itself.
 
-@deftypefun void add_history (char *string)
+@deftypefun void add_history (const char *string)
 Place @var{string} at the end of the history list.  The associated data
 field (if any) is set to @code{NULL}.
 @end deftypefun
@@ -169,13 +173,13 @@ removed element is returned so you can f
 and containing structure.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} replace_history_entry (int which, char *line, char *data)
+@deftypefun {HIST_ENTRY *} replace_history_entry (int which, const char *line, histdata_t data)
 Make the history entry at offset @var{which} have @var{line} and @var{data}.
 This returns the old entry so you can dispose of the data.  In the case
 of an invalid @var{which}, a @code{NULL} pointer is returned.
 @end deftypefun
 
-@deftypefun void clear_history ()
+@deftypefun void clear_history (void)
 Clear the history list by deleting all the entries.
 @end deftypefun
 
@@ -183,13 +187,13 @@ Clear the history list by deleting all t
 Stifle the history list, remembering only the last @var{max} entries.
 @end deftypefun
 
-@deftypefun int unstifle_history ()
+@deftypefun int unstifle_history (void)
 Stop stifling the history.  This returns the previous amount the
 history was stifled.  The value is positive if the history was
 stifled, negative if it wasn't.
 @end deftypefun
 
-@deftypefun int history_is_stifled ()
+@deftypefun int history_is_stifled (void)
 Returns non-zero if the history is stifled, zero if it is not.
 @end deftypefun
 
@@ -199,29 +203,30 @@ Returns non-zero if the history is stifl
 These functions return information about the entire history list or
 individual list entries.
 
-@deftypefun {HIST_ENTRY **} history_list ()
-Return a @code{NULL} terminated array of @code{HIST_ENTRY} which is the
+@deftypefun {HIST_ENTRY **} history_list (void)
+Return a @code{NULL} terminated array of @code{HIST_ENTRY *} which is the
 current input history.  Element 0 of this list is the beginning of time.
 If there is no history, return @code{NULL}.
 @end deftypefun
 
-@deftypefun int where_history ()
+@deftypefun int where_history (void)
 Returns the offset of the current history element.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} current_history ()
+@deftypefun {HIST_ENTRY *} current_history (void)
 Return the history entry at the current position, as determined by
-@code{where_history ()}.  If there is no entry there, return a @code{NULL}
+@code{where_history()}.  If there is no entry there, return a @code{NULL}
 pointer.
 @end deftypefun
 
 @deftypefun {HIST_ENTRY *} history_get (int offset)
 Return the history entry at position @var{offset}, starting from
-@code{history_base}.  If there is no entry there, or if @var{offset}
+@code{history_base} (@pxref{History Variables}).
+If there is no entry there, or if @var{offset}
 is greater than the history length, return a @code{NULL} pointer.
 @end deftypefun
 
-@deftypefun int history_total_bytes ()
+@deftypefun int history_total_bytes (void)
 Return the number of bytes that the primary history entries are using.
 This function returns the sum of the lengths of all the lines in the
 history.
@@ -234,17 +239,19 @@ These functions allow the current index 
 set or changed.
 
 @deftypefun int history_set_pos (int pos)
-Set the position in the history list to @var{pos}, an absolute index
+Set the current history offset to @var{pos}, an absolute index
 into the list.
+Returns 1 on success, 0 if @var{pos} is less than zero or greater
+than the number of history entries.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} previous_history ()
+@deftypefun {HIST_ENTRY *} previous_history (void)
 Back up the current history offset to the previous history entry, and
 return a pointer to that entry.  If there is no previous entry, return
 a @code{NULL} pointer.
 @end deftypefun
 
-@deftypefun {HIST_ENTRY *} next_history ()
+@deftypefun {HIST_ENTRY *} next_history (void)
 Move the current history offset forward to the next history entry, and
 return the a pointer to that entry.  If there is no next entry, return
 a @code{NULL} pointer.
@@ -260,26 +267,28 @@ from the current history position.  The 
 meaning that the string must match at the beginning of the history entry.
 @cindex anchored search
 
-@deftypefun int history_search (char *string, int direction)
-Search the history for @var{string}, starting at the current history
-offset.  If @var{direction} < 0, then the search is through previous entries,
-else through subsequent.  If @var{string} is found, then
+@deftypefun int history_search (const char *string, int direction)
+Search the history for @var{string}, starting at the current history offset.
+If @var{direction} is less than 0, then the search is through
+previous entries, otherwise through subsequent entries.
+If @var{string} is found, then
 the current history index is set to that history entry, and the value
 returned is the offset in the line of the entry where
 @var{string} was found.  Otherwise, nothing is changed, and a -1 is
 returned.
 @end deftypefun
 
-@deftypefun int history_search_prefix (char *string, int direction)
+@deftypefun int history_search_prefix (const char *string, int direction)
 Search the history for @var{string}, starting at the current history
 offset.  The search is anchored: matching lines must begin with
-@var{string}.  If @var{direction} < 0, then the search is through previous
-entries, else through subsequent.  If @var{string} is found, then the
+@var{string}.  If @var{direction} is less than 0, then the search is
+through previous entries, otherwise through subsequent entries.
+If @var{string} is found, then the
 current history index is set to that entry, and the return value is 0. 
 Otherwise, nothing is changed, and a -1 is returned. 
 @end deftypefun
 
-@deftypefun int history_search_pos (char *string, int direction, int pos)
+@deftypefun int history_search_pos (const char *string, int direction, int pos)
 Search for @var{string} in the history list, starting at @var{pos}, an
 absolute index into the list.  If @var{direction} is negative, the search
 proceeds backward from @var{pos}, otherwise forward.  Returns the absolute
@@ -292,41 +301,46 @@ index of the history element where @var{
 The History library can read the history from and write it to a file.
 This section documents the functions for managing a history file.
 
-@deftypefun int read_history (char *filename)
-Add the contents of @var{filename} to the history list, a line at a
-time.  If @var{filename} is @code{NULL}, then read from
-@file{~/.history}.  Returns 0 if successful, or errno if not.
+@deftypefun int read_history (const char *filename)
+Add the contents of @var{filename} to the history list, a line at a time.
+If @var{filename} is @code{NULL}, then read from @file{~/.history}.
+Returns 0 if successful, or @code{errno} if not.
 @end deftypefun
 
-@deftypefun int read_history_range (char *filename, int from, int to)
+@deftypefun int read_history_range (const char *filename, int from, int to)
 Read a range of lines from @var{filename}, adding them to the history list.
-Start reading at line @var{from} and end at @var{to}.  If
-@var{from} is zero, start at the beginning.  If @var{to} is less than
+Start reading at line @var{from} and end at @var{to}.
+If @var{from} is zero, start at the beginning.  If @var{to} is less than
 @var{from}, then read until the end of the file.  If @var{filename} is
 @code{NULL}, then read from @file{~/.history}.  Returns 0 if successful,
 or @code{errno} if not.
 @end deftypefun
 
-@deftypefun int write_history (char *filename)
+@deftypefun int write_history (const char *filename)
 Write the current history to @var{filename}, overwriting @var{filename}
-if necessary.  If @var{filename} is
-@code{NULL}, then write the history list to @file{~/.history}.  Values
-returned are as in @code{read_history ()}.
+if necessary.
+If @var{filename} is @code{NULL}, then write the history list to
+@file{~/.history}.
+Returns 0 on success, or @code{errno} on a read or write error.
 @end deftypefun
 
-@deftypefun int append_history (int nelements, char *filename)
+@deftypefun int append_history (int nelements, const char *filename)
 Append the last @var{nelements} of the history list to @var{filename}.
+If @var{filename} is @code{NULL}, then append to @file{~/.history}.
+Returns 0 on success, or @code{errno} on a read or write error.
 @end deftypefun
 
-@deftypefun int history_truncate_file (char *filename, int nlines)
+@deftypefun int history_truncate_file (const char *filename, int nlines)
 Truncate the history file @var{filename}, leaving only the last
 @var{nlines} lines.
+If @var{filename} is @code{NULL}, then @file{~/.history} is truncated.
+Returns 0 on success, or @code{errno} on failure.
 @end deftypefun
 
 @node History Expansion
 @subsection History Expansion
 
-These functions implement @code{csh}-like history expansion.
+These functions implement history expansion.
 
 @deftypefun int history_expand (char *string, char **output)
 Expand @var{string}, placing the result into @var{output}, a pointer
@@ -334,7 +348,7 @@ to a string (@pxref{History Interaction}
 @table @code
 @item 0
 If no expansions took place (or, if the only change in
-the text was the de-slashifying of the history expansion
+the text was the removal of escape characters preceding the history expansion
 character);
 @item 1
 if expansions did take place;
@@ -348,13 +362,8 @@ as with the @code{:p} modifier (@pxref{M
 If an error ocurred in expansion, then @var{output} contains a descriptive
 error message.
 @end deftypefun
-
-@deftypefun {char *} history_arg_extract (int first, int last, char *string)
-Extract a string segment consisting of the @var{first} through @var{last}
-arguments present in @var{string}.  Arguments are broken up as in Bash.
-@end deftypefun
 
-@deftypefun {char *} get_history_event (char *string, int *cindex, int qchar)
+@deftypefun {char *} get_history_event (const char *string, int *cindex, int qchar)
 Returns the text of the history event beginning at @var{string} +
 @var{*cindex}.  @var{*cindex} is modified to point to after the event
 specifier.  At function entry, @var{cindex} points to the index into
@@ -363,18 +372,24 @@ is a character that is allowed to end th
 to the ``normal'' terminating characters.
 @end deftypefun
 
-@deftypefun {char **} history_tokenize (char *string)
+@deftypefun {char **} history_tokenize (const char *string)
 Return an array of tokens parsed out of @var{string}, much as the
-shell might.  The tokens are split on white space and on the
-characters @code{()<>;&|$}, and shell quoting conventions are
-obeyed.
+shell might.  The tokens are split on the characters in the
+@var{history_word_delimiters} variable,
+and shell quoting conventions are obeyed.
 @end deftypefun
 
+@deftypefun {char *} history_arg_extract (int first, int last, const char *string)
+Extract a string segment consisting of the @var{first} through @var{last}
+arguments present in @var{string}.  Arguments are split using
+@code{history_tokenize}.
+@end deftypefun
+
 @node History Variables
 @section History Variables
 
-This section describes the externally visible variables exported by
-the GNU History Library.
+This section describes the externally-visible variables exported by
+the @sc{gnu} History Library.
 
 @deftypevar int history_base
 The logical offset of the first entry in the history list.
@@ -384,13 +399,14 @@ The logical offset of the first entry in
 The number of entries currently stored in the history list.
 @end deftypevar
 
-@deftypevar int max_input_history
+@deftypevar int history_max_entries
 The maximum number of history entries.  This must be changed using
-@code{stifle_history ()}.
+@code{stifle_history()}.
 @end deftypevar
 
 @deftypevar char history_expansion_char
-The character that starts a history event.  The default is @samp{!}.
+The character that introduces a history event.  The default is @samp{!}.
+Setting this to 0 inhibits history expansion.
 @end deftypevar
 
 @deftypevar char history_subst_char
@@ -405,15 +421,20 @@ ignored, suppressing history expansion f
 This is disabled by default.
 @end deftypevar
 
+@deftypevar {char *} history_word_delimiters
+The characters that separate tokens for \fBhistory_tokenize()\fP.
+The default value is @code{" \t\n()<>;&|"}.
+@end deftypevar
+
 @deftypevar {char *} history_no_expand_chars
 The list of characters which inhibit history expansion if found immediately
-following @var{history_expansion_char}.  The default is whitespace and
-@samp{=}.
+following @var{history_expansion_char}.  The default is space, tab, newline,
+carriage return, and @samp{=}.
 @end deftypevar
 
 @deftypevar {char *} history_search_delimiter_chars
 The list of additional characters which can delimit a history search
-string, in addition to whitespace, @samp{:} and @samp{?} in the case of
+string, in addition to space, TAB, @samp{:} and @samp{?} in the case of
 a substring search.  The default is empty.
 @end deftypevar
 
@@ -422,24 +443,30 @@ If non-zero, single-quoted words are not
 character.  The default value is 0.
 @end deftypevar
 
-@deftypevar {Function *} history_inhibit_expansion_function
+@deftypevar {rl_linebuf_func_t *} history_inhibit_expansion_function
 This should be set to the address of a function that takes two arguments:
-a @code{char *} (@var{string}) and an integer index into that string (@var{i}).
+a @code{char *} (@var{string})
+and an @code{int} index into that string (@var{i}).
 It should return a non-zero value if the history expansion starting at
 @var{string[i]} should not be performed; zero if the expansion should
 be done.
 It is intended for use by applications like Bash that use the history
 expansion character for additional purposes.
-By default, this variable is set to NULL.
+By default, this variable is set to @code{NULL}.
 @end deftypevar
 
 @node History Programming Example
 @section History Programming Example
 
-The following program demonstrates simple use of the GNU History Library.
+The following program demonstrates simple use of the @sc{gnu} History Library.
 
 @smallexample
-main ()
+#include <stdio.h>
+#include <readline/history.h>
+
+main (argc, argv)
+     int argc;
+     char **argv;
 @{
   char line[1024], *t;
   int len, done = 0;
Index: readline/doc/hsuser.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/hsuser.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 hsuser.texinfo
--- readline/doc/hsuser.texinfo	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/hsuser.texinfo	2000/11/22 17:42:50
@@ -38,9 +38,9 @@ For information on using the @sc{gnu} Hi
 see the @sc{gnu} Readline Library Manual.
 @end ifset
 @ifclear BashFeatures
-This chapter describes how to use the GNU History Library interactively,
+This chapter describes how to use the @sc{gnu} History Library interactively,
 from a user's standpoint.  It should be considered a user's guide.  For
-information on using the GNU History Library in your own programs,
+information on using the @sc{gnu} History Library in your own programs,
 @pxref{Programming with GNU History}.
 @end ifclear
 
@@ -65,36 +65,36 @@ information on using the GNU History Lib
 @cindex command history
 @cindex history list
 
-When the @samp{-o history} option to the @code{set} builtin
+When the @option{-o history} option to the @code{set} builtin
 is enabled (@pxref{The Set Builtin}),
-the shell provides access to the @var{command history},
+the shell provides access to the @dfn{command history},
 the list of commands previously typed.
-The value of the @code{HISTSIZE} shell variable is used as the
+The value of the @env{HISTSIZE} shell variable is used as the
 number of commands to save in a history list.
-The text of the last @code{$HISTSIZE}
+The text of the last @env{$HISTSIZE}
 commands (default 500) is saved.
 The shell stores each command in the history list prior to
 parameter and variable expansion
 but after history expansion is performed, subject to the
 values of the shell variables
-@code{HISTIGNORE} and @code{HISTCONTROL}.
+@env{HISTIGNORE} and @env{HISTCONTROL}.
 
 When the shell starts up, the history is initialized from the
-file named by the @code{HISTFILE} variable (default @file{~/.bash_history}).
-The file named by the value of @code{HISTFILE} is truncated, if
+file named by the @env{HISTFILE} variable (default @file{~/.bash_history}).
+The file named by the value of @env{HISTFILE} is truncated, if
 necessary, to contain no more than the number of lines specified by
-the value of the @code{HISTFILESIZE} variable.
+the value of the @env{HISTFILESIZE} variable.
 When an interactive shell exits, the last
-@code{$HISTSIZE} lines are copied from the history list to the file
-named by @code{$HISTFILE}.
+@env{$HISTSIZE} lines are copied from the history list to the file
+named by @env{$HISTFILE}.
 If the @code{histappend} shell option is set (@pxref{Bash Builtins}),
 the lines are appended to the history file,
 otherwise the history file is overwritten.
-If @code{HISTFILE}
+If @env{HISTFILE}
 is unset, or if the history file is unwritable, the history is
 not saved.  After saving the history, the history file is truncated
-to contain no more than @code{$HISTFILESIZE}
-lines.  If @code{HISTFILESIZE} is not set, no truncation is performed.
+to contain no more than @env{$HISTFILESIZE}
+lines.  If @env{HISTFILESIZE} is not set, no truncation is performed.
 
 The builtin command @code{fc} may be used to list or edit and re-execute
 a portion of the history list.
@@ -105,7 +105,7 @@ are available in each editing mode that 
 history list (@pxref{Commands For History}).
 
 The shell allows control over which commands are saved on the history
-list.  The @code{HISTCONTROL} and @code{HISTIGNORE}
+list.  The @env{HISTCONTROL} and @env{HISTIGNORE}
 variables may be set to cause the shell to save only a subset of the
 commands entered.
 The @code{cmdhist}
@@ -141,15 +141,15 @@ command beginning with that string) or a
 history list, where a negative number is used as an offset from the
 current command number).  If @var{last} is not specified it is set to
 @var{first}.  If @var{first} is not specified it is set to the previous
-command for editing and @minus{}16 for listing.  If the @samp{-l} flag is
-given, the commands are listed on standard output.  The @samp{-n} flag
-suppresses the command numbers when listing.  The @samp{-r} flag
+command for editing and @minus{}16 for listing.  If the @option{-l} flag is
+given, the commands are listed on standard output.  The @option{-n} flag
+suppresses the command numbers when listing.  The @option{-r} flag
 reverses the order of the listing.  Otherwise, the editor given by
 @var{ename} is invoked on a file containing those commands.  If
 @var{ename} is not given, the value of the following variable expansion
 is used: @code{$@{FCEDIT:-$@{EDITOR:-vi@}@}}.  This says to use the
-value of the @code{FCEDIT} variable if set, or the value of the
-@code{EDITOR} variable if that is set, or @code{vi} if neither is set.
+value of the @env{FCEDIT} variable if set, or the value of the
+@env{EDITOR} variable if that is set, or @code{vi} if neither is set.
 When editing is complete, the edited commands are echoed and executed.
 
 In the second form, @var{command} is re-executed after each instance
@@ -170,7 +170,7 @@ history -ps @var{arg}
 @end example
 
 With no options, display the history list with line numbers.
-Lines prefixed with with a @samp{*} have been modified.
+Lines prefixed with a @samp{*} have been modified.
 An argument of @var{n} lists only the last @var{n} lines.
 Options, if supplied, have the following meanings:
 
@@ -211,10 +211,10 @@ the history list as a single entry.
 
 @end table
 
-When any of the @samp{-w}, @samp{-r}, @samp{-a}, or @samp{-n} options is
+When any of the @option{-w}, @option{-r}, @option{-a}, or @option{-n} options is
 used, if @var{filename}
 is given, then it is used as the history file.  If not, then
-the value of the @code{HISTFILE} variable is used.
+the value of the @env{HISTFILE} variable is used.
 
 @end table
 @end ifset
@@ -260,9 +260,9 @@ editing buffer for further modification.
 If Readline is being used, and the @code{histreedit}
 shell option is enabled, a failed history expansion will be
 reloaded into the Readline editing buffer for correction.
-The @samp{-p} option to the @code{history} builtin command
+The @option{-p} option to the @code{history} builtin command
 may be used to see what a history expansion will do before using it.
-The @samp{-s} option to the @code{history} builtin may be used to
+The @option{-s} option to the @code{history} builtin may be used to
 add commands to the end of the history list without actually executing
 them, so that they are available for subsequent recall.
 This is most useful in conjunction with Readline.
Index: readline/doc/manvers.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/manvers.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 manvers.texinfo
--- readline/doc/manvers.texinfo	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/manvers.texinfo	2001/04/16 14:54:00
@@ -1,6 +1,6 @@
-@set EDITION 4.1
-@set VERSION 4.1
-@set UPDATED 2000 January 19
-@set UPDATE-MONTH January 2000
+@set EDITION 4.2
+@set VERSION 4.2
+@set UPDATED 2001 Apr 16
+@set UPDATE-MONTH Apr 2001
 
-@set LASTCHANGE Wed Jan 19 12:16:30 EST 2000
+@set LASTCHANGE Mon Apr 16 10:53:58 EDT 2001
Index: readline/doc/readline.3
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/readline.3,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 readline.3
--- readline/doc/readline.3	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/readline.3	2001/03/05 16:11:38
@@ -6,9 +6,9 @@
 .\"	Case Western Reserve University
 .\"	chet@ins.CWRU.Edu
 .\"
-.\"	Last Change: Tue Jun  1 13:28:03 EDT 1999
+.\"	Last Change: Mon Mar  5 09:58:38 EST 2001
 .\"
-.TH READLINE 3 "1999 Jun 1" GNU
+.TH READLINE 3 "2001 Mar 5" "GNU Readline 4.2"
 .\"
 .\" File Name macro.  This used to be `.PN', for Path Name,
 .\" but Sun doesn't seem to like that very much.
@@ -23,20 +23,19 @@ readline \- get a line from a user with 
 .nf
 .ft B
 #include <stdio.h>
-#include <readline.h>
-#include <history.h>
+#include <readline/readline.h>
+#include <readline/history.h>
 .ft
 .fi
 .LP
 .nf
-.ft B
-char *readline (prompt)
-char *prompt;
-.ft
+\fIchar *\fP
+.br
+\fBreadline\fP (\fIconst char *prompt\fP);
 .fi
 .SH COPYRIGHT
-.if n Readline is Copyright (C) 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
-.if t Readline is Copyright \(co 1989, 1991, 1993, 1995, 1996 by the Free Software Foundation, Inc.
+.if n Readline is Copyright (C) 1989\-2001 by the Free Software Foundation, Inc.
+.if t Readline is Copyright \(co 1989\-2001 by the Free Software Foundation, Inc.
 .SH DESCRIPTION
 .LP
 .B readline
@@ -45,9 +44,10 @@ and return it, using
 .B prompt
 as a prompt.  If 
 .B prompt
-is null, no prompt is issued.  The line returned is allocated with
-.IR malloc (3),
-so the caller must free it when finished.  The line returned
+is \fBNULL\fP or the empty string, no prompt is issued.
+The line returned is allocated with
+.IR malloc (3);
+the caller must free it when finished.  The line returned
 has the final newline removed, so only the text of the line
 remains.
 .LP
@@ -57,6 +57,11 @@ line.
 By default, the line editing commands
 are similar to those of emacs.
 A vi\-style line editing interface is also available.
+.LP
+This manual page describes only the most basic use of \fBreadline\fP.
+Much more functionality is available; see
+\fIThe GNU Readline Library\fP and \fIThe GNU History Library\fP
+for additional information.
 .SH RETURN VALUE
 .LP
 .B readline
@@ -130,6 +135,7 @@ or
 .RS
 C\-Meta\-u: universal\-argument
 .RE
+.sp
 into the 
 .I inputrc
 would make M\-C\-u execute the readline command
@@ -137,15 +143,16 @@ would make M\-C\-u execute the readline 
 .PP
 The following symbolic character names are recognized while
 processing key bindings:
-.IR RUBOUT ,
 .IR DEL ,
 .IR ESC ,
+.IR ESCAPE ,
 .IR LFD ,
 .IR NEWLINE ,
 .IR RET ,
 .IR RETURN ,
-.IR SPC ,
+.IR RUBOUT ,
 .IR SPACE ,
+.IR SPC ,
 and
 .IR TAB .
 .PP
@@ -161,6 +168,7 @@ command or the text of a macro and a key
 it should be bound. The name may be specified in one of two ways:
 as a symbolic key name, possibly with \fIMeta\-\fP or \fIControl\-\fP
 prefixes, or as a key sequence.
+.PP
 When using the form \fBkeyname\fP:\^\fIfunction-name\fP or \fImacro\fP,
 .I keyname
 is the name of a key spelled out in English.  For example:
@@ -170,7 +178,7 @@ Control\-u: universal\-argument
 .br
 Meta\-Rubout: backward\-kill\-word
 .br
-Control\-o: ">&output"
+Control\-o: "> output"
 .RE
 .LP
 In the above example,
@@ -184,7 +192,8 @@ and
 .I C\-o
 is bound to run the macro
 expressed on the right hand side (that is, to insert the text
-.I >&output
+.if t \f(CW> output\fP
+.if n ``> output''
 into the line).
 .PP
 In the second form, \fB"keyseq"\fP:\^\fIfunction\-name\fP or \fImacro\fP,
@@ -194,7 +203,8 @@ differs from
 above in that strings denoting
 an entire key sequence may be specified by placing the sequence
 within double quotes.  Some GNU Emacs style key escapes can be
-used, as in the following example.
+used, as in the following example, but the symbolic character names
+are not recognized.
 .sp
 .RS
 "\eC\-u": universal\-argument
@@ -214,8 +224,11 @@ is bound to the function
 and 
 .I "ESC [ 1 1 ~"
 is bound to insert the text
-.BR "Function Key 1" .
-The full set of GNU Emacs style escape sequences is
+.if t \f(CWFunction Key 1\fP.
+.if n ``Function Key 1''.
+.PP
+The full set of GNU Emacs style escape sequences available when specifying
+key sequences is
 .RS
 .PD 0
 .TP
@@ -232,10 +245,10 @@ an escape character
 backslash
 .TP
 .B \e"
-literal "
+literal ", a double quote
 .TP
 .B \e'
-literal '
+literal ', a single quote
 .RE
 .PD
 .PP
@@ -313,7 +326,8 @@ file with a statement of the form
 Except where noted, readline variables can take the values
 .B On
 or
-.BR Off .
+.B Off
+(without regard to case).
 The variables and their default values are:
 .PP
 .PD 0
@@ -351,7 +365,7 @@ on the terminal.
 .B convert\-meta (On)
 If set to \fBOn\fP, readline will convert characters with the
 eighth bit set to an ASCII key sequence
-by stripping the eighth bit and prepending an
+by stripping the eighth bit and prefixing it with an
 escape character (in effect, using escape as the \fImeta prefix\fP).
 .TP
 .B disable\-completion (Off)
@@ -361,7 +375,7 @@ mapped to \fBself-insert\fP.
 .TP
 .B editing\-mode (emacs)
 Controls whether readline begins with a set of key bindings similar
-to \fIemacs\fP or \fIvi\fP.
+to emacs or vi.
 .B editing\-mode
 can be set to either
 .B emacs
@@ -384,12 +398,12 @@ becomes longer than the screen width rat
 .TP
 .B input\-meta (Off)
 If set to \fBOn\fP, readline will enable eight-bit input (that is,
-it will not strip the high bit from the characters it reads),
+it will not clear the eighth bit in the characters it reads),
 regardless of what the terminal claims it can support.  The name
 .B meta\-flag
 is a synonym for this variable.
 .TP
-.B isearch\-terminators (``C\-[C\-J'')
+.B isearch\-terminators (``C\-[ C\-J'')
 The string of characters that should terminate an incremental
 search without subsequently executing the character as a command.
 If this variable has not been given a value, the characters
@@ -402,13 +416,13 @@ vi-command\fP, and
 .IR vi-insert .
 \fIvi\fP is equivalent to \fIvi-command\fP; \fIemacs\fP is
 equivalent to \fIemacs-standard\fP.  The default value is
-.IR emacs ;
-the value of
+.IR emacs .
+The value of
 .B editing\-mode
 also affects the default keymap.
 .TP
 .B mark\-directories (On)
-If set to \fBOn\fP, complete<d directory names have a slash
+If set to \fBOn\fP, completed directory names have a slash
 appended.
 .TP
 .B mark\-modified\-lines (Off)
@@ -433,7 +447,7 @@ matches to be listed immediately instead
 .TP
 .B visible\-stats (Off)
 If set to \fBOn\fP, a character denoting a file's type as reported  
-by \fBstat\fP(2) is appended to the filename when listing possible
+by \fIstat\fP(2) is appended to the filename when listing possible
 completions.
 .PD
 .SS Conditional Constructs
@@ -481,7 +495,7 @@ key sequence that quotes the current or 
 .sp 1
 .RS
 .nf
-\fB$if\fP bash
+\fB$if\fP Bash
 # Quote the current or previous word
 "\eC-xq": "\eeb\e"\eef\e""
 \fB$endif\fP
@@ -519,22 +533,27 @@ As each character of the search string i
 the next entry from the history matching the string typed so far.
 An incremental search requires only as many characters as needed to
 find the desired history entry.
-The characters present in the value of the \fIisearch-terminators\fP
+To search backward in the history for a particular string, type
+\fBC\-r\fP.  Typing \fBC\-s\fP searches forward through the history.
+The characters present in the value of the \fBisearch-terminators\fP
 variable are used to terminate an incremental search.
-If that variable has not been assigned a value the Escape and
-Control-J characters will terminate an incremental search.
-Control-G will abort an incremental search and restore the original
+If that variable has not been assigned a value the \fIEscape\fP and
+\fBC\-J\fP characters will terminate an incremental search.
+\fBC\-G\fP will abort an incremental search and restore the original
 line.
 When the search is terminated, the history entry containing the
 search string becomes the current line.
-To find other matching entries in the history list, type Control-S or
-Control-R as appropriate.
+.PP
+To find other matching entries in the history list, type \fBC\-s\fP or
+\fBC\-r\fP as appropriate.
 This will search backward or forward in the history for the next
 line matching the search string typed so far.
 Any other key sequence bound to a readline command will terminate
 the search and execute that command.
-For instance, a \fInewline\fP will terminate the search and accept
+For instance, a newline will terminate the search and accept
 the line, thereby executing the command from the history list.
+A movement command will terminate the search, make the last line found
+the current line, and begin editing.
 .PP
 Non-incremental searches read the entire search string before starting
 to search for matching history lines.  The search string may be
@@ -544,6 +563,11 @@ typed by the user or be part of the cont
 The following is a list of the names of the commands and the default
 key sequences to which they are bound.
 Command names without an accompanying key sequence are unbound by default.
+.PP
+In the following descriptions, \fIpoint\fP refers to the current cursor
+position, and \fImark\fP refers to a cursor position saved by the
+\fBset\-mark\fP command.
+The text between the point and mark is referred to as the \fIregion\fP.
 .SS Commands for Moving
 .PP
 .PD 0
@@ -581,9 +605,11 @@ Refresh the current line.
 .PD 0
 .TP
 .B accept\-line (Newline, Return)
-Accept the line regardless of where the cursor is.  If this line is
-non-empty, add it to the history list. If the line is a modified
-history line, then restore the history line to its original state.
+Accept the line regardless of where the cursor is.
+If this line is
+non-empty, it may be added to the history list for future recall with
+\fBadd_history()\fP.
+If the line is a modified history line, the history line is restored to its original state.
 .TP
 .B previous\-history (C\-p)
 Fetch the previous command from the history list, moving back in
@@ -629,8 +655,8 @@ This is a non-incremental search.
 .TP
 .B yank\-nth\-arg (M\-C\-y)
 Insert the first argument to the previous command (usually
-the second word on the previous line) at point (the current
-cursor position).  With an argument
+the second word on the previous line) at point.
+With an argument
 .IR n ,
 insert the \fIn\fPth word from the previous command (the words
 in the previous command begin with word 0).  A negative argument
@@ -649,9 +675,9 @@ list, inserting the last argument of eac
 .PD 0
 .TP
 .B delete\-char (C\-d)
-Delete the character under the cursor.  If point is at the
+Delete the character at point.  If point is at the
 beginning of the line, there are no characters in the line, and
-the last character typed was not bound to \fBBdelete\-char\fP, then return
+the last character typed was not bound to \fBdelete\-char\fP, then return
 .SM
 .BR EOF .
 .TP
@@ -662,7 +688,7 @@ save the deleted text on the kill ring.
 .B forward\-backward\-delete\-char   
 Delete the character under the cursor, unless the cursor is at the
 end of the line, in which case the character behind the cursor is
-deleted.  By default, this is not bound to a key.
+deleted.
 .TP
 .B quoted\-insert (C\-q, C\-v)
 Add the next character that you type to the line verbatim.  This is
@@ -675,13 +701,15 @@ Insert a tab character.
 Insert the character typed.
 .TP
 .B transpose\-chars (C\-t)
-Drag the character before point forward over the character at point.
-Point moves forward as well.  If point is at the end of the line, then
-transpose the two characters before point.  Negative arguments don't work.
+Drag the character before point forward over the character at point,
+moving point forward as well.
+If point is at the end of the line, then this transposes
+the two characters before point.
+Negative arguments have no effect.
 .TP
 .B transpose\-words (M\-t)
-Drag the word behind the cursor past the word in front of the cursor
-moving the cursor over that word as well.
+Drag the word before point past the word after point,
+moving point over that word as well.
 .TP
 .B upcase\-word (M\-u)
 Uppercase the current (or following) word.  With a negative argument,
@@ -700,7 +728,7 @@ capitalize the previous word, but do not
 .PD 0
 .TP
 .B kill\-line (C\-k)
-Kill the text from the current cursor position to the end of the line.
+Kill the text from point to the end of the line.
 .TP
 .B backward\-kill\-line (C\-x Rubout)
 Kill backward to the beginning of the line.
@@ -711,22 +739,20 @@ The killed text is saved on the kill-rin
 .\" There is no real difference between this and backward-kill-line
 .TP
 .B kill\-whole\-line
-Kill all characters on the current line, no matter where the
-cursor is.
+Kill all characters on the current line, no matter where point is.
 .TP
 .B kill\-word  (M\-d)
-Kill from the cursor to the end of the current word, or if between
+Kill from point the end of the current word, or if between
 words, to the end of the next word.  Word boundaries are the same as
 those used by \fBforward\-word\fP.
 .TP
 .B backward\-kill\-word (M\-Rubout)
-Kill the word behind the cursor.  Word boundaries are the same as
-those used by \fBbackward\-word\fP.
+Kill the word behind point.
+Word boundaries are the same as those used by \fBbackward\-word\fP.
 .TP
 .B unix\-word\-rubout (C\-w)
-Kill the word behind the cursor, using white space as a word boundary.
-The word boundaries are different from
-.BR backward\-kill\-word .
+Kill the word behind point, using white space as a word boundary.
+The killed text is saved on the kill-ring.
 .TP
 .B delete\-horizontal\-space (M\-\e)
 Delete all spaces and tabs around point.
@@ -747,7 +773,7 @@ Copy the word following point to the kil
 The word boundaries are the same as \fBforward\-word\fP.
 .TP
 .B yank (C\-y)
-Yank the top of the kill ring into the buffer at the cursor.
+Yank the top of the kill ring into the buffer at point.
 .TP
 .B yank\-pop (M\-y)
 Rotate the kill ring, and yank the new top.  Only works following
@@ -808,8 +834,9 @@ Similar to \fBcomplete\fP, but replaces 
 with a single match from the list of possible completions.
 Repeated execution of \fBmenu\-complete\fP steps through the list
 of possible completions, inserting each match in turn.
-At the end of the list of completions, the bell is rung and the
-original text is restored.
+At the end of the list of completions, the bell is rung
+(subject to the setting of \Bbell\-style\fP)
+and the original text is restored.
 An argument of \fIn\fP moves \fIn\fP positions forward in the list
 of matches; a negative argument may be used to move backward 
 through the list.
@@ -821,7 +848,6 @@ Deletes the character under the cursor i
 end of the line (like \fBdelete-char\fP).
 If at the end of the line, behaves identically to
 \fBpossible-completions\fP.
-This command is unbound by default.
 .PD
 .SS Keyboard Macros
 .PP
@@ -874,8 +900,8 @@ command enough times to return the line 
 .B tilde\-expand (M\-&)
 Perform tilde expansion on the current word.
 .TP
-.B set\-mark (C\-@, M-<space>)
-Set the mark to the current point.  If a
+.B set\-mark (C\-@, M\-<space>)
+Set the mark to the point.  If a
 numeric argument is supplied, the mark is set to that position.
 .TP
 .B exchange\-point\-and\-mark (C\-x C\-x)
@@ -894,8 +920,9 @@ character.  A negative count searches fo
 The value of the readline
 .B comment\-begin
 variable is inserted at the beginning of the current line, and the line
-is accepted as if a newline had been typed.  This makes the current line
-a shell comment.
+is accepted as if a newline had been typed.  The default value of
+.B comment\-begin
+makes the current line a shell comment.
 .TP
 .B dump\-functions
 Print all of the functions and their key bindings to the
@@ -932,25 +959,23 @@ editing mode.
 .SH DEFAULT KEY BINDINGS
 .LP
 The following is a list of the default emacs and vi bindings.
-Characters with the 8th bit set are written as M\-<character>, and
+Characters with the eighth bit set are written as M\-<character>, and
 are referred to as
 .I metafied
 characters.
 The printable ASCII characters not mentioned in the list of emacs
 standard bindings are bound to the
-.I self\-insert
+.B self\-insert
 function, which just inserts the given character into the input line.
 In vi insertion mode, all characters not specifically mentioned are
 bound to
-.IR self\-insert .
+.BR self\-insert .
 Characters assigned to signal generation by
 .IR stty (1)
 or the terminal driver, such as C-Z or C-C,
 retain that function.
-Upper and lower case
-.I metafied
-characters are bound to the same function in the emacs mode
-meta keymap.
+Upper and lower case metafied characters are bound to the same function in
+the emacs mode meta keymap.
 The remaining characters are unbound, which causes readline
 to ring the bell (subject to the setting of the
 .B bell\-style
@@ -1036,7 +1061,7 @@ Emacs Meta bindings
 "M-Y"  yank-pop
 "M-\e"  delete-horizontal-space
 "M-~"  tilde-expand
-"M-C-?"  backward-delete-word
+"M-C-?"  backward-kill-word
 "M-_"  yank-last-arg
 .PP
 Emacs Control-X bindings
@@ -1096,6 +1121,7 @@ VI Command Mode functions
 "C-V"  quoted-insert
 "C-W"  unix-word-rubout
 "C-Y"  yank
+"C-_"  vi-undo
 "\^ "  forward-char
 "#"  insert-comment
 "$"  end-of-line
@@ -1150,7 +1176,7 @@ VI Command Mode functions
 "r"  vi-change-char
 "s"  vi-subst
 "t"  vi-char-search
-"u"  undo
+"u"  vi-undo
 "w"  vi-next-word
 "x"  vi-delete
 "y"  vi-yank-to
Index: readline/doc/rlman.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/rlman.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rlman.texinfo
--- readline/doc/rlman.texinfo	2003/02/16 21:36:33	1.1.1.1
+++ readline/doc/rlman.texinfo	2001/02/02 16:49:17
@@ -18,7 +18,7 @@ This document describes the GNU Readline
 in the consistency of user interface across discrete programs that need
 to provide a command line interface.
 
-Copyright (C) 1988-1999 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
@@ -73,7 +73,7 @@ except that this permission notice may b
 by the Free Software Foundation.
 
 @vskip 0pt plus 1filll
-Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
+Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
 @end titlepage
 
 @ifinfo
Index: readline/doc/rltech.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/rltech.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rltech.texinfo
--- readline/doc/rltech.texinfo	2003/02/16 21:36:34	1.1.1.1
+++ readline/doc/rltech.texinfo	2001/03/12 10:42:09
@@ -8,7 +8,7 @@ This document describes the GNU Readline
 in the consitency of user interface across discrete programs that need
 to provide a command line interface.
 
-Copyright (C) 1988, 1994, 1996, 1998, 1999 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
@@ -35,9 +35,9 @@ by the Foundation.
 @node Programming with GNU Readline
 @chapter Programming with GNU Readline
 
-This chapter describes the interface between the GNU Readline Library and
+This chapter describes the interface between the @sc{gnu} Readline Library and
 other programs.  If you are a programmer, and you wish to include the
-features found in GNU Readline
+features found in @sc{gnu} Readline
 such as completion, line editing, and interactive history manipulation
 in your own programs, this section is for you.
 
@@ -61,18 +61,20 @@ Many programs provide a command line int
 @code{ftp}, and @code{sh}.  For such programs, the default behaviour of
 Readline is sufficient.  This section describes how to use Readline in
 the simplest way possible, perhaps to replace calls in your code to
-@code{gets()} or @code{fgets ()}.
+@code{gets()} or @code{fgets()}.
 
 @findex readline
 @cindex readline, function
-The function @code{readline ()} prints a prompt and then reads and returns
-a single line of text from the user.  The line @code{readline}
-returns is allocated with @code{malloc ()}; you should @code{free ()}
-the line when you are done with it.  The declaration for @code{readline}
-in ANSI C is
 
+The function @code{readline()} prints a prompt @var{prompt}
+and then reads and returns a single line of text from the user.
+If @var{prompt} is @code{NULL} or the empty string, no prompt is displayed.
+The line @code{readline} returns is allocated with @code{malloc()};
+the caller should @code{free()} the line when it has finished with it.
+The declaration for @code{readline} in ANSI C is
+
 @example
-@code{char *readline (char *@var{prompt});}
+@code{char *readline (const char *@var{prompt});}
 @end example
 
 @noindent
@@ -90,7 +92,7 @@ line is empty at that point, then @code{
 Otherwise, the line is ended just as if a newline had been typed.
 
 If you want the user to be able to get at the line later, (with
-@key{C-p} for example), you must call @code{add_history ()} to save the
+@key{C-p} for example), you must call @code{add_history()} to save the
 line away in a @dfn{history} list of such lines.
 
 @example
@@ -102,7 +104,7 @@ For full details on the GNU History Libr
 
 It is preferable to avoid saving empty lines on the history list, since
 users rarely have a burning need to reuse a blank line.  Here is
-a function which usefully replaces the standard @code{gets ()} library
+a function which usefully replaces the standard @code{gets()} library
 function, and has the advantage of no static buffer to overflow:
 
 @example
@@ -135,17 +137,17 @@ rl_gets ()
 This function gives the user the default behaviour of @key{TAB}
 completion: completion on file names.  If you do not want Readline to
 complete on filenames, you can change the binding of the @key{TAB} key
-with @code{rl_bind_key ()}.
+with @code{rl_bind_key()}.
 
 @example
-@code{int rl_bind_key (int @var{key}, int (*@var{function})());}
+@code{int rl_bind_key (int @var{key}, rl_command_func_t *@var{function});}
 @end example
 
-@code{rl_bind_key ()} takes two arguments: @var{key} is the character that
+@code{rl_bind_key()} takes two arguments: @var{key} is the character that
 you want to bind, and @var{function} is the address of the function to
-call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert ()}
+call when @var{key} is pressed.  Binding @key{TAB} to @code{rl_insert()}
 makes @key{TAB} insert itself.
-@code{rl_bind_key ()} returns non-zero if @var{key} is not a valid
+@code{rl_bind_key()} returns non-zero if @var{key} is not a valid
 ASCII character code (between 0 and 255).
 
 Thus, to disable the default @key{TAB} behavior, the following suffices:
@@ -154,7 +156,7 @@ Thus, to disable the default @key{TAB} b
 @end example
 
 This code should be executed once at the start of your program; you
-might write a function called @code{initialize_readline ()} which
+might write a function called @code{initialize_readline()} which
 performs this and other desired initializations, such as installing
 custom completers (@pxref{Custom Completers}).
 
@@ -175,45 +177,72 @@ in @code{readline.h} use the @code{stdio
 @code{<stdio.h>} should be included before @code{readline.h}.
 
 @menu
-* The Function Type::	C declarations to make code readable.
+* Readline Typedefs::	C declarations to make code readable.
 * Function Writing::	Variables and calling conventions.
 @end menu
 
-@node The Function Type
-@subsection The Function Type
+@node Readline Typedefs
+@subsection Readline Typedefs
 
-For readabilty, we declare a new type of object, called
-@dfn{Function}.  A @code{Function} is a C function which
-returns an @code{int}.  The type declaration for @code{Function} is:
+For readabilty, we declare a number of new object types, all pointers
+to functions.
 
-@noindent
-@code{typedef int Function ();}
+The reason for declaring these new types is to make it easier to write
+code describing pointers to C functions with appropriately prototyped
+arguments and return values.
+
+For instance, say we want to declare a variable @var{func} as a pointer
+to a function which takes two @code{int} arguments and returns an
+@code{int} (this is the type of all of the Readline bindable functions).
+Instead of the classic C declaration
 
-The reason for declaring this new type is to make it easier to write
-code describing pointers to C functions.  Let us say we had a variable
-called @var{func} which was a pointer to a function.  Instead of the
-classic C declaration
+@code{int (*func)();}
+
+@noindent
+or the ANSI-C style declaration
 
-@code{int (*)()func;}
+@code{int (*func)(int, int);}
 
 @noindent
 we may write
 
-@code{Function *func;}
+@code{rl_command_func_t *func;}
 
-@noindent
-Similarly, there are
+The full list of function pointer types available is
 
-@example
-typedef void VFunction ();
-typedef char *CPFunction (); @r{and}
-typedef char **CPPFunction ();
-@end example
+@table @code
+@item typedef int rl_command_func_t (int, int);
 
-@noindent
-for functions returning no value, @code{pointer to char}, and
-@code{pointer to pointer to char}, respectively.
+@item typedef char *rl_compentry_func_t (const char *, int);
+
+@item typedef char **rl_completion_func_t (const char *, int, int);
+
+@item typedef char *rl_quote_func_t (char *, int, char *);
+
+@item typedef char *rl_dequote_func_t (char *, int);
+
+@item typedef int rl_compignore_func_t (char **);
+
+@item typedef void rl_compdisp_func_t (char **, int, int);
 
+@item typedef int rl_hook_func_t (void);
+
+@item typedef int rl_getc_func_t (FILE *);
+
+@item typedef int rl_linebuf_func_t (char *, int);
+
+@item typedef int rl_intfunc_t (int);
+@item #define rl_ivoidfunc_t rl_hook_func_t
+@item typedef int rl_icpfunc_t (char *);
+@item typedef int rl_icppfunc_t (char **);
+
+@item typedef void rl_voidfunc_t (void);
+@item typedef void rl_vintfunc_t (int);
+@item typedef void rl_vcpfunc_t (char *);
+@item typedef void rl_vcppfunc_t (char **);
+
+@end table
+
 @node Function Writing
 @subsection Writing a New Function
 
@@ -265,7 +294,7 @@ The number of characters present in @cod
 @end deftypevar
 
 @deftypevar int rl_mark
-The mark (saved position) in the current line.  If set, the mark
+The @var{mark} (saved position) in the current line.  If set, the mark
 and point define a @emph{region}.
 @end deftypevar
 
@@ -274,11 +303,23 @@ Setting this to a non-zero value causes 
 line immediately.
 @end deftypevar
 
+@deftypevar int rl_num_chars_to_read
+Setting this to a positive value before calling @code{readline()} causes
+Readline to return after accepting that many characters, rather
+than reading up to a character bound to @code{accept-line}.
+@end deftypevar
+
 @deftypevar int rl_pending_input
 Setting this to a value makes it the next keystroke read.  This is a
 way to stuff a single character into the input stream.
 @end deftypevar
 
+@deftypevar int rl_dispatching
+Set to a non-zero value if a function is being called from a key binding;
+zero otherwise.  Application functions can test this to discover whether
+they were called directly or by Readline's dispatching mechanism.
+@end deftypevar
+
 @deftypevar int rl_erase_empty_line
 Setting this to a non-zero value causes Readline to completely erase
 the current line, including any prompt, any time a newline is typed as
@@ -288,7 +329,9 @@ the beginning of the newly-blank line.
 
 @deftypevar {char *} rl_prompt
 The prompt Readline uses.  This is set from the argument to
-@code{readline ()}, and should not be assigned to directly.
+@code{readline()}, and should not be assigned to directly.
+The @code{rl_set_prompt()} function (@pxref{Redisplay}) may
+be used to modify the prompt string after calling @code{readline()}.
 @end deftypevar
 
 @deftypevar int rl_already_prompted
@@ -301,15 +344,22 @@ The calling application is responsible f
 never sets it.
 @end deftypevar
 
-@deftypevar {char *} rl_library_version
+@deftypevar {const char *} rl_library_version
 The version number of this revision of the library.
 @end deftypevar
+
+@deftypevar {int} rl_gnu_readline_p
+Always set to 1, denoting that this is @sc{gnu} readline rather than some
+emulation.
+@end deftypevar
 
-@deftypevar {char *} rl_terminal_name
-The terminal type, used for initialization.
+@deftypevar {const char *} rl_terminal_name
+The terminal type, used for initialization.  If not set by the application,
+Readline sets this to the value of the @env{TERM} environment variable
+the first time it is called.
 @end deftypevar
 
-@deftypevar {char *} rl_readline_name
+@deftypevar {const char *} rl_readline_name
 This variable is set to a unique name by each application using Readline.
 The value allows conditional parsing of the inputrc file
 (@pxref{Conditional Init Constructs}).
@@ -323,36 +373,60 @@ The stdio stream from which Readline rea
 The stdio stream to which Readline performs output.
 @end deftypevar
 
-@deftypevar {Function *} rl_startup_hook
+@deftypevar {rl_command_func_t *} rl_last_func
+The address of the last command function Readline executed.  May be used to
+test whether or not a function is being executed twice in succession, for
+example.
+@end deftypevar
+
+@deftypevar {rl_hook_func_t *} rl_startup_hook
 If non-zero, this is the address of a function to call just
 before @code{readline} prints the first prompt.
 @end deftypevar
 
-@deftypevar {Function *} rl_pre_input_hook
+@deftypevar {rl_hook_func_t *} rl_pre_input_hook
 If non-zero, this is the address of a function to call after
 the first prompt has been printed and just before @code{readline}
 starts reading input characters.
 @end deftypevar
 
-@deftypevar {Function *} rl_event_hook
+@deftypevar {rl_hook_func_t *} rl_event_hook
 If non-zero, this is the address of a function to call periodically
-when readline is waiting for terminal input.
+when Readline is waiting for terminal input.
+By default, this will be called at most ten times a second if there
+is no keyboard input.
 @end deftypevar
 
-@deftypevar {Function *} rl_getc_function
-If non-zero, @code{readline} will call indirectly through this pointer
+@deftypevar {rl_getc_func_t *} rl_getc_function
+If non-zero, Readline will call indirectly through this pointer
 to get a character from the input stream.  By default, it is set to
-@code{rl_getc}, the default @code{readline} character input function
-(@pxref{Utility Functions}).
+@code{rl_getc}, the default Readline character input function
+(@pxref{Character Input}).
 @end deftypevar
 
-@deftypevar {VFunction *} rl_redisplay_function
-If non-zero, @code{readline} will call indirectly through this pointer
+@deftypevar {rl_voidfunc_t *} rl_redisplay_function
+If non-zero, Readline will call indirectly through this pointer
 to update the display with the current contents of the editing buffer.
-By default, it is set to @code{rl_redisplay}, the default @code{readline}
+By default, it is set to @code{rl_redisplay}, the default Readline
 redisplay function (@pxref{Redisplay}).
 @end deftypevar
 
+@deftypevar {rl_vintfunc_t *} rl_prep_term_function
+If non-zero, Readline will call indirectly through this pointer
+to initialize the terminal.  The function takes a single argument, an
+@code{int} flag that says whether or not to use eight-bit characters.
+By default, this is set to @code{rl_prep_terminal}
+(@pxref{Terminal Management}).
+@end deftypevar
+
+@deftypevar {rl_voidfunc_t *} rl_deprep_term_function
+If non-zero, Readline will call indirectly through this pointer
+to reset the terminal.  This function should undo the effects of
+@code{rl_prep_term_function}.
+By default, this is set to @code{rl_deprep_terminal}
+(@pxref{Terminal Management}).
+@end deftypevar
+
 @deftypevar {Keymap} rl_executing_keymap
 This variable is set to the keymap (@pxref{Keymaps}) in which the
 currently executing readline function was found.
@@ -363,6 +437,79 @@ This variable is set to the keymap (@pxr
 last key binding occurred.
 @end deftypevar 
 
+@deftypevar {char *} rl_executing_macro
+This variable is set to the text of any currently-executing macro.
+@end deftypevar
+
+@deftypevar {int} rl_readline_state
+A variable with bit values that encapsulate the current Readline state.
+A bit is set with the @code{RL_SETSTATE} macro, and unset with the
+@code{RL_UNSETSTATE} macro.  Use the @code{RL_ISSTATE} macro to test
+whether a particular state bit is set.  Current state bits include:
+
+@table @code
+@item RL_STATE_NONE
+Readline has not yet been called, nor has it begun to intialize.
+@item RL_STATE_INITIALIZING
+Readline is initializing its internal data structures.
+@item RL_STATE_INITIALIZED
+Readline has completed its initialization.
+@item RL_STATE_TERMPREPPED
+Readline has modified the terminal modes to do its own input and redisplay.
+@item RL_STATE_READCMD
+Readline is reading a command from the keyboard.
+@item RL_STATE_METANEXT
+Readline is reading more input after reading the meta-prefix character.
+@item RL_STATE_DISPATCHING
+Readline is dispatching to a command.
+@item RL_STATE_MOREINPUT
+Readline is reading more input while executing an editing command.
+@item RL_STATE_ISEARCH
+Readline is performing an incremental history search.
+@item RL_STATE_NSEARCH
+Readline is performing a non-incremental history search.
+@item RL_STATE_SEARCH
+Readline is searching backward or forward through the history for a string.
+@item RL_STATE_NUMERICARG
+Readline is reading a numeric argument.
+@item RL_STATE_MACROINPUT
+Readline is currently getting its input from a previously-defined keyboard
+macro.
+@item RL_STATE_MACRODEF
+Readline is currently reading characters defining a keyboard macro.
+@item RL_STATE_OVERWRITE
+Readline is in overwrite mode.
+@item RL_STATE_COMPLETING
+Readline is performing word completion.
+@item RL_STATE_SIGHANDLER
+Readline is currently executing the readline signal handler.
+@item RL_STATE_UNDOING
+Readline is performing an undo.
+@item RL_STATE_DONE
+Readline has read a key sequence bound to @code{accept-line}
+and is about to return the line to the caller.
+@end table
+
+@end deftypevar
+
+@deftypevar {int} rl_explicit_arg
+Set to a non-zero value if an explicit numeric argument was specified by
+the user.  Only valid in a bindable command function.
+@end deftypevar
+
+@deftypevar {int} rl_numeric_arg
+Set to the value of any numeric argument explicitly specified by the user
+before executing the current Readline function.  Only valid in a bindable
+command function.
+@end deftypevar
+
+@deftypevar {int} rl_editing_mode
+Set to a value denoting Readline's current editing mode.  A value of
+@var{1} means Readline is currently in emacs mode; @var{0}
+means that vi mode is active.
+@end deftypevar
+
+
 @node Readline Convenience Functions
 @section Readline Convenience Functions
 
@@ -375,8 +522,12 @@ last key binding occurred.
 * Allowing Undoing::	How to make your functions undoable.
 * Redisplay::		Functions to control line display.
 * Modifying Text::	Functions to modify @code{rl_line_buffer}.
+* Character Input::	Functions to read keyboard input.
+* Terminal Management::	Functions to manage terminal settings.
 * Utility Functions::	Generally useful functions and hooks.
+* Miscellaneous Functions::	Functions that don't fall into any category.
 * Alternate Interface::	Using Readline in a `callback' fashion.
+* A Readline Example::		An example Readline function.
 @end menu
 
 @node Function Naming
@@ -396,10 +547,10 @@ This binds the keystroke @key{Meta-Rubou
 programmer, should bind the functions you write to descriptive names as
 well.  Readline provides a function for doing that:
 
-@deftypefun int rl_add_defun (char *name, Function *function, int key)
+@deftypefun int rl_add_defun (const char *name, rl_command_func_t *function, int key)
 Add @var{name} to the list of named functions.  Make @var{function} be
 the function that gets called.  If @var{key} is not -1, then bind it to
-@var{function} using @code{rl_bind_key ()}.
+@var{function} using @code{rl_bind_key()}.
 @end deftypefun
 
 Using this function alone is sufficient for most applications.  It is
@@ -416,16 +567,17 @@ association between the keys that the us
 get run.  You can make your own keymaps, copy existing keymaps, and tell
 Readline which keymap to use.
 
-@deftypefun Keymap rl_make_bare_keymap ()
+@deftypefun Keymap rl_make_bare_keymap (void)
 Returns a new, empty keymap.  The space for the keymap is allocated with
-@code{malloc ()}; you should @code{free ()} it when you are done.
+@code{malloc()}; the caller should free it by calling
+@code{rl_discard_keymap()} when done.
 @end deftypefun
 
 @deftypefun Keymap rl_copy_keymap (Keymap map)
 Return a new keymap which is a copy of @var{map}.
 @end deftypefun
 
-@deftypefun Keymap rl_make_keymap ()
+@deftypefun Keymap rl_make_keymap (void)
 Return a new keymap with the printing characters bound to rl_insert,
 the lowercase Meta characters bound to run their equivalents, and
 the Meta digits bound to produce numeric arguments.
@@ -438,7 +590,7 @@ Free the storage associated with @var{ke
 Readline has several internal keymaps.  These functions allow you to
 change which keymap is active.
 
-@deftypefun Keymap rl_get_keymap ()
+@deftypefun Keymap rl_get_keymap (void)
 Returns the currently active keymap.
 @end deftypefun
 
@@ -446,7 +598,7 @@ Returns the currently active keymap.
 Makes @var{keymap} the currently active keymap.
 @end deftypefun
 
-@deftypefun Keymap rl_get_keymap_by_name (char *name)
+@deftypefun Keymap rl_get_keymap_by_name (const char *name)
 Return the keymap matching @var{name}.  @var{name} is one which would
 be supplied in a @code{set keymap} inputrc line (@pxref{Readline Init File}).
 @end deftypefun
@@ -459,28 +611,28 @@ be supplied in a @code{set keymap} input
 @node Binding Keys
 @subsection Binding Keys
 
-You associate keys with functions through the keymap.  Readline has
-several internal keymaps: @code{emacs_standard_keymap},
+Key sequences are associate with functions through the keymap.
+Readline has several internal keymaps: @code{emacs_standard_keymap},
 @code{emacs_meta_keymap}, @code{emacs_ctlx_keymap},
 @code{vi_movement_keymap}, and @code{vi_insertion_keymap}.
 @code{emacs_standard_keymap} is the default, and the examples in
 this manual assume that.
 
-Since @code{readline} installs a set of default key bindings the first
+Since @code{readline()} installs a set of default key bindings the first
 time it is called, there is always the danger that a custom binding
-installed before the first call to @code{readline} will be overridden.
+installed before the first call to @code{readline()} will be overridden.
 An alternate mechanism is to install custom key bindings in an
 initialization function assigned to the @code{rl_startup_hook} variable
 (@pxref{Readline Variables}).
 
 These functions manage key bindings.
 
-@deftypefun int rl_bind_key (int key, Function *function)
+@deftypefun int rl_bind_key (int key, rl_command_func_t *function)
 Binds @var{key} to @var{function} in the currently active keymap.
 Returns non-zero in the case of an invalid @var{key}.
 @end deftypefun
 
-@deftypefun int rl_bind_key_in_map (int key, Function *function, Keymap map)
+@deftypefun int rl_bind_key_in_map (int key, rl_command_func_t *function, Keymap map)
 Bind @var{key} to @var{function} in @var{map}.  Returns non-zero in the case
 of an invalid @var{key}.
 @end deftypefun
@@ -495,15 +647,21 @@ Bind @var{key} to the null function in @
 Returns non-zero in case of error.
 @end deftypefun
 
-@deftypefun int rl_unbind_function_in_map (Function *function, Keymap map)
+@deftypefun int rl_unbind_function_in_map (rl_command_func_t *function, Keymap map)
 Unbind all keys that execute @var{function} in @var{map}.
 @end deftypefun
 
-@deftypefun int rl_unbind_command_in_map (char *command, Keymap map)
+@deftypefun int rl_unbind_command_in_map (const char *command, Keymap map)
 Unbind all keys that are bound to @var{command} in @var{map}.
 @end deftypefun
 
-@deftypefun int rl_generic_bind (int type, char *keyseq, char *data, Keymap map)
+@deftypefun int rl_set_key (const char *keyseq, rl_command_func_t *function, Keymap map)
+Bind the key sequence represented by the string @var{keyseq} to the function
+@var{function}.  This makes new keymaps as
+necessary.  The initial keymap in which to do bindings is @var{map}.
+@end deftypefun
+
+@deftypefun int rl_generic_bind (int type, const char *keyseq, char *data, Keymap map)
 Bind the key sequence represented by the string @var{keyseq} to the arbitrary
 pointer @var{data}.  @var{type} says what kind of data is pointed to by
 @var{data}; this can be a function (@code{ISFUNC}), a macro
@@ -517,7 +675,7 @@ perform any key bindings and variable as
 (@pxref{Readline Init File}).
 @end deftypefun
 
-@deftypefun int rl_read_init_file (char *filename)
+@deftypefun int rl_read_init_file (const char *filename)
 Read keybindings and variable assignments from @var{filename}
 (@pxref{Readline Init File}).
 @end deftypefun
@@ -526,25 +684,26 @@ Read keybindings and variable assignment
 @subsection Associating Function Names and Bindings
 
 These functions allow you to find out what keys invoke named functions
-and the functions invoked by a particular key sequence.
+and the functions invoked by a particular key sequence.  You may also
+associate a new function name with an arbitrary function.
 
-@deftypefun {Function *} rl_named_function (char *name)
+@deftypefun {rl_command_func_t *} rl_named_function (const char *name)
 Return the function with name @var{name}.
 @end deftypefun
 
-@deftypefun {Function *} rl_function_of_keyseq (char *keyseq, Keymap map, int *type)
+@deftypefun {rl_command_func_t *} rl_function_of_keyseq (const char *keyseq, Keymap map, int *type)
 Return the function invoked by @var{keyseq} in keymap @var{map}.
-If @var{map} is NULL, the current keymap is used.  If @var{type} is
-not NULL, the type of the object is returned in it (one of @code{ISFUNC},
-@code{ISKMAP}, or @code{ISMACR}).
+If @var{map} is @code{NULL}, the current keymap is used.  If @var{type} is
+not @code{NULL}, the type of the object is returned in the @code{int} variable
+it points to (one of @code{ISFUNC}, @code{ISKMAP}, or @code{ISMACR}).
 @end deftypefun
 
-@deftypefun {char **} rl_invoking_keyseqs (Function *function)
+@deftypefun {char **} rl_invoking_keyseqs (rl_command_func_t *function)
 Return an array of strings representing the key sequences used to
 invoke @var{function} in the current keymap.
 @end deftypefun
 
-@deftypefun {char **} rl_invoking_keyseqs_in_map (Function *function, Keymap map)
+@deftypefun {char **} rl_invoking_keyseqs_in_map (rl_command_func_t *function, Keymap map)
 Return an array of strings representing the key sequences used to
 invoke @var{function} in the keymap @var{map}.
 @end deftypefun
@@ -556,14 +715,19 @@ the list is formatted in such a way that
 @code{inputrc} file and re-read.
 @end deftypefun
 
-@deftypefun void rl_list_funmap_names ()
+@deftypefun void rl_list_funmap_names (void)
 Print the names of all bindable Readline functions to @code{rl_outstream}.
 @end deftypefun
 
-@deftypefun {char **} rl_funmap_names ()
+@deftypefun {const char **} rl_funmap_names (void)
 Return a NULL terminated array of known function names.  The array is
 sorted.  The array itself is allocated, but not the strings inside.  You
-should free () the array when you done, but not the pointrs.
+should @code{free()} the array when you are done, but not the pointers.
+@end deftypefun
+
+@deftypefun int rl_add_funmap_entry (const char *name, rl_command_func_t *function)
+Add @var{name} to the list of bindable Readline command names, and make
+@var{function} the function to be called when @var{name} is invoked.
 @end deftypefun
 
 @node Allowing Undoing
@@ -571,17 +735,16 @@ should free () the array when you done, 
 
 Supporting the undo command is a painless thing, and makes your
 functions much more useful.  It is certainly easy to try
-something if you know you can undo it.  I could use an undo function for
-the stock market.
+something if you know you can undo it.
 
 If your function simply inserts text once, or deletes text once, and
-uses @code{rl_insert_text ()} or @code{rl_delete_text ()} to do it, then
+uses @code{rl_insert_text()} or @code{rl_delete_text()} to do it, then
 undoing is already done for you automatically.
 
 If you do multiple insertions or multiple deletions, or any combination
 of these operations, you should group them together into one operation.
-This is done with @code{rl_begin_undo_group ()} and
-@code{rl_end_undo_group ()}.
+This is done with @code{rl_begin_undo_group()} and
+@code{rl_end_undo_group()}.
 
 The types of events that can be undone are:
 
@@ -591,21 +754,21 @@ enum undo_code @{ UNDO_DELETE, UNDO_INSE
 
 Notice that @code{UNDO_DELETE} means to insert some text, and
 @code{UNDO_INSERT} means to delete some text.  That is, the undo code
-tells undo what to undo, not how to undo it.  @code{UNDO_BEGIN} and
-@code{UNDO_END} are tags added by @code{rl_begin_undo_group ()} and
-@code{rl_end_undo_group ()}.
+tells what to undo, not how to undo it.  @code{UNDO_BEGIN} and
+@code{UNDO_END} are tags added by @code{rl_begin_undo_group()} and
+@code{rl_end_undo_group()}.
 
-@deftypefun int rl_begin_undo_group ()
+@deftypefun int rl_begin_undo_group (void)
 Begins saving undo information in a group construct.  The undo
-information usually comes from calls to @code{rl_insert_text ()} and
-@code{rl_delete_text ()}, but could be the result of calls to
-@code{rl_add_undo ()}.
+information usually comes from calls to @code{rl_insert_text()} and
+@code{rl_delete_text()}, but could be the result of calls to
+@code{rl_add_undo()}.
 @end deftypefun
 
-@deftypefun int rl_end_undo_group ()
+@deftypefun int rl_end_undo_group (void)
 Closes the current undo group started with @code{rl_begin_undo_group
-()}.  There should be one call to @code{rl_end_undo_group ()}
-for each call to @code{rl_begin_undo_group ()}.
+()}.  There should be one call to @code{rl_end_undo_group()}
+for each call to @code{rl_begin_undo_group()}.
 @end deftypefun
 
 @deftypefun void rl_add_undo (enum undo_code what, int start, int end, char *text)
@@ -613,17 +776,17 @@ Remember how to undo an event (according
 text runs from @var{start} to @var{end}, and encompasses @var{text}.
 @end deftypefun
 
-@deftypefun void free_undo_list ()
+@deftypefun void rl_free_undo_list (void)
 Free the existing undo list.
 @end deftypefun
 
-@deftypefun int rl_do_undo ()
+@deftypefun int rl_do_undo (void)
 Undo the first thing on the undo list.  Returns @code{0} if there was
 nothing to undo, non-zero if something was undone.
 @end deftypefun
 
 Finally, if you neither insert nor delete text, but directly modify the
-existing text (e.g., change its case), call @code{rl_modifying ()}
+existing text (e.g., change its case), call @code{rl_modifying()}
 once, just before you modify the text.  You must supply the indices of
 the text range that you are going to modify.
 
@@ -636,22 +799,22 @@ that text.
 @node Redisplay
 @subsection Redisplay
 
-@deftypefun void rl_redisplay ()
+@deftypefun void rl_redisplay (void)
 Change what's displayed on the screen to reflect the current contents
 of @code{rl_line_buffer}.
 @end deftypefun
 
-@deftypefun int rl_forced_update_display ()
+@deftypefun int rl_forced_update_display (void)
 Force the line to be updated and redisplayed, whether or not
 Readline thinks the screen display is correct.
 @end deftypefun
 
-@deftypefun int rl_on_new_line ()
+@deftypefun int rl_on_new_line (void)
 Tell the update functions that we have moved onto a new (empty) line,
 usually after ouputting a newline.
 @end deftypefun
 
-@deftypefun int rl_on_new_line_with_prompt ()
+@deftypefun int rl_on_new_line_with_prompt (void)
 Tell the update functions that we have moved onto a new line, with
 @var{rl_prompt} already displayed.
 This could be used by applications that want to output the prompt string
@@ -660,35 +823,65 @@ redisplay.
 It should be used after setting @var{rl_already_prompted}.
 @end deftypefun
 
-@deftypefun int rl_reset_line_state ()
+@deftypefun int rl_reset_line_state (void)
 Reset the display state to a clean state and redisplay the current line
 starting on a new line.
 @end deftypefun
+
+@deftypefun int rl_crlf (void)
+Move the cursor to the start of the next screen line.
+@end deftypefun
+
+@deftypefun int rl_show_char (int c)
+Display character @var{c} on @code{rl_outstream}.
+If Readline has not been set to display meta characters directly, this
+will convert meta characters to a meta-prefixed key sequence.
+This is intended for use by applications which wish to do their own
+redisplay.
+@end deftypefun
 
-@deftypefun int rl_message (va_alist)
-The arguments are a string as would be supplied to @code{printf}.  The
-resulting string is displayed in the @dfn{echo area}.  The echo area
+@deftypefun int rl_message (const char *, @dots{})
+The arguments are a format string as would be supplied to @code{printf},
+possibly containing conversion specifications such as @samp{%d}, and
+any additional arguments necessary to satisfy the conversion specifications.
+The resulting string is displayed in the @dfn{echo area}.  The echo area
 is also used to display numeric arguments and search strings.
 @end deftypefun
 
-@deftypefun int rl_clear_message ()
+@deftypefun int rl_clear_message (void)
 Clear the message in the echo area.
 @end deftypefun
 
-@deftypefun void rl_save_prompt ()
+@deftypefun void rl_save_prompt (void)
 Save the local Readline prompt display state in preparation for
-displaying a new message in the message area with @code{rl_message}.
+displaying a new message in the message area with @code{rl_message()}.
 @end deftypefun
 
-@deftypefun void rl_restore_prompt ()
+@deftypefun void rl_restore_prompt (void)
 Restore the local Readline prompt display state saved by the most
 recent call to @code{rl_save_prompt}.
 @end deftypefun
 
+@deftypefun int rl_expand_prompt (char *prompt)
+Expand any special character sequences in @var{prompt} and set up the
+local Readline prompt redisplay variables.
+This function is called by @code{readline()}.  It may also be called to
+expand the primary prompt if the @code{rl_on_new_line_with_prompt()}
+function or @code{rl_already_prompted} variable is used.
+It returns the number of visible characters on the last line of the
+(possibly multi-line) prompt.
+@end deftypefun
+
+@deftypefun int rl_set_prompt (const char *prompt)
+Make Readline use @var{prompt} for subsequent redisplay.  This calls
+@code{rl_expand_prompt()} to expand the prompt and sets @code{rl_prompt}
+to the result.
+@end deftypefun
+
 @node Modifying Text
 @subsection Modifying Text
 
-@deftypefun int rl_insert_text (char *text)
+@deftypefun int rl_insert_text (const char *text)
 Insert @var{text} into the line at the current cursor position.
 @end deftypefun
 
@@ -710,53 +903,104 @@ the text is appended, otherwise prepende
 not a kill, a new kill ring slot is used.
 @end deftypefun
 
-@node Utility Functions
-@subsection Utility Functions
-
-@deftypefun int rl_read_key ()
-Return the next character available.  This handles input inserted into
-the input stream via @var{pending input} (@pxref{Readline Variables})
-and @code{rl_stuff_char ()}, macros, and characters read from the keyboard.
+@deftypefun int rl_push_macro_input (char *macro)
+Cause @var{macro} to be inserted into the line, as if it had been invoked
+by a key bound to a macro.  Not especially useful; use
+@code{rl_insert_text()} instead.
+@end deftypefun
+
+@node Character Input
+@subsection Character Input
+
+@deftypefun int rl_read_key (void)
+Return the next character available from Readline's current input stream.
+This handles input inserted into
+the input stream via @var{rl_pending_input} (@pxref{Readline Variables})
+and @code{rl_stuff_char()}, macros, and characters read from the keyboard.
+While waiting for input, this function will call any function assigned to
+the @code{rl_event_hook} variable.
+@end deftypefun
+
+@deftypefun int rl_getc (FILE *stream)
+Return the next character available from @var{stream}, which is assumed to
+be the keyboard.
 @end deftypefun
 
-@deftypefun int rl_getc (FILE *)
-Return the next character available from the keyboard.
-@end deftypefun
-
 @deftypefun int rl_stuff_char (int c)
 Insert @var{c} into the Readline input stream.  It will be "read"
 before Readline attempts to read characters from the terminal with
-@code{rl_read_key ()}.
+@code{rl_read_key()}.
 @end deftypefun
 
-@deftypefun int rl_extend_line_buffer (int len)
-Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
-characters, possibly reallocating it if necessary.
+@deftypefun int rl_execute_next (int c)
+Make @var{c} be the next command to be executed when @code{rl_read_key()}
+is called.  This sets @var{rl_pending_input}.
 @end deftypefun
 
-@deftypefun int rl_initialize ()
-Initialize or re-initialize Readline's internal state.
+@deftypefun int rl_clear_pending_input (void)
+Unset @var{rl_pending_input}, effectively negating the effect of any
+previous call to @code{rl_execute_next()}.  This works only if the
+pending input has not already been read with @code{rl_read_key()}.
+@end deftypefun
+
+@deftypefun int rl_set_keyboard_input_timeout (int u)
+While waiting for keyboard input in @code{rl_read_key()}, Readline will
+wait for @var{u} microseconds for input before calling any function
+assigned to @code{rl_event_hook}.  The default waiting period is
+one-tenth of a second.  Returns the old timeout value.
 @end deftypefun
+
+@node Terminal Management
+@subsection Terminal Management
 
-@deftypefun int rl_reset_terminal (char *terminal_name)
+@deftypefun void rl_prep_terminal (int meta_flag)
+Modify the terminal settings for Readline's use, so @code{readline()}
+can read a single character at a time from the keyboard.
+The @var{meta_flag} argument should be non-zero if Readline should
+read eight-bit input.
+@end deftypefun
+
+@deftypefun void rl_deprep_terminal (void)
+Undo the effects of @code{rl_prep_terminal()}, leaving the terminal in
+the state in which it was before the most recent call to
+@code{rl_prep_terminal()}.
+@end deftypefun
+
+@deftypefun void rl_tty_set_default_bindings (Keymap kmap)
+Read the operating system's terminal editing characters (as would be displayed
+by @code{stty}) to their Readline equivalents.  The bindings are performed
+in @var{kmap}.
+@end deftypefun
+
+@deftypefun int rl_reset_terminal (const char *terminal_name)
 Reinitialize Readline's idea of the terminal settings using
 @var{terminal_name} as the terminal type (e.g., @code{vt100}).
-If @var{terminal_name} is NULL, the value of the @code{TERM}
+If @var{terminal_name} is @code{NULL}, the value of the @code{TERM}
 environment variable is used.
 @end deftypefun
 
-@deftypefun int alphabetic (int c)
-Return 1 if @var{c} is an alphabetic character.
+@node Utility Functions
+@subsection Utility Functions
+
+@deftypefun int rl_extend_line_buffer (int len)
+Ensure that @code{rl_line_buffer} has enough space to hold @var{len}
+characters, possibly reallocating it if necessary.
 @end deftypefun
 
-@deftypefun int numeric (int c)
-Return 1 if @var{c} is a numeric character.
+@deftypefun int rl_initialize (void)
+Initialize or re-initialize Readline's internal state.
+It's not strictly necessary to call this; @code{readline()} calls it before
+reading any input.
 @end deftypefun
 
-@deftypefun int ding ()
+@deftypefun int rl_ding (void)
 Ring the terminal bell, obeying the setting of @code{bell-style}.
 @end deftypefun
 
+@deftypefun int rl_alphabetic (int c)
+Return 1 if @var{c} is an alphabetic character.
+@end deftypefun
+
 @deftypefun void rl_display_match_list (char **matches, int len, int max)
 A convenience function for displaying a list of strings in
 columnar format on Readline's output stream.  @code{matches} is the list
@@ -767,34 +1011,71 @@ the setting of @code{print-completions-h
 matches are displayed (@pxref{Readline Init File Syntax}).
 @end deftypefun
 
-The following are implemented as macros, defined in @code{chartypes.h}.
+The following are implemented as macros, defined in @code{chardefs.h}.
+Applications should refrain from using them.
 
-@deftypefun int uppercase_p (int c)
+@deftypefun int _rl_uppercase_p (int c)
 Return 1 if @var{c} is an uppercase alphabetic character.
 @end deftypefun
 
-@deftypefun int lowercase_p (int c)
+@deftypefun int _rl_lowercase_p (int c)
 Return 1 if @var{c} is a lowercase alphabetic character.
 @end deftypefun
 
-@deftypefun int digit_p (int c)
+@deftypefun int _rl_digit_p (int c)
 Return 1 if @var{c} is a numeric character.
 @end deftypefun
 
-@deftypefun int to_upper (int c)
+@deftypefun int _rl_to_upper (int c)
 If @var{c} is a lowercase alphabetic character, return the corresponding
 uppercase character.
 @end deftypefun
 
-@deftypefun int to_lower (int c)
+@deftypefun int _rl_to_lower (int c)
 If @var{c} is an uppercase alphabetic character, return the corresponding
 lowercase character.
 @end deftypefun
 
-@deftypefun int digit_value (int c)
+@deftypefun int _rl_digit_value (int c)
 If @var{c} is a number, return the value it represents.
 @end deftypefun
 
+@node Miscellaneous Functions
+@subsection Miscellaneous Functions
+
+@deftypefun int rl_macro_bind (const char *keyseq, const char *macro, Keymap map)
+Bind the key sequence @var{keyseq} to invoke the macro @var{macro}.
+The binding is performed in @var{map}.  When @var{keyseq} is invoked, the
+@var{macro} will be inserted into the line.  This function is deprecated;
+use @code{rl_generic_bind()} instead.
+@end deftypefun
+
+@deftypefun void rl_macro_dumper (int readable)
+Print the key sequences bound to macros and their values, using
+the current keymap, to @code{rl_outstream}.
+If @var{readable} is non-zero, the list is formatted in such a way
+that it can be made part of an @code{inputrc} file and re-read.
+@end deftypefun
+
+@deftypefun int rl_variable_bind (const char *variable, const char *value)
+Make the Readline variable @var{variable} have @var{value}.
+This behaves as if the readline command
+@samp{set @var{variable} @var{value}} had been executed in an @code{inputrc}
+file (@pxref{Readline Init File Syntax}).
+@end deftypefun
+
+@deftypefun void rl_variable_dumper (int readable)
+Print the readline variable names and their current values
+to @code{rl_outstream}.
+If @var{readable} is non-zero, the list is formatted in such a way
+that it can be made part of an @code{inputrc} file and re-read.
+@end deftypefun
+
+@deftypefun int rl_set_paren_blink_timeout (int u)
+Set the time interval (in microseconds) that Readline waits when showing
+a balancing character when @code{blink-matching-paren} has been enabled.
+@end deftypefun
+
 @node Alternate Interface
 @subsection Alternate Interface
 
@@ -805,13 +1086,14 @@ on various file descriptors.  To accomod
 also be invoked as a `callback' function from an event loop.  There
 are functions available to make this easy.
 
-@deftypefun void rl_callback_handler_install (char *prompt, Vfunction *lhandler)
+@deftypefun void rl_callback_handler_install (const char *prompt, rl_vcpfunc_t *lhandler)
 Set up the terminal for readline I/O and display the initial
 expanded value of @var{prompt}.  Save the value of @var{lhandler} to
-use as a callback when a complete line of input has been entered.
+use as a function to call when a complete line of input has been entered.
+The function takes the text of the line as an argument.
 @end deftypefun
 
-@deftypefun void rl_callback_read_char ()
+@deftypefun void rl_callback_read_char (void)
 Whenever an application determines that keyboard input is available, it
 should call @code{rl_callback_read_char()}, which will read the next
 character from the current input source.  If that character completes the
@@ -821,12 +1103,13 @@ line.  @code{EOF} is  indicated by calli
 @code{NULL} line.
 @end deftypefun
 
-@deftypefun void rl_callback_handler_remove ()
+@deftypefun void rl_callback_handler_remove (void)
 Restore the terminal to its initial state and remove the line handler.
 This may be called from within a callback as well as independently.
 @end deftypefun
 
-@subsection An Example
+@node A Readline Example
+@subsection A Readline Example
 
 Here is a function which changes lowercase characters to their uppercase
 equivalents, and uppercase characters to lowercase.  If
@@ -881,10 +1164,10 @@ invert_case_line (count, key)
 
   for (i = start; i != end; i++)
     @{
-      if (uppercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
-      else if (lowercase_p (rl_line_buffer[i]))
-        rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
+      if (_rl_uppercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = _rl_to_lower (rl_line_buffer[i]);
+      else if (_rl_lowercase_p (rl_line_buffer[i]))
+        rl_line_buffer[i] = _rl_to_upper (rl_line_buffer[i]);
     @}
   /* Move point to on top of the last character changed. */
   rl_point = (direction == 1) ? end - 1 : start;
@@ -897,44 +1180,44 @@ invert_case_line (count, key)
 
 Signals are asynchronous events sent to a process by the Unix kernel,
 sometimes on behalf of another process.  They are intended to indicate
-exceptional events, like a user pressing the interrupt key on his
-terminal, or a network connection being broken.  There is a class of
-signals that can be sent to the process currently reading input from
-the keyboard.  Since Readline changes the terminal attributes when it
-is called, it needs to perform special processing when a signal is
-received to restore the terminal to a sane state, or provide application
-writers with functions to do so manually.
+exceptional events, like a user pressing the interrupt key on his terminal,
+or a network connection being broken.  There is a class of signals that can
+be sent to the process currently reading input from the keyboard.  Since
+Readline changes the terminal attributes when it is called, it needs to
+perform special processing when such a signal is received in order to
+restore the terminal to a sane state, or provide application writers with
+functions to do so manually. 
 
 Readline contains an internal signal handler that is installed for a
 number of signals (@code{SIGINT}, @code{SIGQUIT}, @code{SIGTERM},
 @code{SIGALRM}, @code{SIGTSTP}, @code{SIGTTIN}, and @code{SIGTTOU}).
 When one of these signals is received, the signal handler
 will reset the terminal attributes to those that were in effect before
-@code{readline ()} was called, reset the signal handling to what it was
-before @code{readline ()} was called, and resend the signal to the calling
+@code{readline()} was called, reset the signal handling to what it was
+before @code{readline()} was called, and resend the signal to the calling
 application.
 If and when the calling application's signal handler returns, Readline
 will reinitialize the terminal and continue to accept input.
 When a @code{SIGINT} is received, the Readline signal handler performs
 some additional work, which will cause any partially-entered line to be
-aborted (see the description of @code{rl_free_line_state ()}).
+aborted (see the description of @code{rl_free_line_state()} below).
 
 There is an additional Readline signal handler, for @code{SIGWINCH}, which
 the kernel sends to a process whenever the terminal's size changes (for
 example, if a user resizes an @code{xterm}).  The Readline @code{SIGWINCH}
-handler updates Readline's internal screen size state, and then calls any
-@code{SIGWINCH} signal handler the calling application has installed. 
+handler updates Readline's internal screen size information, and then calls
+any @code{SIGWINCH} signal handler the calling application has installed. 
 Readline calls the application's @code{SIGWINCH} signal handler without
 resetting the terminal to its original state.  If the application's signal
 handler does more than update its idea of the terminal size and return (for
 example, a @code{longjmp} back to a main processing loop), it @emph{must}
-call @code{rl_cleanup_after_signal ()} (described below), to restore the
+call @code{rl_cleanup_after_signal()} (described below), to restore the
 terminal state. 
 
 Readline provides two variables that allow application writers to
 control whether or not it will catch certain signals and act on them
 when they are received.  It is important that applications change the
-values of these variables only when calling @code{readline ()}, not in
+values of these variables only when calling @code{readline()}, not in
 a signal handler, so Readline's internal signal state is not corrupted.
 
 @deftypevar int rl_catch_signals
@@ -960,7 +1243,7 @@ and internal state cleanup upon receipt 
 
 @deftypefun void rl_cleanup_after_signal (void)
 This function will reset the state of the terminal to what it was before
-@code{readline ()} was called, and remove the Readline signal handlers for
+@code{readline()} was called, and remove the Readline signal handlers for
 all signals, depending on the values of @code{rl_catch_signals} and
 @code{rl_catch_sigwinch}.
 @end deftypefun
@@ -969,7 +1252,7 @@ all signals, depending on the values of 
 This will free any partial state associated with the current input line
 (undo information, any partial history entry, any partially-entered
 keyboard macro, and any partially-entered numeric argument).  This
-should be called before @code{rl_cleanup_after_signal ()}.  The
+should be called before @code{rl_cleanup_after_signal()}.  The
 Readline signal handler for @code{SIGINT} calls this to abort the
 current input line.
 @end deftypefun
@@ -981,11 +1264,26 @@ handlers, depending on the values of @co
 @end deftypefun
 
 If an application does not wish Readline to catch @code{SIGWINCH}, it may
-call @code{rl_resize_terminal ()} to force Readline to update its idea of
-the terminal size when a @code{SIGWINCH} is received.
+call @code{rl_resize_terminal()} or @code{rl_set_screen_size()} to force
+Readline to update its idea of the terminal size when a @code{SIGWINCH}
+is received.
 
 @deftypefun void rl_resize_terminal (void)
-Update Readline's internal screen size.
+Update Readline's internal screen size by reading values from the kernel.
+@end deftypefun
+
+@deftypefun void rl_set_screen_size (int rows, int cols)
+Set Readline's idea of the terminal size to @var{rows} rows and
+@var{cols} columns.
+@end deftypefun
+
+If an application does not want to install a @code{SIGWINCH} handler, but
+is still interested in the screen dimensions, Readline's idea of the screen
+size may be queried.
+
+@deftypefun void rl_get_screen_size (int *rows, int *cols)
+Return Readline's idea of the terminal's size in the
+variables pointed to by the arguments.
 @end deftypefun
 
 The following functions install and remove Readline's signal handlers.
@@ -999,7 +1297,7 @@ Install Readline's signal handler for @c
 
 @deftypefun int rl_clear_signals (void)
 Remove all of the Readline signal handlers installed by
-@code{rl_set_signals ()}.
+@code{rl_set_signals()}.
 @end deftypefun
 
 @node Custom Completers
@@ -1034,30 +1332,31 @@ There are three major functions used to 
 
 @enumerate
 @item
-The user-interface function @code{rl_complete ()}.  This function is
-called with the same arguments as other Readline
-functions intended for interactive use:  @var{count} and
-@var{invoking_key}.  It isolates the word to be completed and calls
-@code{completion_matches ()} to generate a list of possible completions.
+The user-interface function @code{rl_complete()}.  This function is
+called with the same arguments as other bindable Readline functions:
+@var{count} and @var{invoking_key}.
+It isolates the word to be completed and calls
+@code{rl_completion_matches()} to generate a list of possible completions.
 It then either lists the possible completions, inserts the possible
 completions, or actually performs the
 completion, depending on which behavior is desired.
 
 @item
-The internal function @code{completion_matches ()} uses your
-@dfn{generator} function to generate the list of possible matches, and
-then returns the array of these matches.  You should place the address
-of your generator function in @code{rl_completion_entry_function}.
+The internal function @code{rl_completion_matches()} uses an
+application-supplied @dfn{generator} function to generate the list of
+possible matches, and then returns the array of these matches.
+The caller should place the address of its generator function in
+@code{rl_completion_entry_function}.
 
 @item
 The generator function is called repeatedly from
-@code{completion_matches ()}, returning a string each time.  The
+@code{rl_completion_matches()}, returning a string each time.  The
 arguments to the generator function are @var{text} and @var{state}.
 @var{text} is the partial word to be completed.  @var{state} is zero the
 first time the function is called, allowing the generator to perform
 any necessary initialization, and a positive non-zero integer for
-each subsequent call.  When the generator function returns
-@code{(char *)NULL} this signals @code{completion_matches ()} that there are
+each subsequent call.  The generator function returns
+@code{(char *)NULL} to inform @code{rl_completion_matches()} that there are
 no more possibilities left.  Usually the generator function computes the
 list of possible completions when @var{state} is zero, and returns them
 one at a time on subsequent calls.  Each string the generator function
@@ -1069,14 +1368,15 @@ frees the strings when it has finished w
 @deftypefun int rl_complete (int ignore, int invoking_key)
 Complete the word at or before point.  You have supplied the function
 that does the initial simple matching selection algorithm (see
-@code{completion_matches ()}).  The default is to do filename completion.
+@code{rl_completion_matches()}).  The default is to do filename completion.
 @end deftypefun
 
-@deftypevar {Function *} rl_completion_entry_function
-This is a pointer to the generator function for @code{completion_matches
-()}.  If the value of @code{rl_completion_entry_function} is
-@code{(Function *)NULL} then the default filename generator function,
-@code{filename_completion_function ()}, is used.
+@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
+This is a pointer to the generator function for
+@code{rl_completion_matches()}.
+If the value of @code{rl_completion_entry_function} is
+@code{NULL} then the default filename generator
+function, @code{rl_filename_completion_function()}, is used.
 @end deftypevar
 
 @node Completion Functions
@@ -1097,47 +1397,47 @@ performing partial completion.
 @deftypefun int rl_complete (int ignore, int invoking_key)
 Complete the word at or before point.  You have supplied the function
 that does the initial simple matching selection algorithm (see
-@code{completion_matches ()} and @code{rl_completion_entry_function}).
+@code{rl_completion_matches()} and @code{rl_completion_entry_function}).
 The default is to do filename
-completion.  This calls @code{rl_complete_internal ()} with an
+completion.  This calls @code{rl_complete_internal()} with an
 argument depending on @var{invoking_key}.
 @end deftypefun
 
-@deftypefun int rl_possible_completions (int count, int invoking_key))
+@deftypefun int rl_possible_completions (int count, int invoking_key)
 List the possible completions.  See description of @code{rl_complete
-()}.  This calls @code{rl_complete_internal ()} with an argument of
+()}.  This calls @code{rl_complete_internal()} with an argument of
 @samp{?}.
 @end deftypefun
 
-@deftypefun int rl_insert_completions (int count, int invoking_key))
+@deftypefun int rl_insert_completions (int count, int invoking_key)
 Insert the list of possible completions into the line, deleting the
-partially-completed word.  See description of @code{rl_complete ()}.
-This calls @code{rl_complete_internal ()} with an argument of @samp{*}.
+partially-completed word.  See description of @code{rl_complete()}.
+This calls @code{rl_complete_internal()} with an argument of @samp{*}.
 @end deftypefun
 
-@deftypefun {char **} completion_matches (char *text, CPFunction *entry_func)
-Returns an array of @code{(char *)} which is a list of completions for
-@var{text}.  If there are no completions, returns @code{(char **)NULL}.
+@deftypefun {char **} rl_completion_matches (const char *text, rl_compentry_func_t *entry_func)
+Returns an array of strings which is a list of completions for
+@var{text}.  If there are no completions, returns @code{NULL}.
 The first entry in the returned array is the substitution for @var{text}.
 The remaining entries are the possible completions.  The array is
 terminated with a @code{NULL} pointer.
 
 @var{entry_func} is a function of two args, and returns a
-@code{(char *)}.  The first argument is @var{text}.  The second is a
+@code{char *}.  The first argument is @var{text}.  The second is a
 state argument; it is zero on the first call, and non-zero on subsequent
 calls.  @var{entry_func} returns a @code{NULL}  pointer to the caller
 when there are no more matches.
 @end deftypefun
 
-@deftypefun {char *} filename_completion_function (char *text, int state)
-A generator function for filename completion in the general case.  Note
-that completion in Bash is a little different because of all
-the pathnames that must be followed when looking up completions for a
-command.  The Bash source is a useful reference for writing custom
-completion functions.
+@deftypefun {char *} rl_filename_completion_function (const char *text, int state)
+A generator function for filename completion in the general case.
+@var{text} is a partial filename.
+The Bash source is a useful reference for writing custom
+completion functions (the Bash completion functions call this and other
+Readline functions).
 @end deftypefun
 
-@deftypefun {char *} username_completion_function (char *text, int state)
+@deftypefun {char *} rl_username_completion_function (const char *text, int state)
 A completion generator for usernames.  @var{text} contains a partial
 username preceded by a random character (usually @samp{~}).  As with all
 completion generators, @var{state} is zero on the first call and non-zero
@@ -1147,26 +1447,29 @@ for subsequent calls.
 @node Completion Variables
 @subsection Completion Variables
 
-@deftypevar {Function *} rl_completion_entry_function
-A pointer to the generator function for @code{completion_matches ()}.
-@code{NULL} means to use @code{filename_completion_function ()}, the default
+@deftypevar {rl_compentry_func_t *} rl_completion_entry_function
+A pointer to the generator function for @code{rl_completion_matches()}.
+@code{NULL} means to use @code{rl_filename_completion_function()}, the default
 filename completer.
 @end deftypevar
 
-@deftypevar {CPPFunction *} rl_attempted_completion_function
+@deftypevar {rl_completion_func_t *} rl_attempted_completion_function
 A pointer to an alternative function to create matches.
 The function is called with @var{text}, @var{start}, and @var{end}.
-@var{start} and @var{end} are indices in @code{rl_line_buffer} saying
-what the boundaries of @var{text} are.  If this function exists and
-returns @code{NULL}, or if this variable is set to @code{NULL}, then
-@code{rl_complete ()} will call the value of
+@var{start} and @var{end} are indices in @code{rl_line_buffer} defining
+the boundaries of @var{text}, which is a character string.
+If this function exists and returns @code{NULL}, or if this variable is
+set to @code{NULL}, then @code{rl_complete()} will call the value of
 @code{rl_completion_entry_function} to generate matches, otherwise the
 array of strings returned will be used.
+If this function sets the @code{rl_attempted_completion_over}
+variable to a non-zero value, Readline will not perform its default
+completion even if this function returns no matches.
 @end deftypevar
 
-@deftypevar {CPFunction *} rl_filename_quoting_function
-A pointer to a function that will quote a filename in an application-
-specific fashion.  This is called if filename completion is being
+@deftypevar {rl_quote_func_t *} rl_filename_quoting_function
+A pointer to a function that will quote a filename in an
+application-specific fashion.  This is called if filename completion is being
 attempted and one of the characters in @code{rl_filename_quote_characters}
 appears in a completed filename.  The function is called with
 @var{text}, @var{match_type}, and @var{quote_pointer}.  The @var{text}
@@ -1178,7 +1481,7 @@ to any opening quote character the user 
 to reset this character.
 @end deftypevar
 
-@deftypevar {CPFunction *} rl_filename_dequoting_function
+@deftypevar {rl_dequote_func_t *} rl_filename_dequoting_function
 A pointer to a function that will remove application-specific quoting
 characters from a filename before completion is attempted, so those
 characters do not interfere with matching the text against names in
@@ -1188,10 +1491,10 @@ that delimits the filename (usually @sam
 @var{quote_char} is zero, the filename was not in an embedded string.
 @end deftypevar
 
-@deftypevar {Function *} rl_char_is_quoted_p
+@deftypevar {rl_linebuf_func_t *} rl_char_is_quoted_p
 A pointer to a function to call that determines whether or not a specific
 character in the line buffer is quoted, according to whatever quoting
-mechanism the program calling readline uses.  The function is called with
+mechanism the program calling Readline uses.  The function is called with
 two arguments: @var{text}, the text of the line, and @var{index}, the
 index of the character in the line.  It is used to decide whether a
 character found in @code{rl_completer_word_break_characters} should be
@@ -1204,36 +1507,36 @@ possible-completions call.  After that, 
 she wants to see them all.  The default value is 100.
 @end deftypevar
 
-@deftypevar {char *} rl_basic_word_break_characters
+@deftypevar {const char *} rl_basic_word_break_characters
 The basic list of characters that signal a break between words for the
 completer routine.  The default value of this variable is the characters
-which break words for completion in Bash, i.e.,
+which break words for completion in Bash:
 @code{" \t\n\"\\'`@@$><=;|&@{("}.
 @end deftypevar
 
-@deftypevar {char *} rl_basic_quote_characters
-List of quote characters which can cause a word break.
+@deftypevar {const char *} rl_basic_quote_characters
+A list of quote characters which can cause a word break.
 @end deftypevar
 
-@deftypevar {char *} rl_completer_word_break_characters
+@deftypevar {const char *} rl_completer_word_break_characters
 The list of characters that signal a break between words for
-@code{rl_complete_internal ()}.  The default list is the value of
+@code{rl_complete_internal()}.  The default list is the value of
 @code{rl_basic_word_break_characters}.
 @end deftypevar
 
-@deftypevar {char *} rl_completer_quote_characters
-List of characters which can be used to quote a substring of the line.
+@deftypevar {const char *} rl_completer_quote_characters
+A list of characters which can be used to quote a substring of the line.
 Completion occurs on the entire substring, and within the substring
 @code{rl_completer_word_break_characters} are treated as any other character,
 unless they also appear within this list.
 @end deftypevar
 
-@deftypevar {char *} rl_filename_quote_characters
+@deftypevar {const char *} rl_filename_quote_characters
 A list of characters that cause a filename to be quoted by the completer
 when they appear in a completed filename.  The default is the null string.
 @end deftypevar
 
-@deftypevar {char *} rl_special_prefixes
+@deftypevar {const char *} rl_special_prefixes
 The list of characters that are word break characters, but should be
 left in @var{text} when it is passed to the completion function.
 Programs can use this to help determine what kind of completing to do.
@@ -1252,7 +1555,8 @@ an application-specific command line syn
 @end deftypevar
 
 @deftypevar int rl_ignore_completion_duplicates
-If non-zero, then disallow duplicates in the matches.  Default is 1.
+If non-zero, then duplicates in the matches are removed.
+The default is 1.
 @end deftypevar
 
 @deftypevar int rl_filename_completion_desired
@@ -1260,8 +1564,9 @@ Non-zero means that the results of the m
 filenames.  This is @emph{always} zero on entry, and can only be changed
 within a completion entry generator function.  If it is set to a non-zero
 value, directory names have a slash appended and Readline attempts to
-quote completed filenames if they contain any embedded word break
-characters.
+quote completed filenames if they contain any characters in
+@code{rl_filename_quote_characters} and @code{rl_filename_quoting_desired}
+is set to a non-zero value.
 @end deftypevar
 
 @deftypevar int rl_filename_quoting_desired
@@ -1274,12 +1579,26 @@ function.  The quoting is effected via a
 by @code{rl_filename_quoting_function}.
 @end deftypevar
 
+@deftypevar int rl_attempted_completion_over
+If an application-specific completion function assigned to
+@code{rl_attempted_completion_function} sets this variable to a non-zero
+value, Readline will not perform its default filename completion even
+if the application's completion function returns no matches.
+It should be set only by an application's completion function.
+@end deftypevar
+
+@deftypevar int rl_completion_type
+Set to a character describing the type of completion Readline is currently
+attempting; see the description of @code{rl_complete_internal()}
+(@pxref{Completion Functions}) for the list of characters.
+@end deftypevar
+
 @deftypevar int rl_inhibit_completion
-If this variable is non-zero, completion is inhibit<ed.  The completion
+If this variable is non-zero, completion is inhibited.  The completion
 character will be inserted as any other bound to @code{self-insert}.
 @end deftypevar
 
-@deftypevar {Function *} rl_ignore_some_completions_function
+@deftypevar {rl_compignore_func_t *} rl_ignore_some_completions_function
 This function, if defined, is called by the completer when real filename
 completion is done, after all the matching names have been generated.
 It is passed a @code{NULL} terminated array of matches.
@@ -1289,14 +1608,20 @@ re-arrange the list of matches as requir
 from the array must be freed.
 @end deftypevar
 
-@deftypevar {Function *} rl_directory_completion_hook
+@deftypevar {rl_icppfunc_t *} rl_directory_completion_hook
 This function, if defined, is allowed to modify the directory portion
 of filenames Readline completes.  It is called with the address of a
-string (the current directory name) as an argument.  It could be used
-to expand symbolic links or shell variables in pathnames.
+string (the current directory name) as an argument, and may modify that string.
+If the string is replaced with a new string, the old value should be freed.
+Any modified directory name should have a trailing slash.
+The modified value will be displayed as part of the completion, replacing
+the directory portion of the pathname the user typed.
+It returns an integer that should be non-zero if the function modifies
+its directory argument.
+It could be used to expand symbolic links or shell variables in pathnames.
 @end deftypevar
 
-@deftypevar {VFunction *} rl_completion_display_matches_hook
+@deftypevar {rl_compdisp_func_t *} rl_completion_display_matches_hook
 If non-zero, then this is the address of a function to call when
 completing a word would normally display the list of possible matches.
 This function is called in lieu of Readline displaying the list.
@@ -1334,19 +1659,25 @@ history list.
 #include <readline/readline.h>
 #include <readline/history.h>
 
-extern char *getwd ();
 extern char *xmalloc ();
 
 /* The names of functions that actually do the manipulation. */
-int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
-int com_delete (), com_help (), com_cd (), com_quit ();
+int com_list __P((char *));
+int com_view __P((char *));
+int com_rename __P((char *));
+int com_stat __P((char *));
+int com_pwd __P((char *));
+int com_delete __P((char *));
+int com_help __P((char *));
+int com_cd __P((char *));
+int com_quit __P((char *));
 
 /* A structure which contains information on the commands this program
    can understand. */
 
 typedef struct @{
   char *name;			/* User printable name of the function. */
-  Function *func;		/* Function to call to do the job. */
+  rl_icpfunc_t *func;		/* Function to call to do the job. */
   char *doc;			/* Documentation for this function.  */
 @} COMMAND;
 
@@ -1362,7 +1693,7 @@ COMMAND commands[] = @{
   @{ "rename", com_rename, "Rename FILE to NEWNAME" @},
   @{ "stat", com_stat, "Print out statistics on FILE" @},
   @{ "view", com_view, "View the contents of FILE" @},
-  @{ (char *)NULL, (Function *)NULL, (char *)NULL @}
+  @{ (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL @}
 @};
 
 /* Forward declarations. */
@@ -1372,7 +1703,7 @@ COMMAND *find_command ();
 /* The name of this program, as taken from argv[0]. */
 char *progname;
 
-/* When non-zero, this global means the user is done using this program. */
+/* When non-zero, this means the user is done using this program. */
 int done;
 
 char *
@@ -1502,29 +1833,29 @@ stripwhite (string)
 /*                                                                  */
 /* **************************************************************** */
 
-char *command_generator ();
-char **fileman_completion ();
+char *command_generator __P((const char *, int));
+char **fileman_completion __P((const char *, int, int));
 
-/* Tell the GNU Readline library how to complete.  We want to try to complete
-   on command names if this is the first word in the line, or on filenames
-   if not. */
+/* Tell the GNU Readline library how to complete.  We want to try to
+   complete on command names if this is the first word in the line, or
+   on filenames if not. */
 initialize_readline ()
 @{
   /* Allow conditional parsing of the ~/.inputrc file. */
   rl_readline_name = "FileMan";
 
   /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+  rl_attempted_completion_function = fileman_completion;
 @}
 
-/* Attempt to complete on the contents of TEXT.  START and END bound the
-   region of rl_line_buffer that contains the word to complete.  TEXT is
-   the word to complete.  We can use the entire contents of rl_line_buffer
-   in case we want to do some simple parsing.  Return the array of matches,
-   or NULL if there aren't any. */
+/* Attempt to complete on the contents of TEXT.  START and END
+   bound the region of rl_line_buffer that contains the word to
+   complete.  TEXT is the word to complete.  We can use the entire
+   contents of rl_line_buffer in case we want to do some simple
+   parsing.  Returnthe array of matches, or NULL if there aren't any. */
 char **
 fileman_completion (text, start, end)
-     char *text;
+     const char *text;
      int start, end;
 @{
   char **matches;
@@ -1535,32 +1866,33 @@ fileman_completion (text, start, end)
      to complete.  Otherwise it is the name of a file in the current
      directory. */
   if (start == 0)
-    matches = completion_matches (text, command_generator);
+    matches = rl_completion_matches (text, command_generator);
 
   return (matches);
 @}
 
-/* Generator function for command completion.  STATE lets us know whether
-   to start from scratch; without any state (i.e. STATE == 0), then we
-   start at the top of the list. */
+/* Generator function for command completion.  STATE lets us
+   know whether to start from scratch; without any state
+   (i.e. STATE == 0), then we start at the top of the list. */
 char *
 command_generator (text, state)
-     char *text;
+     const char *text;
      int state;
 @{
   static int list_index, len;
   char *name;
 
-  /* If this is a new word to complete, initialize now.  This includes
-     saving the length of TEXT for efficiency, and initializing the index
-     variable to 0. */
+  /* If this is a new word to complete, initialize now.  This
+     includes saving the length of TEXT for efficiency, and
+     initializing the index variable to 0. */
   if (!state)
     @{
       list_index = 0;
       len = strlen (text);
     @}
 
-  /* Return the next name which partially matches from the command list. */
+  /* Return the next name which partially matches from the
+     command list. */
   while (name = commands[list_index].name)
     @{
       list_index++;
@@ -1705,7 +2037,7 @@ com_pwd (ignore)
 @{
   char dir[1024], *s;
 
-  s = getwd (dir);
+  s = getcwd (dir, sizeof(dir) - 1);
   if (s == 0)
     @{
       printf ("Error getting pwd: %s\n", dir);
@@ -1716,7 +2048,8 @@ com_pwd (ignore)
   return 0;
 @}
 
-/* The user wishes to quit using this program.  Just set DONE non-zero. */
+/* The user wishes to quit using this program.  Just set DONE
+   non-zero. */
 com_quit (arg)
      char *arg;
 @{
Index: readline/doc/rluser.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/rluser.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rluser.texinfo
--- readline/doc/rluser.texinfo	2003/02/16 21:36:34	1.1.1.1
+++ readline/doc/rluser.texinfo	2001/03/05 16:11:53
@@ -10,7 +10,7 @@ use these features.  There is a document
 which contains both end-user and programmer documentation for the
 GNU Readline Library.
 
-Copyright (C) 1988-1999 Free Software Foundation, Inc.
+Copyright (C) 1988-2000 Free Software Foundation, Inc.
 
 Authored by Brian Fox and Chet Ramey.
 
@@ -72,11 +72,11 @@ used by several different programs, incl
 The following paragraphs describe the notation used to represent
 keystrokes.
 
-The text @key{C-k} is read as `Control-K' and describes the character
+The text @kbd{C-k} is read as `Control-K' and describes the character
 produced when the @key{k} key is pressed while the Control key
 is depressed.
 
-The text @key{M-k} is read as `Meta-K' and describes the character
+The text @kbd{M-k} is read as `Meta-K' and describes the character
 produced when the Meta key (if you have one) is depressed, and the @key{k}
 key is pressed.
 The Meta key is labeled @key{ALT} on many keyboards.
@@ -89,11 +89,11 @@ Compose key for typing accented characte
 
 If you do not have a Meta or @key{ALT} key, or another key working as
 a Meta key, the identical keystroke can be generated by typing @key{ESC}
-@i{first}, and then typing @key{k}.
+@emph{first}, and then typing @key{k}.
 Either process is known as @dfn{metafying} the @key{k} key.
 
-The text @key{M-C-k} is read as `Meta-Control-k' and describes the
-character produced by @dfn{metafying} @key{C-k}.
+The text @kbd{M-C-k} is read as `Meta-Control-k' and describes the
+character produced by @dfn{metafying} @kbd{C-k}.
 
 In addition, several keys have their own names.  Specifically,
 @key{DEL}, @key{ESC}, @key{LFD}, @key{SPC}, @key{RET}, and @key{TAB} all
@@ -115,8 +115,8 @@ as you type it in, allowing you to just 
 you to retype the majority of the line.  Using these editing commands,
 you move the cursor to the place that needs correction, and delete or
 insert the text of the corrections.  Then, when you are satisfied with
-the line, you simply press @key{RETURN}.  You do not have to be at the
-end of the line to press @key{RETURN}; the entire line is accepted
+the line, you simply press @key{RET}.  You do not have to be at the
+end of the line to press @key{RET}; the entire line is accepted
 regardless of the location of the cursor within the line.
 
 @menu
@@ -140,9 +140,9 @@ erase character to back up and delete th
 
 Sometimes you may mistype a character, and
 not notice the error until you have typed several other characters.  In
-that case, you can type @key{C-b} to move the cursor to the left, and then
+that case, you can type @kbd{C-b} to move the cursor to the left, and then
 correct your mistake.  Afterwards, you can move the cursor to the right
-with @key{C-f}.
+with @kbd{C-f}.
 
 When you add text in the middle of a line, you will notice that characters
 to the right of the cursor are `pushed over' to make room for the text
@@ -152,17 +152,17 @@ blank space created by the removal of th
 essentials for editing the text of an input line follows.
 
 @table @asis
-@item @key{C-b}
+@item @kbd{C-b}
 Move back one character.
-@item @key{C-f}
+@item @kbd{C-f}
 Move forward one character.
 @item @key{DEL} or @key{Backspace}
 Delete the character to the left of the cursor.
-@item @key{C-d}
+@item @kbd{C-d}
 Delete the character underneath the cursor.
 @item @w{Printing characters}
 Insert the character into the line at the cursor.
-@item @key{C-_} or @key{C-x C-u}
+@item @kbd{C-_} or @kbd{C-x C-u}
 Undo the last editing command.  You can undo all the way back to an
 empty line.
 @end table
@@ -170,7 +170,7 @@ empty line.
 @noindent
 (Depending on your configuration, the @key{Backspace} key be set to
 delete the character to the left of the cursor and the @key{DEL} key set
-to delete the character underneath the cursor, like @key{C-d}, rather
+to delete the character underneath the cursor, like @kbd{C-d}, rather
 than the character to the left of the cursor.)
 
 @node Readline Movement Commands
@@ -179,11 +179,11 @@ than the character to the left of the cu
 
 The above table describes the most basic keystrokes that you need
 in order to do editing of the input line.  For your convenience, many
-other commands have been added in addition to @key{C-b}, @key{C-f},
-@key{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
+other commands have been added in addition to @kbd{C-b}, @kbd{C-f},
+@kbd{C-d}, and @key{DEL}.  Here are some commands for moving more rapidly
 about the line.
 
-@table @key
+@table @kbd
 @item C-a
 Move to the start of the line.
 @item C-e
@@ -196,7 +196,7 @@ Move backward a word.
 Clear the screen, reprinting the current line at the top.
 @end table
 
-Notice how @key{C-f} moves forward a character, while @key{M-f} moves
+Notice how @kbd{C-f} moves forward a character, while @kbd{M-f} moves
 forward a word.  It is a loose convention that control keystrokes
 operate on characters while meta keystrokes operate on words.
 
@@ -225,36 +225,36 @@ another line.
 
 Here is the list of commands for killing text.
 
-@table @key
+@table @kbd
 @item C-k
 Kill the text from the current cursor position to the end of the line.
 
 @item M-d
 Kill from the cursor to the end of the current word, or, if between
 words, to the end of the next word.
-Word boundaries are the same as those used by @key{M-f}.
+Word boundaries are the same as those used by @kbd{M-f}.
 
-@item M-DEL
+@item M-@key{DEL}
 Kill from the cursor the start of the previous word, or, if between
 words, to the start of the previous word.
-Word boundaries are the same as those used by @key{M-b}.
+Word boundaries are the same as those used by @kbd{M-b}.
 
 @item C-w
 Kill from the cursor to the previous whitespace.  This is different than
-@key{M-DEL} because the word boundaries differ.
+@kbd{M-@key{DEL}} because the word boundaries differ.
 
 @end table
 
 Here is how to @dfn{yank} the text back into the line.  Yanking
 means to copy the most-recently-killed text from the kill buffer.
 
-@table @key
+@table @kbd
 @item C-y
 Yank the most recently killed text back into the buffer at the cursor.
 
 @item M-y
 Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is @key{C-y} or @key{M-y}.
+the prior command is @kbd{C-y} or @kbd{M-y}.
 @end table
 
 @node Readline Arguments
@@ -272,7 +272,8 @@ digits before the command.  If the first
 sign (@samp{-}), then the sign of the argument will be negative.  Once
 you have typed one meta digit to get the argument started, you can type
 the remainder of the digits, and then the command.  For example, to give
-the @key{C-d} command an argument of 10, you could type @samp{M-1 0 C-d}.
+the @kbd{C-d} command an argument of 10, you could type @samp{M-1 0 C-d},
+which will delete the next ten characters on the input line.
 
 @node Searching
 @subsection Searching for Commands in the History
@@ -282,7 +283,7 @@ Readline provides commands for searching
 (@pxref{Bash History Facilities})
 @end ifset
 for lines containing a specified string.
-There are two search modes:  @var{incremental} and @var{non-incremental}.
+There are two search modes:  @dfn{incremental} and @dfn{non-incremental}.
 
 Incremental searches begin before the user has finished typing the
 search string.
@@ -291,23 +292,25 @@ the next entry from the history matching
 An incremental search requires only as many characters as needed to
 find the desired history entry.
 To search backward in the history for a particular string, type
-@key{C-r}.  Typing @key{C-s} searches forward through the history.
+@kbd{C-r}.  Typing @kbd{C-s} searches forward through the history.
 The characters present in the value of the @code{isearch-terminators} variable
 are used to terminate an incremental search.
 If that variable has not been assigned a value, the @key{ESC} and
-@key{C-J} characters will terminate an incremental search.
-@key{C-g} will abort an incremental search and restore the original line.
+@kbd{C-J} characters will terminate an incremental search.
+@kbd{C-g} will abort an incremental search and restore the original line.
 When the search is terminated, the history entry containing the
 search string becomes the current line.
 
-To find other matching entries in the history list, type @key{C-r} or
-@key{C-s} as appropriate.
+To find other matching entries in the history list, type @kbd{C-r} or
+@kbd{C-s} as appropriate.
 This will search backward or forward in the history for the next
 entry matching the search string typed so far.
 Any other key sequence bound to a Readline command will terminate
 the search and execute that command.
 For instance, a @key{RET} will terminate the search and accept
 the line, thereby executing the command from the history list.
+A movement command will terminate the search, make the last line found
+the current line, and begin editing.
 
 Non-incremental searches read the entire search string before starting
 to search for matching history lines.  The search string may be
@@ -324,10 +327,10 @@ Any user can customize programs that use
 commands in an @dfn{inputrc} file, conventionally in his home directory.
 The name of this
 @ifset BashFeatures
-file is taken from the value of the shell variable @code{INPUTRC}.  If
+file is taken from the value of the shell variable @env{INPUTRC}.  If
 @end ifset
 @ifclear BashFeatures
-file is taken from the value of the environment variable @code{INPUTRC}.  If
+file is taken from the value of the environment variable @env{INPUTRC}.  If
 @end ifclear
 that variable is unset, the default is @file{~/.inputrc}.
 
@@ -359,7 +362,15 @@ denote variable settings and key binding
 @item Variable Settings
 You can modify the run-time behavior of Readline by
 altering the values of variables in Readline
-using the @code{set} command within the init file.  Here is how to
+using the @code{set} command within the init file.
+The syntax is simple:
+
+@example
+set @var{variable} @var{value}
+@end example
+
+@noindent
+Here, for example, is how to
 change from the default Emacs-like key binding to use
 @code{vi} line editing commands:
 
@@ -367,6 +378,9 @@ change from the default Emacs-like key b
 set editing-mode vi
 @end example
 
+Variable names and values, where appropriate, are recognized without regard
+to case. 
+
 @ifset BashFeatures
 The @w{@code{bind -V}} command lists the current Readline variable names
 and values.  @xref{Bash Builtins}.
@@ -375,6 +389,7 @@ and values.  @xref{Bash Builtins}.
 A great deal of run-time behavior is changeable with the following
 variables.
 
+@cindex variables, readline
 @table @code
 
 @item bell-style
@@ -402,13 +417,14 @@ The number of possible completions that 
 asked whether he wants to see the list of possibilities.  If the
 number of possible completions is greater than this value,
 Readline will ask the user whether or not he wishes to view
-them; otherwise, they are simply listed.  The default limit is
-@code{100}.
+them; otherwise, they are simply listed.
+This variable must be set to an integer value greater than or equal to 0.
+The default limit is @code{100}.
 
 @item convert-meta
 @vindex convert-meta
 If set to @samp{on}, Readline will convert characters with the
-eighth bit set to an ASCII key sequence by stripping the eighth
+eighth bit set to an @sc{ascii} key sequence by stripping the eighth
 bit and prefixing an @key{ESC} character, converting them to a
 meta-prefixed key sequence.  The default value is @samp{on}.
 
@@ -448,7 +464,7 @@ this variable is set to @samp{off}.
 @vindex input-meta
 @vindex meta-flag
 If set to @samp{on}, Readline will enable eight-bit input (it
-will not strip the eighth bit from the characters it reads),
+will not clear the eighth bit in the characters it reads),
 regardless of what the terminal claims it can support.  The
 default value is @samp{off}.  The name @code{meta-flag} is a
 synonym for this variable.
@@ -458,7 +474,7 @@ synonym for this variable.
 The string of characters that should terminate an incremental search without
 subsequently executing the character as a command (@pxref{Searching}).
 If this variable has not been given a value, the characters @key{ESC} and
-@key{C-J} will terminate an incremental search.
+@kbd{C-J} will terminate an incremental search.
 
 @item keymap
 @vindex keymap
@@ -469,6 +485,7 @@ Acceptable @code{keymap} names are
 @code{emacs-meta},
 @code{emacs-ctlx},
 @code{vi},
+@code{vi-move},
 @code{vi-command}, and
 @code{vi-insert}.
 @code{vi} is equivalent to @code{vi-command}; @code{emacs} is
@@ -520,11 +537,15 @@ want to change.  The following sections 
 name, the default keybinding, if any, and a short description of what
 the command does.
 
-Once you know the name of the command, simply place the name of the key
+Once you know the name of the command, simply place on a line
+in the init file the name of the key
 you wish to bind the command to, a colon, and then the name of the
-command on a line in the init file.  The name of the key
-can be expressed in different ways, depending on which is most
-comfortable for you.
+command.  The name of the key
+can be expressed in different ways, depending on what you find most
+comfortable.
+
+In addition to command names, readline allows keys to be bound
+to a string that is inserted when the key is pressed (a @var{macro}).
 
 @ifset BashFeatures
 The @w{@code{bind -p}} command displays Readline function names and
@@ -541,11 +562,28 @@ Meta-Rubout: backward-kill-word
 Control-o: "> output"
 @end example
 
-In the above example, @key{C-u} is bound to the function
-@code{universal-argument}, and @key{C-o} is bound to run the macro
+In the above example, @kbd{C-u} is bound to the function
+@code{universal-argument},
+@kbd{M-DEL} is bound to the function @code{backward-kill-word}, and
+@kbd{C-o} is bound to run the macro
 expressed on the right hand side (that is, to insert the text
 @samp{> output} into the line).
 
+A number of symbolic character names are recognized while
+processing this key binding syntax:
+@var{DEL},
+@var{ESC},
+@var{ESCAPE},
+@var{LFD},
+@var{NEWLINE},
+@var{RET},
+@var{RETURN},
+@var{RUBOUT},
+@var{SPACE},
+@var{SPC},
+and
+@var{TAB}.
+
 @item @w{"@var{keyseq}": @var{function-name} or @var{macro}}
 @var{keyseq} differs from @var{keyname} above in that strings
 denoting an entire key sequence can be specified, by placing
@@ -559,9 +597,9 @@ special character names are not recogniz
 "\e[11~": "Function Key 1"
 @end example
 
-In the above example, @key{C-u} is bound to the function
+In the above example, @kbd{C-u} is again bound to the function
 @code{universal-argument} (just as it was in the first example),
-@samp{@key{C-x} @key{C-r}} is bound to the function @code{re-read-init-file},
+@samp{@kbd{C-x} @kbd{C-r}} is bound to the function @code{re-read-init-file},
 and @samp{@key{ESC} @key{[} @key{1} @key{1} @key{~}} is bound to insert
 the text @samp{Function Key 1}.
 
@@ -606,10 +644,10 @@ horizontal tab
 @item \v
 vertical tab
 @item \@var{nnn}
-the character whose @code{ASCII} code is the octal value @var{nnn}
+the character whose @sc{ascii} code is the octal value @var{nnn}
 (one to three digits)
 @item \x@var{nnn}
-the character whose @code{ASCII} code is the hexadecimal value @var{nnn}
+the character whose @sc{ascii} code is the hexadecimal value @var{nnn}
 (one to three digits)
 @end table
 
@@ -619,7 +657,7 @@ Unquoted text is assumed to be a functio
 In the macro body, the backslash escapes described above are expanded.
 Backslash will quote any other character in the macro text,
 including @samp{"} and @samp{'}.
-For example, the following binding will make @samp{C-x \}
+For example, the following binding will make @samp{@kbd{C-x} \}
 insert a single @samp{\} into the line:
 @example
 "\C-x\\": "\\"
@@ -663,7 +701,8 @@ for instance.
 @item application
 The @var{application} construct is used to include
 application-specific settings.  Each program using the Readline
-library sets the @var{application name}, and you can test for it. 
+library sets the @var{application name}, and you can test for
+a particular value. 
 This could be used to bind key sequences to functions useful for
 a specific program.  For instance, the following command adds a
 key sequence that quotes the current or previous word in Bash:
@@ -686,6 +725,7 @@ the test fails.
 @item $include
 This directive takes a single filename as an argument and reads commands
 and bindings from that file.
+For example, the following directive reads from @file{/etc/inputrc}:
 @example
 $include /etc/inputrc
 @end example
@@ -694,7 +734,7 @@ $include /etc/inputrc
 @node Sample Init File
 @subsection Sample Init File
 
-Here is an example of an inputrc file.  This illustrates key
+Here is an example of an @var{inputrc} file.  This illustrates key
 binding, variable assignment, and conditional syntax.
 
 @example
@@ -759,11 +799,10 @@ TAB: complete
 $if Bash
 # edit the path
 "\C-xp": "PATH=$@{PATH@}\e\C-e\C-a\ef\C-f"
-# prepare to type a quoted word -- insert open and close
-# double quotes and move to just after the open quote
+# prepare to type a quoted word -- insert open and close double quotes
+# and move to just after the open quote
 "\C-x\"": "\"\"\C-b"
-# insert a backslash (testing backslash escapes in sequences
-# and macros)
+# insert a backslash (testing backslash escapes in sequences and macros)
 "\C-x\\": "\\"
 # Quote the current or previous word
 "\C-xq": "\eb\"\ef\""
@@ -820,12 +859,12 @@ You can list your key bindings by execut
 @w{@code{bind -P}} or, for a more terse format, suitable for an
 @var{inputrc} file, @w{@code{bind -p}}.  (@xref{Bash Builtins}.)
 @end ifset
-
 Command names without an accompanying key sequence are unbound by default.
-In the following descriptions, @var{point} refers to the current cursor
-position, and @var{mark} refers to a cursor position saved by the
+
+In the following descriptions, @dfn{point} refers to the current cursor
+position, and @dfn{mark} refers to a cursor position saved by the
 @code{set-mark} command.
-The text between the point and mark is referred to as the @var{region}.
+The text between the point and mark is referred to as the @dfn{region}.
 
 @node Commands For Moving
 @subsection Commands For Moving
@@ -863,25 +902,29 @@ Refresh the current line.  By default, t
 @subsection Commands For Manipulating The History
 
 @ftable @code
-@item accept-line (Newline, Return)
+@item accept-line (Newline or Return)
 @ifset BashFeatures
-Accept the line regardless of where the cursor is.  If this line is
+Accept the line regardless of where the cursor is.
+If this line is
 non-empty, add it to the history list according to the setting of
-the @code{HISTCONTROL} and @code{HISTIGNORE} variables.
-If this line was a history line, then restore the history line to its
-original state.
+the @env{HISTCONTROL} and @env{HISTIGNORE} variables.
+If this line is a modified history line, then restore the history line
+to its original state.
 @end ifset
 @ifclear BashFeatures
-Accept the line regardless of where the cursor is.  If this line is
-non-empty, add it to the history list.  If this line was a history
-line, then restore the history line to its original state.
+Accept the line regardless of where the cursor is.
+If this line is
+non-empty, it may be added to the history list for future recall with
+@code{add_history()}.
+If this line is a modified history line, the history line is restored
+to its original state.
 @end ifclear
 
 @item previous-history (C-p)
-Move `up' through the history list.
+Move `back' through the history list, fetching the previous command.
 
 @item next-history (C-n)
-Move `down' through the history list.
+Move `forward' through the history list, fetching the next command.
 
 @item beginning-of-history (M-<)
 Move to the first line in the history.
@@ -921,12 +964,13 @@ is a non-incremental search.  By default
 
 @item yank-nth-arg (M-C-y)
 Insert the first argument to the previous command (usually
-the second word on the previous line).  With an argument @var{n},
+the second word on the previous line) at point.
+With an argument @var{n},
 insert the @var{n}th word from the previous command (the words
 in the previous command begin with word 0).  A negative argument
 inserts the @var{n}th word from the end of the previous command.
 
-@item yank-last-arg (M-., M-_)
+@item yank-last-arg (M-. or M-_)
 Insert last argument to the previous command (the last word of the
 previous history entry).  With an
 argument, behave exactly like @code{yank-nth-arg}.
@@ -940,10 +984,10 @@ list, inserting the last argument of eac
 
 @ftable @code
 @item delete-char (C-d)
-Delete the character under the cursor.  If the cursor is at the
+Delete the character at point.  If point is at the
 beginning of the line, there are no characters in the line, and
 the last character typed was not bound to @code{delete-char}, then
-return @code{EOF}.
+return @sc{eof}.
 
 @item backward-delete-char (Rubout)
 Delete the character behind the cursor.  A numeric argument means
@@ -954,16 +998,16 @@ Delete the character under the cursor, u
 end of the line, in which case the character behind the cursor is
 deleted.  By default, this is not bound to a key.
 
-@item quoted-insert (C-q, C-v)
+@item quoted-insert (C-q or C-v)
 Add the next character typed to the line verbatim.  This is
-how to insert key sequences like @key{C-q}, for example.
+how to insert key sequences like @kbd{C-q}, for example.
 
 @ifclear BashFeatures
-@item tab-insert (M-TAB)
+@item tab-insert (M-@key{TAB})
 Insert a tab character.
 @end ifclear
 
-@item self-insert (a, b, A, 1, !, ...)
+@item self-insert (a, b, A, 1, !, @dots{})
 Insert yourself.
 
 @item transpose-chars (C-t)
@@ -1007,7 +1051,7 @@ Kill backward to the beginning of the li
 Kill backward from the cursor to the beginning of the current line.
 
 @item kill-whole-line ()
-Kill all characters on the current line, no matter point is.
+Kill all characters on the current line, no matter where point is.
 By default, this is unbound.
 
 @item kill-word (M-d)
@@ -1015,7 +1059,7 @@ Kill from point to the end of the curren
 words, to the end of the next word.
 Word boundaries are the same as @code{forward-word}.
 
-@item backward-kill-word (M-DEL)
+@item backward-kill-word (M-@key{DEL})
 Kill the word behind point.
 Word boundaries are the same as @code{backward-word}.
 
@@ -1045,21 +1089,20 @@ The word boundaries are the same as @cod
 By default, this command is unbound.
 
 @item yank (C-y)
-Yank the top of the kill ring into the buffer at the current
-cursor position.
+Yank the top of the kill ring into the buffer at point.
 
 @item yank-pop (M-y)
 Rotate the kill-ring, and yank the new top.  You can only do this if
-the prior command is yank or yank-pop.
+the prior command is @code{yank} or @code{yank-pop}.
 @end ftable
 
 @node Numeric Arguments
 @subsection Specifying Numeric Arguments
 @ftable @code
 
-@item digit-argument (M-0, M-1, ... M--)
+@item digit-argument (@kbd{M-0}, @kbd{M-1}, @dots{} @kbd{M--})
 Add this digit to the argument already accumulating, or start a new
-argument.  @key{M--} starts a negative argument.
+argument.  @kbd{M--} starts a negative argument.
 
 @item universal-argument ()
 This is another way to specify an argument.
@@ -1080,13 +1123,9 @@ By default, this is not bound to a key.
 @subsection Letting Readline Type For You
 
 @ftable @code
-@item complete (TAB)
-Attempt to do completion on the text before the cursor.  This is
-application-specific.  Generally, if you are typing a filename
-argument, you can do filename completion; if you are typing a command,
-you can do command completion; if you are typing in a symbol to GDB, you
-can do symbol name completion; if you are typing in a variable to Bash,
-you can do variable name completion, and so on.
+@item complete (@key{TAB})
+Attempt to perform completion on the text before point.
+The actual completion performed is application-specific.
 @ifset BashFeatures
 Bash attempts completion treating the text as a variable (if the
 text begins with @samp{$}), username (if the text begins with
@@ -1094,9 +1133,12 @@ text begins with @samp{$}), username (if
 command (including aliases and functions) in turn.  If none 
 of these produces a match, filename completion is attempted.
 @end ifset
+@ifclear BashFeatures
+The default is filename completion.
+@end ifclear
 
 @item possible-completions (M-?)
-List the possible completions of the text before the cursor.
+List the possible completions of the text before point.
 
 @item insert-completions (M-*)
 Insert all completions of the text before point that would have
@@ -1107,12 +1149,13 @@ Similar to @code{complete}, but replaces
 with a single match from the list of possible completions.
 Repeated execution of @code{menu-complete} steps through the list
 of possible completions, inserting each match in turn.
-At the end of the list of completions, the bell is rung and the
-original text is restored.
+At the end of the list of completions, the bell is rung
+(subject to the setting of @code{bell-style})
+and the original text is restored.
 An argument of @var{n} moves @var{n} positions forward in the list
 of matches; a negative argument may be used to move backward
 through the list.
-This command is intended to be bound to @code{TAB}, but is unbound
+This command is intended to be bound to @key{TAB}, but is unbound
 by default.
 
 @item delete-char-or-list ()
@@ -1165,7 +1208,7 @@ in that order.
 List the possible completions of the text before point,
 treating it as a command name.
 
-@item dynamic-complete-history (M-TAB)
+@item dynamic-complete-history (M-@key{TAB})
 Attempt completion on the text before point, comparing
 the text against lines from the history list for possible
 completion matches.
@@ -1212,12 +1255,12 @@ ring the terminal's bell (subject to the
 If the metafied character @var{x} is lowercase, run the command
 that is bound to the corresponding uppercase character.
 
-@item prefix-meta (ESC)
-Make the next character typed be metafied.  This is for keyboards
-without a meta key.  Typing @samp{ESC f} is equivalent to typing
-@samp{M-f}.
+@item prefix-meta (@key{ESC})
+Metafy the next character typed.  This is for keyboards
+without a meta key.  Typing @samp{@key{ESC} f} is equivalent to typing
+@kbd{M-f}.
 
-@item undo (C-_, C-x C-u)
+@item undo (C-_ or C-x C-u)
 Incremental undo, separately remembered for each line.
 
 @item revert-line (M-r)
@@ -1233,7 +1276,7 @@ command enough times to get back to the 
 Perform tilde expansion on the current word.
 
 @item set-mark (C-@@)
-Set the mark to the current point.  If a
+Set the mark to the point.  If a
 numeric argument is supplied, the mark is set to that position.
 
 @item exchange-point-and-mark (C-x C-x)
@@ -1272,7 +1315,7 @@ of an @var{inputrc} file.  This command 
 
 @item dump-macros ()
 Print all of the Readline key sequences bound to macros and the
-strings they ouput.  If a numeric argument is supplied,
+strings they output.  If a numeric argument is supplied,
 the output is formatted in such a way that it can be made part
 of an @var{inputrc} file.  This command is unbound by default.
 
@@ -1306,7 +1349,7 @@ Perform alias expansion on the current l
 @item history-and-alias-expand-line ()
 Perform history and alias expansion on the current line.
 
-@item insert-last-argument (M-., M-_)
+@item insert-last-argument (M-. or M-_)
 A synonym for @code{yank-last-arg}.
 
 @item operate-and-get-next (C-o)
@@ -1329,7 +1372,7 @@ been executed.
 While the Readline library does not have a full set of @code{vi}
 editing functions, it does contain enough to allow simple editing
 of the line.  The Readline @code{vi} mode behaves as specified in
-the @sc{POSIX} 1003.2 standard.
+the @sc{posix} 1003.2 standard.
 
 @ifset BashFeatures
 In order to switch interactively between @code{emacs} and @code{vi}
@@ -1338,7 +1381,8 @@ commands (@pxref{The Set Builtin}).
 @end ifset
 @ifclear BashFeatures
 In order to switch interactively between @code{emacs} and @code{vi}
-editing modes, use the command M-C-j (toggle-editing-mode).
+editing modes, use the command @kbd{M-C-j} (bound to emacs-editing-mode
+when in @code{vi} mode and to vi-editing-mode in @code{emacs} mode).
 @end ifclear
 The Readline default is @code{emacs} mode.
 
@@ -1375,20 +1419,20 @@ described above (@pxref{Commands For Com
 First, the actions specified by the compspec are used.
 Only matches which are prefixed by the word being completed are
 returned.
-When the @samp{-f} or @samp{-d} option is used for filename or
-directory name completion, the shell variable @code{FIGNORE} is
+When the @option{-f} or @option{-d} option is used for filename or
+directory name completion, the shell variable @env{FIGNORE} is
 used to filter the matches.
-@xref{Bash Variables}, for a description of @code{FIGNORE}.
+@xref{Bash Variables}, for a description of @env{FIGNORE}.
 
 Any completions specified by a filename expansion pattern to the
-@samp{-G} option are generated next.
+@option{-G} option are generated next.
 The words generated by the pattern need not match the word being completed.
-The @code{GLOBIGNORE} shell variable is not used to filter the matches,
-but the @code{FIGNORE} shell variable is used.
+The @env{GLOBIGNORE} shell variable is not used to filter the matches,
+but the @env{FIGNORE} shell variable is used.
 
-Next, the string specified as the argument to the @samp{-W} option
+Next, the string specified as the argument to the @option{-W} option
 is considered.
-The string is first split using the characters in the @code{IFS}
+The string is first split using the characters in the @env{IFS}
 special variable as delimiters.
 Shell quoting is honored.
 Each word is then expanded using
@@ -1401,12 +1445,12 @@ The results of the expansion are prefix-
 completed, and the matching words become the possible completions.
 
 After these matches have been generated, any shell function or command
-specified with the @samp{-F} and @samp{-C} options is invoked.
-When the command or function is invoked, the @code{COMP_LINE} and
-@code{COMP_POINT} variables are assigned values as described above
+specified with the @option{-F} and @option{-C} options is invoked.
+When the command or function is invoked, the @env{COMP_LINE} and
+@env{COMP_POINT} variables are assigned values as described above
 (@pxref{Bash Variables}).
-If a shell function is being invoked, the @code{COMP_WORDS} and
-@code{COMP_CWORD} variables are also set.
+If a shell function is being invoked, the @env{COMP_WORDS} and
+@env{COMP_CWORD} variables are also set.
 When the function or command is invoked, the first argument is the
 name of the command whose arguments are being completed, the
 second argument is the word being completed, and the third argument
@@ -1415,21 +1459,21 @@ No filtering of the generated completion
 is performed; the function or command has complete freedom in generating
 the matches.
 
-Any function specified with @samp{-F} is invoked first.
+Any function specified with @option{-F} is invoked first.
 The function may use any of the shell facilities, including the
 @code{compgen} builtin described below
 (@pxref{Programmable Completion Builtins}), to generate the matches.
-It must put the possible completions in the @code{COMPREPLY} array
+It must put the possible completions in the @env{COMPREPLY} array
 variable.
 
-Next, any command specified with the @samp{-C} option is invoked
+Next, any command specified with the @option{-C} option is invoked
 in an environment equivalent to command substitution.
 It should print a list of completions, one per line, to
 the standard output.
 Backslash may be used to escape a newline, if necessary.
 
 After all of the possible completions are generated, any filter
-specified with the @samp{-X} option is applied to the list.
+specified with the @option{-X} option is applied to the list.
 The filter is a pattern as used for pathname expansion; a @samp{&}
 in the pattern is replaced with the text of the word being completed.
 A literal @samp{&} may be escaped with a backslash; the backslash
@@ -1438,15 +1482,22 @@ Any completion that matches the pattern 
 A leading @samp{!} negates the pattern; in this case any completion
 not matching the pattern will be removed.
 
-Finally, any prefix and suffix specified with the @samp{-P} and @samp{-S}
+Finally, any prefix and suffix specified with the @option{-P} and @option{-S}
 options are added to each member of the completion list, and the result is
 returned to the Readline completion code as the list of possible
 completions.
 
-If a compspec is found, whatever it generates is returned to the completion
-code as the full set of possible completions.
-The default Bash completions are not attempted, and the Readline
-default of filename completion is disabled.
+If the previously-applied actions do not generate any matches, and the
+@option{-o dirnames} option was supplied to @code{complete} when the
+compspec was defined, directory name completion is attempted. 
+
+By default, if a compspec is found, whatever it generates is returned to
+the completion code as the full set of possible completions.
+The default Bash completions are not attempted, and the Readline default
+of filename completion is disabled.
+If the @option{-o default} option was supplied to @code{complete} when the
+compspec was defined, Readline's default completion will be performed
+if the compspec generates no matches.
 
 @node Programmable Completion Builtins
 @section Programmable Completion Builtins
@@ -1465,9 +1516,9 @@ facilities.
 Generate possible completion matches for @var{word} according to
 the @var{option}s, which may be any option accepted by the
 @code{complete}
-builtin with the exception of @samp{-p} and @samp{-r}, and write
+builtin with the exception of @option{-p} and @option{-r}, and write
 the matches to the standard output.
-When using the @samp{-F} or @samp{-C} options, the various shell variables
+When using the @option{-F} or @option{-C} options, the various shell variables
 set by the programmable completion facilities, while available, will not
 have useful values.
 
@@ -1483,17 +1534,17 @@ matches were generated.
 @item complete
 @btindex complete
 @example
-@code{complete [-abcdefjkvu] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
+@code{complete [-abcdefjkvu] [-o @var{comp-option}] [-A @var{action}] [-G @var{globpat}] [-W @var{wordlist}]
 [-P @var{prefix}] [-S @var{suffix}] [-X @var{filterpat}] [-F @var{function}]
 [-C @var{command}] @var{name} [@var{name} @dots{}]}
 @code{complete -pr [@var{name} @dots{}]}
 @end example
 
 Specify how arguments to each @var{name} should be completed.
-If the @samp{-p} option is supplied, or if no options are supplied, existing
+If the @option{-p} option is supplied, or if no options are supplied, existing
 completion specifications are printed in a way that allows them to be
 reused as input.
-The @samp{-r} option removes a completion specification for
+The @option{-r} option removes a completion specification for
 each @var{name}, or, if no @var{name}s are supplied, all
 completion specifications.
 
@@ -1501,19 +1552,40 @@ The process of applying these completion
 is attempted is described above (@pxref{Programmable Completion}).
 
 Other options, if specified, have the following meanings.
-The arguments to the @samp{-G}, @samp{-W}, and @samp{-X} options
-(and, if necessary, the @samp{-P} and @samp{-S} options)
+The arguments to the @option{-G}, @option{-W}, and @option{-X} options
+(and, if necessary, the @option{-P} and @option{-S} options)
 should be quoted to protect them from expansion before the
 @code{complete} builtin is invoked.
 
+
+@table @code
+@item -o @var{comp-option}
+The @var{comp-option} controls several aspects of the compspec's behavior
+beyond the simple generation of completions.
+@var{comp-option} may be one of: 
+
 @table @code
+
+@item default
+Use readline's default completion if the compspec generates no matches.
+
+@item dirnames
+Perform directory name completion if the compspec generates no matches.
+
+@item filenames
+Tell Readline that the compspec generates filenames, so it can perform any
+filename\-specific processing (like adding a slash to directory names or
+suppressing trailing spaces).  This option is intended to be used with
+shell functions specified with @option{-F}.
+@end table
+
 @item -A @var{action}
 The @var{action} may be one of the following to generate a list of possible
 completions:
 
 @table @code
 @item alias
-Alias names.  May also be specified as @samp{-a}.
+Alias names.  May also be specified as @option{-a}.
 
 @item arrayvar
 Array variable names.
@@ -1522,13 +1594,13 @@ Array variable names.
 Readline key binding names (@pxref{Bindable Readline Commands}).
 
 @item builtin
-Names of shell builtin commands.  May also be specified as @samp{-b}.
+Names of shell builtin commands.  May also be specified as @option{-b}.
 
 @item command
-Command names.  May also be specified as @samp{-c}.
+Command names.  May also be specified as @option{-c}.
 
 @item directory
-Directory names.  May also be specified as @samp{-d}.
+Directory names.  May also be specified as @option{-d}.
 
 @item disabled
 Names of disabled shell builtins.
@@ -1537,10 +1609,10 @@ Names of disabled shell builtins.
 Names of enabled shell builtins.
 
 @item export
-Names of exported shell variables.  May also be specified as @samp{-e}.
+Names of exported shell variables.  May also be specified as @option{-e}.
 
 @item file
-File names.  May also be specified as @samp{-f}.
+File names.  May also be specified as @option{-f}.
 
 @item function
 Names of shell functions.
@@ -1550,19 +1622,19 @@ Help topics as accepted by the @code{hel
 
 @item hostname
 Hostnames, as taken from the file specified by the
-@code{HOSTFILE} shell variable (@pxref{Bash Variables}).
+@env{HOSTFILE} shell variable (@pxref{Bash Variables}).
 
 @item job
-Job names, if job control is active.  May also be specified as @samp{-j}.
+Job names, if job control is active.  May also be specified as @option{-j}.
 
 @item keyword
-Shell reserved words.  May also be specified as @samp{-k}.
+Shell reserved words.  May also be specified as @option{-k}.
 
 @item running
 Names of running jobs, if job control is active.
 
 @item setopt
-Valid arguments for the @samp{-o} option to the @code{set} builtin
+Valid arguments for the @option{-o} option to the @code{set} builtin
 (@pxref{The Set Builtin}).
 
 @item shopt
@@ -1576,10 +1648,10 @@ Signal names.
 Names of stopped jobs, if job control is active.
 
 @item user
-User names.  May also be specified as @samp{-u}.
+User names.  May also be specified as @option{-u}.
 
 @item variable
-Names of all shell variables.  May also be specified as @samp{-v}.
+Names of all shell variables.  May also be specified as @option{-v}.
 @end table
 
 @item -G @var{globpat}
@@ -1588,7 +1660,7 @@ the possible completions.
 
 @item -W @var{wordlist}
 The @var{wordlist} is split using the characters in the
-@code{IFS} special variable as delimiters, and each resultant word
+@env{IFS} special variable as delimiters, and each resultant word
 is expanded.
 The possible completions are the members of the resultant list which
 match the word being completed.
@@ -1601,7 +1673,7 @@ used as the possible completions.
 The shell function @var{function} is executed in the current shell
 environment.
 When it finishes, the possible completions are retrieved from the value
-of the @code{COMPREPLY} array variable.
+of the @env{COMPREPLY} array variable.
 
 @item -X @var{filterpat}
 @var{filterpat} is a pattern as used for filename expansion.
@@ -1621,7 +1693,7 @@ after all other options have been applie
 @end table
 
 The return value is true unless an invalid option is supplied, an option
-other than @samp{-p} or @samp{-r} is supplied without a @var{name}
+other than @option{-p} or @option{-r} is supplied without a @var{name}
 argument, an attempt is made to remove a completion specification for
 a @var{name} for which no specification exists, or
 an error occurs adding a completion specification.
Index: readline/doc/rluserman.texinfo
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/rluserman.texinfo,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rluserman.texinfo
--- readline/doc/rluserman.texinfo	2003/02/16 21:36:34	1.1.1.1
+++ readline/doc/rluserman.texinfo	2001/02/02 16:59:01
@@ -10,14 +10,14 @@
 @ifinfo
 @dircategory Libraries
 @direntry
-* Readline: (readline).       The GNU readline library API
+* RLuserman: (rluserman).       The GNU readline library User's Manual.
 @end direntry
 
 This document describes the end user interface of the GNU Readline Library,
 a utility which aids in the consistency of user interface across discrete
 programs that need to provide a command line interface.
 
-Copyright (C) 1988-1999 Free Software Foundation, Inc.
+Copyright (C) 1988-2001 Free Software Foundation, Inc.
 
 Permission is granted to make and distribute verbatim copies of
 this manual provided the copyright notice and this permission notice
@@ -72,7 +72,7 @@ except that this permission notice may b
 by the Free Software Foundation.
 
 @vskip 0pt plus 1filll
-Copyright @copyright{} 1988-1999 Free Software Foundation, Inc.
+Copyright @copyright{} 1988-2001 Free Software Foundation, Inc.
 @end titlepage
 
 @ifinfo
Index: readline/doc/texi2dvi
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/doc/texi2dvi,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 texi2dvi
--- readline/doc/texi2dvi	2003/02/16 21:36:34	1.1.1.1
+++ readline/doc/texi2dvi	1998/04/27 16:00:44
@@ -1,6 +1,6 @@
 #! /bin/sh
 # texi2dvi --- smartly produce DVI files from texinfo sources
-# $Id: texi2dvi,v 1.1.1.1 2003/02/16 21:36:34 BoydE Exp $
+# $Id: texi2dvi,v 0.8 1998/02/26 21:13:13 karl Exp $
 #
 # Copyright (C) 1992, 93, 94, 95, 96, 97, 98 Free Software Foundation, Inc.
 #
@@ -45,7 +45,7 @@
 progname=`echo "$0" | sed -e 's/[^\/]*\///g'`
 
 # This string is expanded by rcs automatically when this file is checked out.
-rcs_revision='$Revision: 1.1.1.1 $'
+rcs_revision='$Revision: 0.8 $'
 version=`set - $rcs_revision; echo $2`
 
 # To prevent hairy quoting and escaping later.
Index: readline/examples/Makefile.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/Makefile.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 Makefile.in
--- readline/examples/Makefile.in	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/Makefile.in	2001/04/02 18:27:34
@@ -16,6 +16,7 @@
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the Free Software
 # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111 USA.
+RL_LIBRARY_VERSION = @LIBVERSION@
 
 SHELL = @MAKE_SHELL@
 RM = rm -f
@@ -28,7 +29,7 @@ BUILD_DIR = .
 DEFS = @DEFS@
 CC = @CC@
 CFLAGS = @CFLAGS@
-LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DREADLINE_LIBRARY
+LOCAL_CFLAGS = @LOCAL_CFLAGS@ -DREADLINE_LIBRARY -DRL_LIBRARY_VERSION='"$(RL_LIBRARY_VERSION)"'
 CPPFLAGS = @CPPFLAGS@
 
 INCLUDES = -I$(srcdir) -I$(top_srcdir) -I..
@@ -45,10 +46,11 @@ TERMCAP_LIB = @TERMCAP_LIB@
 	${RM} $@
 	$(CC) $(CCFLAGS) -c $<
 
-EXECUTABLES = fileman rltest rl rlversion
-OBJECTS = fileman.o rltest.o rl.o rlversion.o
+EXECUTABLES = fileman rltest rl rlversion histexamp
+OBJECTS = fileman.o rltest.o rl.o rlversion.o histexamp.o
 
 all: $(EXECUTABLES)
+everything: all rlfe
 
 rl: rl.o
 	$(CC) $(LDFLAGS) -o $@ rl.o -lreadline $(TERMCAP_LIB)
@@ -62,9 +64,13 @@ rltest: rltest.o
 rlversion: rlversion.o $(READLINE_LIB)
 	$(CC) $(LDFLAGS) -o $@ rlversion.o -lreadline $(TERMCAP_LIB)
 
+histexamp: histexamp.o $(HISTORY_LIB)
+	$(CC) $(LDFLAGS) -o $@ histexamp.o -lhistory $(TERMCAP_LIB)
+
 clean mostlyclean:
 	$(RM) $(OBJECTS)
 	$(RM) $(EXECUTABLES) *.exe
+	$(RM) rlfe.o rlfe
 
 distclean maintainer-clean: clean
 	$(RM) Makefile
@@ -73,6 +79,13 @@ fileman.o: fileman.c
 rltest.o: rltest.c
 rl.o: rl.c
 rlversion.o: rlversion.c
+histexamp.o: histexamp.c
+
+fileman.o: $(top_srcdir)/readline.h
+rltest.o: $(top_srcdir)/readline.h
+rl.o: $(top_srcdir)/readline.h
+rlversion.o: $(top_srcdir)/readline.h
+histexamp.o: $(top_srcdir)/history.h
 
 # Stuff for Per Bothner's `rlfe' program
  
Index: readline/examples/excallback.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/excallback.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 excallback.c
--- readline/examples/excallback.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/excallback.c	2000/07/10 14:52:46
@@ -153,6 +153,8 @@ process_line(char *line)
   } else {
     fprintf(stderr, "|%s|\n", line);
   }
+
+  free (line);
 }
 
 int
Index: readline/examples/fileman.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/fileman.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 fileman.c
--- readline/examples/fileman.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/fileman.c	2003/02/17 12:47:09
@@ -41,15 +41,22 @@
 extern char *xmalloc ();
 
 /* The names of functions that actually do the manipulation. */
-int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
-int com_delete (), com_help (), com_cd (), com_quit ();
+int com_list __P((char *));
+int com_view __P((char *));
+int com_rename __P((char *));
+int com_stat __P((char *));
+int com_pwd __P((char *));
+int com_delete __P((char *));
+int com_help __P((char *));
+int com_cd __P((char *));
+int com_quit __P((char *));
 
 /* A structure which contains information on the commands this program
    can understand. */
 
 typedef struct {
   char *name;			/* User printable name of the function. */
-  Function *func;		/* Function to call to do the job. */
+  rl_icpfunc_t *func;		/* Function to call to do the job. */
   char *doc;			/* Documentation for this function.  */
 } COMMAND;
 
@@ -65,7 +72,7 @@ COMMAND commands[] = {
   { "rename", com_rename, "Rename FILE to NEWNAME" },
   { "stat", com_stat, "Print out statistics on FILE" },
   { "view", com_view, "View the contents of FILE" },
-  { (char *)NULL, (Function *)NULL, (char *)NULL }
+  { (char *)NULL, (rl_icpfunc_t *)NULL, (char *)NULL }
 };
 
 /* Forward declarations. */
@@ -205,8 +212,8 @@ stripwhite (string)
 /*                                                                  */
 /* **************************************************************** */
 
-char *command_generator ();
-char **fileman_completion ();
+char *command_generator __P((const char *, int));
+char **fileman_completion __P((const char *, int, int));
 
 /* Tell the GNU Readline library how to complete.  We want to try to complete
    on command names if this is the first word in the line, or on filenames
@@ -217,7 +224,7 @@ initialize_readline ()
   rl_readline_name = "FileMan";
 
   /* Tell the completer that we want a crack first. */
-  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
+  rl_attempted_completion_function = fileman_completion;
 }
 
 /* Attempt to complete on the contents of TEXT.  START and END bound the
@@ -227,7 +234,7 @@ initialize_readline ()
    or NULL if there aren't any. */
 char **
 fileman_completion (text, start, end)
-     char *text;
+     const char *text;
      int start, end;
 {
   char **matches;
@@ -238,7 +245,7 @@ fileman_completion (text, start, end)
      to complete.  Otherwise it is the name of a file in the current
      directory. */
   if (start == 0)
-    matches = completion_matches (text, command_generator);
+    matches = rl_completion_matches (text, command_generator);
 
   return (matches);
 }
@@ -248,7 +255,7 @@ fileman_completion (text, start, end)
    start at the top of the list. */
 char *
 command_generator (text, state)
-     char *text;
+     const char *text;
      int state;
 {
   static int list_index, len;
@@ -292,8 +299,11 @@ com_list (arg)
 {
   if (!arg)
     arg = "";
-
+#ifdef __MSDOS__
+  sprintf (syscom, "dir %s", arg);
+#else
   sprintf (syscom, "ls -FClg %s", arg);
+#endif
   return (system (syscom));
 }
 
Index: readline/examples/histexamp.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/histexamp.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 histexamp.c
--- readline/examples/histexamp.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/histexamp.c	2001/02/06 15:35:21
@@ -1,4 +1,14 @@
-main ()
+#include <stdio.h>
+
+#ifdef READLINE_LIBRARY
+#  include "history.h"
+#else
+#  include <readline/history.h>
+#endif
+
+main (argc, argv)
+     int argc;
+     char **argv;
 {
   char line[1024], *t;
   int len, done = 0;
Index: readline/examples/manexamp.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/manexamp.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 manexamp.c
--- readline/examples/manexamp.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/manexamp.c	2001/02/02 17:14:15
@@ -3,10 +3,9 @@
 #include <stdio.h>
 #include <readline/readline.h>
 
-
 /* **************************************************************** */
 /*                                                                  */
-*   			How to Emulate gets ()			    */
+/*   			How to Emulate gets ()			    */
 /*                                                                  */
 /* **************************************************************** */
 
@@ -82,13 +81,12 @@ invert_case_line (count, key)
 
   for (; start != end; start += direction)
     {
-      if (uppercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = to_lower (rl_line_buffer[start]);
-      else if (lowercase_p (rl_line_buffer[start]))
-	rl_line_buffer[start] = to_upper (rl_line_buffer[start]);
+      if (_rl_uppercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = _rl_to_lower (rl_line_buffer[start]);
+      else if (_rl_lowercase_p (rl_line_buffer[start]))
+	rl_line_buffer[start] = _rl_to_upper (rl_line_buffer[start]);
     }
 
   /* Move point to on top of the last character changed. */
   rl_point = end - direction;
 }
-
Index: readline/examples/rl.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/rl.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rl.c
--- readline/examples/rl.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/rl.c	2000/11/01 19:04:30
@@ -38,7 +38,7 @@ set_deftext ()
     {
       rl_insert_text (deftext);
       deftext = (char *)NULL;
-      rl_startup_hook = (Function *)NULL;
+      rl_startup_hook = (rl_hook_func_t *)NULL;
     }
   return 0;
 }
@@ -126,6 +126,6 @@ main (argc, argv)
   if (temp == 0)
     exit (1);
 
-  puts (temp);
+  printf ("%s\n", temp);
   exit (0);
 }
Index: readline/examples/rlfe.c
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/examples/rlfe.c,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 rlfe.c
--- readline/examples/rlfe.c	2003/02/16 21:36:34	1.1.1.1
+++ readline/examples/rlfe.c	2000/11/17 21:16:24
@@ -64,6 +64,8 @@
 #include <unistd.h>
 #include <sys/ioctl.h>
 #include <termios.h>
+#include <limits.h>
+#include <dirent.h>
 
 #ifdef READLINE_LIBRARY
 #  include "readline.h"
@@ -81,6 +83,7 @@
 #endif
 
 #ifndef HAVE_MEMMOVE
+#ifndef memmove
 #  if __GNUC__ > 1
 #    define memmove(d, s, n)	__builtin_memcpy(d, s, n)
 #  else
@@ -89,9 +92,20 @@
 #else
 #  define memmove(d, s, n)	memcpy(d, s, n)
 #endif
+#endif
+
+#define APPLICATION_NAME "Rlfe"
+
+#ifndef errno
+extern int errno;
+#endif
 
-#define APPLICATION_NAME "Fep"
+extern int optind;
+extern char *optarg;
 
+static char *progname;
+static char *progversion;
+
 static int in_from_inferior_fd;
 static int out_to_inferior_fd;
 
@@ -109,14 +123,16 @@ static int out_to_inferior_fd;
 char echo_suppress_buffer[ECHO_SUPPRESS_MAX];
 int echo_suppress_start = 0;
 int echo_suppress_limit = 0;
+
+/* #define DEBUG */
 
-#define DEBUG
+static FILE *logfile = NULL;
 
 #ifdef DEBUG
-FILE *logfile = NULL;
-#define DPRINT0(FMT) (fprintf(logfile, FMT), fflush(logfile))
-#define DPRINT1(FMT, V1) (fprintf(logfile, FMT, V1), fflush(logfile))
-#define DPRINT2(FMT, V1, V2) (fprintf(logfile, FMT, V1, V2), fflush(logfile))
+FILE *debugfile = NULL;
+#define DPRINT0(FMT) (fprintf(debugfile, FMT), fflush(debugfile))
+#define DPRINT1(FMT, V1) (fprintf(debugfile, FMT, V1), fflush(debugfile))
+#define DPRINT2(FMT, V1, V2) (fprintf(debugfile, FMT, V1, V2), fflush(debugfile))
 #else
 #define DPRINT0(FMT) /* Do nothing */
 #define DPRINT1(FMT, V1) /* Do nothing */
@@ -125,6 +141,10 @@ FILE *logfile = NULL;
 
 struct termios orig_term;
 
+static int rlfe_directory_completion_hook __P((char **));
+static int rlfe_directory_rewrite_hook __P((char **));
+static char *rlfe_filename_completion_function __P((const char *, int));
+
 /* Pid of child process. */
 static pid_t child = -1;
 
@@ -370,13 +390,20 @@ my_rl_getc (FILE *dummy)
   return ch;
 }
 
+static void
+usage()
+{
+  fprintf (stderr, "%s: usage: %s [-l filename] [-a] [-n appname] [-hv] [command [arguments...]]\n",
+		   progname, progname);
+}
+
 int
 main(int argc, char** argv)
 {
   char *path;
-  int i;
+  int i, append;
   int master;
-  char *name;
+  char *name, *logfname, *appname;
   int in_from_tty_fd;
   struct sigaction act;
   struct winsize ws;
@@ -387,12 +414,58 @@ main(int argc, char** argv)
   char *prompt = empty_string;
   int ioctl_err = 0;
 
+  if ((progname = strrchr (argv[0], '/')) == 0)
+    progname = argv[0];
+  else
+    progname++;
+  progversion = RL_LIBRARY_VERSION;
+
+  append = 0;
+  appname = APPLICATION_NAME;
+  logfname = (char *)NULL;
+
+  while ((i = getopt (argc, argv, "ahl:n:v")) != EOF)
+    {
+      switch (i)
+	{
+	case 'l':
+	  logfname = optarg;
+	  break;
+	case 'n':
+	  appname = optarg;
+	  break;
+	case 'a':
+	  append = 1;
+	  break;
+	case 'h':
+	  usage ();
+	  exit (0);
+	case 'v':
+	  fprintf (stderr, "%s version %s\n", progname, progversion);
+	  exit (0);
+	default:
+	  usage ();
+	  exit (2);
+	}
+    }
+
+  argc -= optind;
+  argv += optind;
+
+  if (logfname)
+    {
+      logfile = fopen (logfname, append ? "a" : "w");
+      if (logfile == 0)
+	fprintf (stderr, "%s: warning: could not open log file %s: %s\n",
+			 progname, logfname, strerror (errno));
+    }
+    
+  rl_readline_name = appname;
+  
 #ifdef DEBUG
-  logfile = fopen("LOG", "w");
+  debugfile = fopen("LOG", "w");
 #endif
 
-  rl_readline_name = APPLICATION_NAME;
-  
   if ((master = get_master_pty(&name)) < 0)
     {
       perror("ptypair: could not open master pty");
@@ -486,10 +559,10 @@ main(int argc, char** argv)
       /* now start the shell */
       {
 	static char* command_args[] = { COMMAND_ARGS, NULL };
-	if (argc <= 1)
+	if (argc < 1)
 	  execvp(COMMAND, command_args);
 	else
-	  execvp(argv[1], &argv[1]);
+	  execvp(argv[0], &argv[0]);
       }
 
       /* should never be reached */
@@ -535,6 +608,13 @@ main(int argc, char** argv)
   rl_deprep_term_function = null_deprep_terminal; 
   rl_callback_handler_install (prompt, line_handler);
 
+#if 1
+  rl_directory_completion_hook = rlfe_directory_completion_hook;
+  rl_completion_entry_function = rlfe_filename_completion_function;
+#else
+  rl_directory_rewrite_hook = rlfe_directory_rewrite_hook;
+#endif
+
   in_from_tty_fd = STDIN_FILENO;
   FD_ZERO (&in_set);
   maxfd = in_from_inferior_fd > in_from_tty_fd ? in_from_inferior_fd
@@ -644,6 +724,47 @@ main(int argc, char** argv)
 	    }
 	  old_count = buf_count;
 
+	  /* Do some minimal carriage return translation and backspace
+	     processing before logging the input line. */
+	  if (logfile)
+	    {
+#ifndef __GNUC__
+	      char *b;
+#else
+	      char b[count + 1];
+#endif
+	      int i, j;
+
+#ifndef __GNUC__
+	      b = malloc (count + 1);
+	      if (b) {
+#endif
+	      for (i = 0; i < count; i++)
+	        b[i] = buf[buf_count + i];
+	      b[i] = '\0';
+	      for (i = j = 0; i <= count; i++)
+		{
+		  if (b[i] == '\r')
+		    {
+		      if (b[i+1] != '\n')
+		        b[j++] = '\n';
+		    }
+		  else if (b[i] == '\b')
+		    {
+		      if (i)
+			j--;
+		    }
+		  else
+		    b[j++] = b[i];
+		}
+	      fprintf (logfile, "%s", b);
+
+#ifndef __GNUC__
+	      free (b);
+	      }
+#endif
+	    }
+
           /* Look for any pending echo that we need to suppress. */
 	  while (echo_suppress_start < echo_suppress_limit
 		 && count > 0
@@ -682,4 +803,240 @@ main(int argc, char** argv)
 	  DPRINT2("-> i: %d, buf_count: %d\n", i, buf_count);
 	}
     }
+}
+
+/*
+ *
+ * FILENAME COMPLETION FOR RLFE
+ *
+ */
+
+#ifndef PATH_MAX
+#  define PATH_MAX 1024
+#endif
+
+#define DIRSEP		'/'
+#define ISDIRSEP(x)	((x) == '/')
+#define PATHSEP(x)	(ISDIRSEP(x) || (x) == 0)
+
+#define DOT_OR_DOTDOT(x) \
+	((x)[0] == '.' && (PATHSEP((x)[1]) || \
+			  ((x)[1] == '.' && PATHSEP((x)[2]))))
+
+#define FREE(x)		if (x) free(x)
+
+#define STRDUP(s, x)	do { \
+			  s = strdup (x);\
+			  if (s == 0) \
+			    return ((char *)NULL); \
+			} while (0)
+
+static int
+get_inferior_cwd (path, psize)
+     char *path;
+     size_t psize;
+{
+  int n;
+  static char procfsbuf[PATH_MAX] = { '\0' };
+
+  if (procfsbuf[0] == '\0')
+    sprintf (procfsbuf, "/proc/%d/cwd", (int)child);
+  n = readlink (procfsbuf, path, psize);
+  if (n < 0)
+    return n;
+  if (n > psize)
+    return -1;
+  path[n] = '\0';
+  return n;
+}
+
+static int
+rlfe_directory_rewrite_hook (dirnamep)
+     char **dirnamep;
+{
+  char *ldirname, cwd[PATH_MAX], *retdir, *ld;
+  int n, ldlen;
+
+  ldirname = *dirnamep;
+
+  if (*ldirname == '/')
+    return 0;
+
+  n = get_inferior_cwd (cwd, sizeof(cwd) - 1);
+  if (n < 0)
+    return 0;
+  if (n == 0)	/* current directory */
+    {
+      cwd[0] = '.';
+      cwd[1] = '\0';
+      n = 1;
+    }
+
+  /* Minimally canonicalize ldirname by removing leading `./' */
+  for (ld = ldirname; *ld; )
+    {
+      if (ISDIRSEP (ld[0]))
+	ld++;
+      else if (ld[0] == '.' && PATHSEP(ld[1]))
+	ld++;
+      else
+	break;
+    }
+  ldlen = (ld && *ld) ? strlen (ld) : 0;
+
+  retdir = (char *)malloc (n + ldlen + 3);
+  if (retdir == 0)
+    return 0;
+  if (ldlen)
+    sprintf (retdir, "%s/%s", cwd, ld);
+  else
+    strcpy (retdir, cwd);
+  free (ldirname);
+
+  *dirnamep = retdir;
+
+  DPRINT1("rl_directory_rewrite_hook returns %s\n", retdir);
+  return 1;
+}
+
+/* Translate *DIRNAMEP to be relative to the inferior's CWD.  Leave a trailing
+   slash on the result. */
+static int
+rlfe_directory_completion_hook (dirnamep)
+     char **dirnamep;
+{
+  char *ldirname, *retdir;
+  int n, ldlen;
+
+  ldirname = *dirnamep;
+
+  if (*ldirname == '/')
+    return 0;
+
+  n = rlfe_directory_rewrite_hook (dirnamep);
+  if (n == 0)
+    return 0;
+
+  ldirname = *dirnamep;
+  ldlen = (ldirname && *ldirname) ? strlen (ldirname) : 0;
+
+  if (ldlen == 0 || ldirname[ldlen - 1] != '/')
+    {
+      retdir = (char *)malloc (ldlen + 3);
+      if (retdir == 0)
+	return 0;
+      if (ldlen)
+	strcpy (retdir, ldirname);
+      else
+	retdir[ldlen++] = '.';
+      retdir[ldlen] = '/';
+      retdir[ldlen+1] = '\0';
+      free (ldirname);
+
+      *dirnamep = retdir;
+    }
+
+  DPRINT1("rl_directory_completion_hook returns %s\n", retdir);
+  return 1;
+}
+
+static char *
+rlfe_filename_completion_function (text, state)
+     const char *text;
+     int state;
+{
+  static DIR *directory;
+  static char *filename = (char *)NULL;
+  static char *dirname = (char *)NULL, *ud = (char *)NULL;
+  static int flen, udlen;
+  char *temp;
+  struct dirent *dentry;
+
+  if (state == 0)
+    {
+      if (directory)
+	{
+	  closedir (directory);
+	  directory = 0;
+	}
+      FREE (dirname);
+      FREE (filename);
+      FREE (ud);
+
+      if (text && *text)
+        STRDUP (filename, text);
+      else
+	{
+	  filename = malloc(1); 
+	  if (filename == 0)
+	    return ((char *)NULL);
+	  filename[0] = '\0';
+	}
+      dirname = (text && *text) ? strdup (text) : strdup (".");
+      if (dirname == 0)
+        return ((char *)NULL);
+
+      temp = strrchr (dirname, '/');
+      if (temp)
+	{
+	  strcpy (filename, ++temp);
+	  *temp = '\0';
+	}
+      else
+	{
+	  dirname[0] = '.';
+	  dirname[1] = '\0';
+	}
+
+      STRDUP (ud, dirname);
+      udlen = strlen (ud);
+
+      rlfe_directory_completion_hook (&dirname);
+
+      directory = opendir (dirname);
+      flen = strlen (filename);
+
+      rl_filename_completion_desired = 1;
+    }
+
+  dentry = 0;
+  while (directory && (dentry = readdir (directory)))
+    {
+      if (flen == 0)
+	{
+          if (DOT_OR_DOTDOT(dentry->d_name) == 0)
+            break;
+	}
+      else
+	{
+	  if ((dentry->d_name[0] == filename[0]) &&
+	      (strlen (dentry->d_name) >= flen) &&
+	      (strncmp (filename, dentry->d_name, flen) == 0))
+	    break;
+	}
+    }
+
+  if (dentry == 0)
+    {
+      if (directory)
+	{
+	  closedir (directory);
+	  directory = 0;
+	}
+      FREE (dirname);
+      FREE (filename);
+      FREE (ud);
+      dirname = filename = ud = 0;
+      return ((char *)NULL);
+    }
+
+  if (ud == 0 || (ud[0] == '.' && ud[1] == '\0'))
+    temp = strdup (dentry->d_name);
+  else
+    {
+      temp = malloc (1 + udlen + strlen (dentry->d_name));
+      strcpy (temp, ud);
+      strcpy (temp + udlen, dentry->d_name);
+    }
+  return (temp);
 }
Index: readline/shlib/Makefile.in
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/shlib/Makefile.in,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 Makefile.in
--- readline/shlib/Makefile.in	2003/02/16 21:36:34	1.1.1.1
+++ readline/shlib/Makefile.in	2000/11/27 17:03:27
@@ -36,6 +36,7 @@ ARFLAGS = @ARFLAGS@
 RM = rm -f
 CP = cp
 MV = mv
+LN = ln
 
 SHELL = @MAKE_SHELL@
 
@@ -43,6 +44,7 @@ host_os = @host_os@
 
 prefix = @prefix@
 exec_prefix = @exec_prefix@
+includedir = @includedir@
 libdir = @libdir@
 
 CFLAGS = @CFLAGS@
@@ -108,7 +110,8 @@ CSOURCES = $(topdir)/readline.c $(topdir
 	   $(topdir)/callback.c $(topdir)/terminal.c $(topdir)/xmalloc.c \
 	   $(topdir)/history.c $(topdir)/histsearch.c $(topdir)/histexpand.c \
 	   $(topdir)/histfile.c $(topdir)/nls.c $(topdir)/search.c \
-	   $(topdir)/shell.c $(topdir)/savestring.c $(topdir)/tilde.c
+	   $(topdir)/shell.c $(topdir)/savestring.c $(topdir)/compat.c \
+	   $(topdir)/tilde.c
 
 # The header files for this library.
 HSOURCES = readline.h rldefs.h chardefs.h keymaps.h history.h histlib.h \
@@ -120,7 +123,7 @@ SHARED_TILDEOBJ = tilde.so
 SHARED_OBJ = readline.so vi_mode.so funmap.so keymaps.so parens.so search.so \
 	  rltty.so complete.so bind.so isearch.so display.so signals.so \
 	  util.so kill.so undo.so macro.so input.so callback.so terminal.so \
-	  nls.so xmalloc.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ)
+	  nls.so xmalloc.so $(SHARED_HISTOBJ) $(SHARED_TILDEOBJ) compat.so
 
 ##########################################################################
 
@@ -173,90 +176,108 @@ force:
 bind.so: $(topdir)/ansi_stdlib.h $(topdir)/posixstat.h
 bind.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 bind.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+bind.so: $(topdir)/rltypedefs.h
 bind.so: $(topdir)/tilde.h $(topdir)/history.h
+compat.so: $(topdir)/rlstdc.h
 callback.so: $(topdir)/rlconf.h
 callback.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h
 callback.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+callback.so: $(topdir)/rltypedefs.h
 callback.so: $(topdir)/tilde.h
 complete.so: $(topdir)/ansi_stdlib.h posixdir.h $(topdir)/posixstat.h
 complete.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 complete.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+complete.so: $(topdir)/rltypedefs.h
 complete.so: $(topdir)/tilde.h
 display.so: $(topdir)/ansi_stdlib.h $(topdir)/posixstat.h
 display.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 display.so: $(topdir)/tcap.h
 display.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+display.so: $(topdir)/rltypedefs.h
 display.so: $(topdir)/tilde.h $(topdir)/history.h
 funmap.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+funmap.so: $(topdir)/rltypedefs.h
 funmap.so: $(topdir)/rlconf.h $(topdir)/ansi_stdlib.h
 funmap.so: ${BUILD_DIR}/config.h $(topdir)/tilde.h
 histexpand.so: $(topdir)/ansi_stdlib.h
-histexpand.so: $(topdir)/history.h histlib.h
+histexpand.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
 histexpand.so: ${BUILD_DIR}/config.h
 histfile.so: $(topdir)/ansi_stdlib.h
-histfile.so: $(topdir)/history.h histlib.h
+histfile.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
 histfile.so: ${BUILD_DIR}/config.h
 history.so: $(topdir)/ansi_stdlib.h
-history.so: $(topdir)/history.h histlib.h
+history.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
 history.so: ${BUILD_DIR}/config.h
 histsearch.so: $(topdir)/ansi_stdlib.h
-histsearch.so: $(topdir)/history.h histlib.h
+histsearch.so: $(topdir)/history.h $(topdir)/histlib.h $(topdir)/rltypedefs.h
 histsearch.so: ${BUILD_DIR}/config.h
 input.so: $(topdir)/ansi_stdlib.h
 input.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 input.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+input.so: $(topdir)/rltypedefs.h
 input.so: $(topdir)/tilde.h
 isearch.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 isearch.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+isearch.so: $(topdir)/rltypedefs.h
 isearch.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h
 keymaps.so: emacs_keymap.c vi_keymap.c
 keymaps.so: $(topdir)/keymaps.h $(topdir)/chardefs.h $(topdir)/rlconf.h
 keymaps.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+keymaps.so: $(topdir)/rltypedefs.h
 keymaps.so: ${BUILD_DIR}/config.h $(topdir)/ansi_stdlib.h $(topdir)/tilde.h
 kill.so: $(topdir)/ansi_stdlib.h
 kill.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 kill.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-kill.so: $(topdir)/tilde.h $(topdir)/history.h
+kill.so: $(topdir)/tilde.h $(topdir)/history.h  $(topdir)/rltypedefs.h
 macro.so: $(topdir)/ansi_stdlib.h
 macro.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 macro.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-macro.so: $(topdir)/tilde.h $(topdir)/history.h
+macro.so: $(topdir)/tilde.h $(topdir)/history.h $(topdir)/rltypedefs.h
 nls.so: $(topdir)/ansi_stdlib.h
 nls.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 nls.o: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+nls.o: $(topdir)/rltypedefs.h
 nls.o: $(topdir)/tilde.h $(topdir)/history.h $(topdir)/rlstdc.h  
 parens.so: $(topdir)/rlconf.h ${BUILD_DIR}/config.h
 parens.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+parens.so: $(topdir)/rltypedefs.h
 parens.so: $(topdir)/tilde.h
 readline.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
 readline.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
+readline.so: $(topdir)/rltypedefs.h
 readline.so: $(topdir)/history.h $(topdir)/tilde.h
 readline.so: $(topdir)/posixstat.h $(topdir)/ansi_stdlib.h $(topdir)/posixjmp.h
 rltty.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 rltty.so: $(topdir)/rltty.h $(topdir)/tilde.h
 rltty.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+rltty.so: $(topdir)/rltypedefs.h
 search.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 search.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
 search.so: $(topdir)/ansi_stdlib.h $(topdir)/history.h $(topdir)/tilde.h
+search.so: $(topdir)/rltypedefs.h
 signals.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 signals.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
 signals.so: $(topdir)/history.h $(topdir)/tilde.h
+signals.so: $(topdir)/rltypedefs.h
 terminal.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 terminal.so: $(topdir)/tcap.h
 terminal.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
 terminal.so: $(topdir)/tilde.h $(topdir)/history.h
+terminal.so: $(topdir)/rltypedefs.h
 tilde.so: $(topdir)/ansi_stdlib.h ${BUILD_DIR}/config.h $(topdir)/tilde.h
 undo.so: $(topdir)/ansi_stdlib.h
 undo.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 undo.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
+undo.so: $(topdir)/rltypedefs.h
 undo.so: $(topdir)/tilde.h $(topdir)/history.h
 util.so: $(topdir)/posixjmp.h $(topdir)/ansi_stdlib.h
 util.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 util.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
-util.so: $(topdir)/tilde.h
+util.so: $(topdir)/rltypedefs.h $(topdir)/tilde.h
 vi_mode.so: $(topdir)/rldefs.h ${BUILD_DIR}/config.h $(topdir)/rlconf.h
 vi_mode.so: $(topdir)/readline.h $(topdir)/keymaps.h $(topdir)/chardefs.h
 vi_mode.so: $(topdir)/history.h $(topdir)/ansi_stdlib.h $(topdir)/tilde.h
+vi_mode.so: $(topdir)/rltypedefs.h
 xmalloc.so: ${BUILD_DIR}/config.h
 xmalloc.so: $(topdir)/ansi_stdlib.h
 
@@ -315,6 +336,7 @@ keymaps.so: $(topdir)/keymaps.c
 parens.so: $(topdir)/parens.c
 search.so: $(topdir)/search.c
 rltty.so: $(topdir)/rltty.c
+compat.so: $(topdir)/compat.c
 complete.so: $(topdir)/complete.c
 bind.so: $(topdir)/bind.c
 isearch.so: $(topdir)/isearch.c
@@ -344,6 +366,7 @@ keymaps.so: keymaps.c
 parens.so: parens.c
 search.so: search.c
 rltty.so: rltty.c
+comapt.so: compat.c
 complete.so: complete.c
 bind.so: bind.c
 isearch.so: isearch.c
Index: readline/support/config.guess
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/support/config.guess,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 config.guess
--- readline/support/config.guess	2003/02/16 21:36:34	1.1.1.1
+++ readline/support/config.guess	2000/12/18 15:43:18
@@ -1,10 +1,7 @@
 #! /bin/sh
 # Attempt to guess a canonical system name.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002 Free Software Foundation, Inc.
-
-timestamp='2002-02-19'
-
+#   Copyright (C) 1992, 1993, 1994, 1995, 1996 Free Software Foundation, Inc.
+#
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
 # the Free Software Foundation; either version 2 of the License, or
@@ -24,281 +21,256 @@ timestamp='2002-02-19'
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Originally written by Per Bothner <per@bothner.com>.
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
+# Written by Per Bothner <bothner@cygnus.com>.
+# The master version of this file is at the FSF in /home/gd/gnu/lib.
 #
 # This script attempts to guess a canonical system name similar to
 # config.sub.  If it succeeds, it prints the system name on stdout, and
 # exits with 0.  Otherwise, it exits with 1.
 #
 # The plan is that this can be called by configure scripts if you
-# don't specify an explicit build system type.
-
-me=`echo "$0" | sed -e 's,.*/,,'`
-
-usage="\
-Usage: $0 [OPTION]
-
-Output the configuration name of the system \`$me' is run on.
+# don't specify an explicit system type (host/target name).
+#
+# Only a few systems have been added to this list; please add others
+# (but try to keep the structure clean).
+#
 
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.guess ($timestamp)
-
-Originally written by Per Bothner.
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
-    --version | -v )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help" >&2
-       exit 1 ;;
-    * )
-       break ;;
-  esac
-done
-
-if test $# != 0; then
-  echo "$me: too many arguments$help" >&2
-  exit 1
+# Use $HOST_CC if defined. $CC may point to a cross-compiler
+if test x"$CC_FOR_BUILD" = x; then
+  if test x"$HOST_CC" != x; then
+    CC_FOR_BUILD="$HOST_CC"
+  else
+    if test x"$CC" != x; then
+      CC_FOR_BUILD="$CC"
+    else
+      CC_FOR_BUILD=cc
+    fi
+  fi
 fi
 
-
-dummy=dummy-$$
-trap 'rm -f $dummy.c $dummy.o $dummy.rel $dummy; exit 1' 1 2 15
-
-# CC_FOR_BUILD -- compiler used by this script.
-# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
-# use `HOST_CC' if defined, but it is deprecated.
-
-set_cc_for_build='case $CC_FOR_BUILD,$HOST_CC,$CC in
- ,,)    echo "int dummy(){}" > $dummy.c ;
-	for c in cc gcc c89 ; do
-	  ($c $dummy.c -c -o $dummy.o) >/dev/null 2>&1 ;
-	  if test $? = 0 ; then
-	     CC_FOR_BUILD="$c"; break ;
-	  fi ;
-	done ;
-	rm -f $dummy.c $dummy.o $dummy.rel ;
-	if test x"$CC_FOR_BUILD" = x ; then
-	  CC_FOR_BUILD=no_compiler_found ;
-	fi
-	;;
- ,,*)   CC_FOR_BUILD=$CC ;;
- ,*,*)  CC_FOR_BUILD=$HOST_CC ;;
-esac'
-
 # This is needed to find uname on a Pyramid OSx when run in the BSD universe.
-# (ghazi@noc.rutgers.edu 1994-08-24)
+# (ghazi@noc.rutgers.edu 8/24/94.)
 if (test -f /.attbin/uname) >/dev/null 2>&1 ; then
 	PATH=$PATH:/.attbin ; export PATH
+elif (test -f /usr/5bin/uname) >/dev/null 2>&1 ; then
+	PATH=$PATH:/usr/5bin
 fi
 
+UNAME=`(uname) 2>/dev/null` || UNAME=unknown
 UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
 UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
-UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null` || UNAME_SYSTEM=unknown
 UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
 
+RELEASE=`expr "$UNAME_RELEASE" : '[^0-9]*\([0-9]*\)'` # 4
+case "$RELEASE" in
+"")	RELEASE=0 ;;
+*)	RELEASE=`expr "$RELEASE" + 0` ;;
+esac
+REL_LEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.\([0-9]*\)'`    # 1
+REL_SUBLEVEL=`expr "$UNAME_RELEASE" : '[^0-9]*[0-9]*.[0-9]*.\([0-9]*\)'` # 2
+
+dummy=dummy-$$
+trap 'rm -f $dummy.c $dummy.o $dummy; exit 1' 1 2 15
+
+# Some versions of i386 SVR4.2 make `uname' equivalent to `uname -n', which
+# is contrary to all other versions of uname
+if [ -n "$UNAME" ] && [ "$UNAME_S" != "$UNAME" ] && [ "$UNAME_S" = UNIX_SV ]; then
+	UNAME=UNIX_SV
+fi
+
 # Note: order is significant - the case branches are not exclusive.
 
 case "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" in
-    *:NetBSD:*:*)
-	# NetBSD (nbsd) targets should (where applicable) match one or
-	# more of the tupples: *-*-netbsdelf*, *-*-netbsdaout*,
-	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
-	# switched to ELF, *-*-netbsd* would select the old
-	# object file format.  This provides both forward
-	# compatibility and a consistent mechanism for selecting the
-	# object file format.
-	#
-	# Note: NetBSD doesn't particularly care about the vendor
-	# portion of the name.  We always set it to "unknown".
-	UNAME_MACHINE_ARCH=`(uname -p) 2>/dev/null` || \
-	    UNAME_MACHINE_ARCH=unknown
-	case "${UNAME_MACHINE_ARCH}" in
-	    arm*) machine=arm-unknown ;;
-	    sh3el) machine=shl-unknown ;;
-	    sh3eb) machine=sh-unknown ;;
-	    *) machine=${UNAME_MACHINE_ARCH}-unknown ;;
-	esac
-	# The Operating System including object format, if it has switched
-	# to ELF recently, or will in the future.
-	case "${UNAME_MACHINE_ARCH}" in
-	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
-		eval $set_cc_for_build
-		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
-			| grep __ELF__ >/dev/null
-		then
-		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
-		    # Return netbsd for either.  FIX?
-		    os=netbsd
-		else
-		    os=netbsdelf
-		fi
-		;;
-	    *)
-	        os=netbsd
-		;;
-	esac
-	# The OS release
-	release=`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
-	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
-	# contains redundant information, the shorter form:
-	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
-	echo "${machine}-${os}${release}"
+    # Begin cases added for Bash
+    alpha:NetBSD:*:*)
+	echo alpha-dec-netbsd${UNAME_RELEASE}
 	exit 0 ;;
-    amiga:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+    alpha:OpenBSD:*:*)
+	echo alpha-dec-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    arc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+    i?86:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
-    hp300:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+    i?86:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-pc-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
-    mac68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+    sparc:NetBSD:*:*)
+	echo sparc-unknown-netbsd${UNAME_RELEASE}
 	exit 0 ;;
-    macppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+    sparc:OpenBSD:*:*)
+	echo sparc-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    mvme68k:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+    vax:NetBSD:*:*)
+	echo vax-dec-netbsd${UNAME_RELEASE}
 	exit 0 ;;
-    mvme88k:OpenBSD:*:*)
-	echo m88k-unknown-openbsd${UNAME_RELEASE}
+    vax:OpenBSD:*:*)
+	echo vax-dec-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    mvmeppc:OpenBSD:*:*)
-	echo powerpc-unknown-openbsd${UNAME_RELEASE}
+    mac68k:machten:*:*)
+	echo mac68k-apple-machten${UNAME_RELEASE}
 	exit 0 ;;
-    pmax:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+    concurrent*:*:*:*)
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo concurrent-concurrent-sysv3
+	else
+		echo concurrent-concurrent-bsd
+	fi
 	exit 0 ;;
-    sgi:OpenBSD:*:*)
-	echo mipseb-unknown-openbsd${UNAME_RELEASE}
+    ppc*:SunOS:5.*:*)
+	echo ppc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
-    sun3:OpenBSD:*:*)
-	echo m68k-unknown-openbsd${UNAME_RELEASE}
+    sparc:UNIX_SV:4.*:*)
+	echo sparc-unknown-sysv${UNAME_RELEASE}
 	exit 0 ;;
-    wgrisc:OpenBSD:*:*)
-	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+    mips:UNIX_SV:4.*:*)
+	echo mips-mips-sysv${UNAME_RELEASE}
 	exit 0 ;;
-    *:OpenBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-openbsd${UNAME_RELEASE}
+    mips:OSF*1:*:*)
+	echo mips-mips-osf1
+	exit 0 ;;
+    mips:4.4BSD:*:*)
+	echo mips-mips-bsd4.4
+	exit 0 ;;
+    MIServer-S:SMP_DC.OSx:*:dcosx)
+	echo mips-pyramid-sysv4
+	exit 0 ;;
+    news*:NEWS*:*:*)
+	echo mips-sony-newsos${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:NEXTSTEP:*:*)
+	echo i386-next-nextstep${RELEASE}
+	exit 0 ;;
+    *680?0:NEXTSTEP:*:*)
+	echo m68k-next-nextstep${RELEASE}
+	exit 0 ;;    
+    *370:AIX:*:*)
+	echo ibm370-ibm-aix
+	exit 0 ;;
+    ksr1:OSF*1:*:*)
+	echo ksr1-ksr-osf1
+	exit 0 ;;
+    esa:OSF*1:*:* | ESA:OSF*:*:*)
+	echo esa-ibm-osf1
+	exit 0 ;;
+    DNP*:DNIX:*:*)
+	echo m68k-dnix-sysv
+	exit 0 ;;
+    *3b2*:*:*:*)
+	echo we32k-att-sysv3
+	exit 0 ;;
+    *:QNX:*:42*)
+	echo i386-qssl-qnx`echo ${UNAME_VERSION}`
+	exit 0 ;;
+    Alpha*:Windows:NT:*:SP*)
+	echo alpha-pc-opennt
+	exit 0 ;;
+    *:Windows:NT:*:SP*)
+	echo intel-pc-opennt
+	exit 0 ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
 	exit 0 ;;
+    # end cases added for Bash
     alpha:OSF1:*:*)
-	if test $UNAME_RELEASE = "V4.0"; then
+	# TEST CHANGED FOR BASH to handle `letter version' releases
+	UNAME_MAJOR=`echo "$UNAME_RELEASE" | sed -e 's/^.\([0-9]\).*/\1/'`
+	if test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR = 4 ; then
 		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+	elif test X"$UNAME_MAJOR" != X"" && test $UNAME_MAJOR -gt 4 ; then
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`		
 	fi
 	# A Vn.n version is a released version.
 	# A Tn.n version is a released field test version.
 	# A Xn.n version is an unreleased experimental baselevel.
 	# 1.2 uses "1.2" for uname -r.
 	cat <<EOF >$dummy.s
-	.data
-\$Lformat:
-	.byte 37,100,45,37,120,10,0	# "%d-%x\n"
-
-	.text
 	.globl main
-	.align 4
 	.ent main
 main:
-	.frame \$30,16,\$26,0
-	ldgp \$29,0(\$27)
-	.prologue 1
-	.long 0x47e03d80 # implver \$0
-	lda \$2,-1
-	.long 0x47e20c21 # amask \$2,\$1
-	lda \$16,\$Lformat
-	mov \$0,\$17
-	not \$1,\$18
-	jsr \$26,printf
-	ldgp \$29,0(\$26)
-	mov 0,\$16
-	jsr \$26,exit
+	.frame \$30,0,\$26,0
+	.prologue 0
+	.long 0x47e03d80 # implver $0
+	lda \$2,259
+	.long 0x47e20c21 # amask $2,$1
+	srl \$1,8,\$2
+	sll \$2,2,\$2
+	sll \$0,3,\$0
+	addl \$1,\$0,\$0
+	addl \$2,\$0,\$0
+	ret \$31,(\$26),1
 	.end main
 EOF
-	eval $set_cc_for_build
 	$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
 	if test "$?" = 0 ; then
-		case `./$dummy` in
-			0-0)
+		./$dummy
+		case "$?" in
+			7)
 				UNAME_MACHINE="alpha"
 				;;
-			1-0)
+			15)
 				UNAME_MACHINE="alphaev5"
 				;;
-			1-1)
+			14)
 				UNAME_MACHINE="alphaev56"
 				;;
-			1-101)
+			10)
 				UNAME_MACHINE="alphapca56"
 				;;
-			2-303)
+			16)
 				UNAME_MACHINE="alphaev6"
 				;;
-			2-307)
-				UNAME_MACHINE="alphaev67"
-				;;
-			2-1307)
-				UNAME_MACHINE="alphaev68"
-				;;
 		esac
 	fi
 	rm -f $dummy.s $dummy
 	echo ${UNAME_MACHINE}-dec-osf`echo ${UNAME_RELEASE} | sed -e 's/^[VTX]//' | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
 	exit 0 ;;
     Alpha\ *:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# Should we change UNAME_MACHINE based on the output of uname instead
-	# of the specific Alpha model?
-	echo alpha-pc-interix
-	exit 0 ;;
+        # How do we know it's Interix rather than the generic POSIX subsystem?
+        # Should we change UNAME_MACHINE based on the output of uname instead
+        # of the specific Alpha model?
+        echo alpha-pc-interix
+        exit 0 ;;
     21064:Windows_NT:50:3)
 	echo alpha-dec-winnt3.5
 	exit 0 ;;
     Amiga*:UNIX_System_V:4.0:*)
-	echo m68k-unknown-sysv4
+	echo m68k-cbm-sysv4
 	exit 0;;
+    amiga:NetBSD:*:*)
+	echo m68k-cbm-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    amiga:OpenBSD:*:*)
+	echo m68k-cbm-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     *:[Aa]miga[Oo][Ss]:*:*)
 	echo ${UNAME_MACHINE}-unknown-amigaos
 	exit 0 ;;
-    *:[Mm]orph[Oo][Ss]:*:*)
-	echo ${UNAME_MACHINE}-unknown-morphos
+    arc64:OpenBSD:*:*)
+	echo mips64el-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
-    *:OS/390:*:*)
-	echo i370-ibm-openedition
+    arc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    hkmips:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    pmax:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sgi:OpenBSD:*:*)
+	echo mips-unknown-openbsd${UNAME_RELEASE}
 	exit 0 ;;
+    wgrisc:OpenBSD:*:*)
+	echo mipsel-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
 	echo arm-acorn-riscix${UNAME_RELEASE}
 	exit 0;;
-    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+    arm32:NetBSD:*:*)
+	echo arm-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    SR2?01:HI-UX/MPP:*:*)
 	echo hppa1.1-hitachi-hiuxmpp
 	exit 0;;
     Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
@@ -309,12 +281,12 @@ EOF
 		echo pyramid-pyramid-bsd
 	fi
 	exit 0 ;;
-    NILE*:*:*:dcosx)
+    NILE:*:*:*:dcosx)
 	echo pyramid-pyramid-svr4
 	exit 0 ;;
     sun4H:SunOS:5.*:*)
-	echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
-	exit 0 ;;
+        echo sparc-hal-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
+        exit 0 ;;
     sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
 	echo sparc-sun-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
@@ -340,7 +312,7 @@ EOF
 	echo m68k-sun-sunos${UNAME_RELEASE}
 	exit 0 ;;
     sun*:*:4.2BSD:*)
-	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	UNAME_RELEASE=`(head -1 /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
 	test "x${UNAME_RELEASE}" = "x" && UNAME_RELEASE=3
 	case "`/bin/arch`" in
 	    sun3)
@@ -354,23 +326,29 @@ EOF
     aushp:SunOS:*:*)
 	echo sparc-auspex-sunos${UNAME_RELEASE}
 	exit 0 ;;
+    atari*:NetBSD:*:*)
+	echo m68k-atari-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    atari*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
     # The situation for MiNT is a little confusing.  The machine name
     # can be virtually everything (everything which is not
-    # "atarist" or "atariste" at least should have a processor
+    # "atarist" or "atariste" at least should have a processor 
     # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
     # to the lowercase version "mint" (or "freemint").  Finally
     # the system name "TOS" denotes a system which is actually not
     # MiNT.  But MiNT is downward compatible to TOS, so this should
     # be no problem.
     atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
-	echo m68k-atari-mint${UNAME_RELEASE}
-        exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
-        echo m68k-atari-mint${UNAME_RELEASE}
-	exit 0 ;;
+       echo m68k-atari-mint${UNAME_RELEASE}
+       exit 0 ;;
     milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
         echo m68k-milan-mint${UNAME_RELEASE}
         exit 0 ;;
@@ -380,9 +358,33 @@ EOF
     *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
         echo m68k-unknown-mint${UNAME_RELEASE}
         exit 0 ;;
+    sun3*:NetBSD:*:*)
+	echo m68k-sun-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    sun3*:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:NetBSD:*:*)
+	echo m68k-apple-netbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mac68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme68k:OpenBSD:*:*)
+	echo m68k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    mvme88k:OpenBSD:*:*)
+	echo m88k-unknown-openbsd${UNAME_RELEASE}
+	exit 0 ;;
+    *:"Mac OS":*:*)
+	echo `uname -p`-apple-macos${UNAME_RELEASE}
+	exit 0 ;;
     powerpc:machten:*:*)
 	echo powerpc-apple-machten${UNAME_RELEASE}
 	exit 0 ;;
+    macppc:NetBSD:*:*)
+        echo powerpc-apple-netbsd${UNAME_RELEASE}
+        exit 0 ;;
     RISC*:Mach:*:*)
 	echo mips-dec-mach_bsd4.3
 	exit 0 ;;
@@ -396,10 +398,8 @@ EOF
 	echo clipper-intergraph-clix${UNAME_RELEASE}
 	exit 0 ;;
     mips:*:*:UMIPS | mips:*:*:RISCos)
-	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 #ifdef __cplusplus
-#include <stdio.h>  /* for printf() prototype */
 	int main (int argc, char *argv[]) {
 #else
 	int main (argc, argv) int argc; char *argv[]; {
@@ -420,13 +420,10 @@ EOF
 EOF
 	$CC_FOR_BUILD $dummy.c -o $dummy \
 	  && ./$dummy `echo "${UNAME_RELEASE}" | sed -n 's/\([0-9]*\).*/\1/p'` \
-	  && rm -f $dummy.c $dummy && exit 0
+	  && rm $dummy.c $dummy && exit 0
 	rm -f $dummy.c $dummy
 	echo mips-mips-riscos${UNAME_RELEASE}
 	exit 0 ;;
-    Motorola:PowerMAX_OS:*:*)
-	echo powerpc-motorola-powermax
-	exit 0 ;;
     Night_Hawk:Power_UNIX:*:*)
 	echo powerpc-harris-powerunix
 	exit 0 ;;
@@ -440,19 +437,17 @@ EOF
 	echo m88k-motorola-sysv3
 	exit 0 ;;
     AViiON:dgux:*:*)
-        # DG/UX returns AViiON for all architectures
-        UNAME_PROCESSOR=`/usr/bin/uname -p`
-	if [ $UNAME_PROCESSOR = mc88100 ] || [ $UNAME_PROCESSOR = mc88110 ]
-	then
-	    if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx ] || \
-	       [ ${TARGET_BINARY_INTERFACE}x = x ]
-	    then
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ $UNAME_PROCESSOR = mc88100 -o $UNAME_PROCESSOR = mc88110 ] ; then
+	  if [ ${TARGET_BINARY_INTERFACE}x = m88kdguxelfx \
+	     -o ${TARGET_BINARY_INTERFACE}x = x ] ; then
 		echo m88k-dg-dgux${UNAME_RELEASE}
-	    else
+	  else
 		echo m88k-dg-dguxbcs${UNAME_RELEASE}
-	    fi
+	  fi
 	else
-	    echo i586-dg-dgux${UNAME_RELEASE}
+	  echo i586-dg-dgux${UNAME_RELEASE}
 	fi
  	exit 0 ;;
     M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
@@ -474,20 +469,11 @@ EOF
     ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
 	echo romp-ibm-aix      # uname -m gives an 8 hex-code CPU id
 	exit 0 ;;              # Note that: echo "'`uname -s`'" gives 'AIX '
-    i*86:AIX:*:*)
+    i?86:AIX:*:*)
 	echo i386-ibm-aix
 	exit 0 ;;
-    ia64:AIX:*:*)
-	if [ -x /usr/bin/oslevel ] ; then
-		IBM_REV=`/usr/bin/oslevel`
-	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
-	fi
-	echo ${UNAME_MACHINE}-ibm-aix${IBM_REV}
-	exit 0 ;;
     *:AIX:2:3)
 	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
-		eval $set_cc_for_build
 		sed 's/^		//' << EOF >$dummy.c
 		#include <sys/systemcfg.h>
 
@@ -499,7 +485,7 @@ EOF
 			exit(0);
 			}
 EOF
-		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+		$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
 		rm -f $dummy.c $dummy
 		echo rs6000-ibm-aix3.2.5
 	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
@@ -508,17 +494,21 @@ EOF
 		echo rs6000-ibm-aix3.2
 	fi
 	exit 0 ;;
-    *:AIX:*:[45])
-	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
-	if /usr/sbin/lsattr -El ${IBM_CPU_ID} | grep ' POWER' >/dev/null 2>&1; then
+    *:AIX:*:4)
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | head -1 | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -EHl ${IBM_CPU_ID} | grep POWER >/dev/null 2>&1; then
 		IBM_ARCH=rs6000
 	else
 		IBM_ARCH=powerpc
 	fi
 	if [ -x /usr/bin/oslevel ] ; then
 		IBM_REV=`/usr/bin/oslevel`
+	elif grep bos410 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1
+	elif grep bos411 /usr/include/stdio.h >/dev/null 2>&1; then
+		IBM_REV=4.1.1
 	else
-		IBM_REV=${UNAME_VERSION}.${UNAME_RELEASE}
+		IBM_REV=4.${UNAME_RELEASE}
 	fi
 	echo ${IBM_ARCH}-ibm-aix${IBM_REV}
 	exit 0 ;;
@@ -528,7 +518,7 @@ EOF
     ibmrt:4.4BSD:*|romp-ibm:BSD:*)
 	echo romp-ibm-bsd4.4
 	exit 0 ;;
-    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC NetBSD and
 	echo romp-ibm-bsd${UNAME_RELEASE}   # 4.3 with uname added to
 	exit 0 ;;                           # report: romp-ibm BSD 4.3
     *:BOSX:*:*)
@@ -544,30 +534,11 @@ EOF
 	echo m68k-hp-bsd4.4
 	exit 0 ;;
     9000/[34678]??:HP-UX:*:*)
-	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
 	case "${UNAME_MACHINE}" in
-	    9000/31? )            HP_ARCH=m68000 ;;
-	    9000/[34]?? )         HP_ARCH=m68k ;;
+	    9000/31? )		HP_ARCH=m68000 ;;
+	    9000/[34]?? )	HP_ARCH=m68k ;;
 	    9000/[678][0-9][0-9])
-		if [ -x /usr/bin/getconf ]; then
-		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
-                    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
-                    case "${sc_cpu_version}" in
-                      523) HP_ARCH="hppa1.0" ;; # CPU_PA_RISC1_0
-                      528) HP_ARCH="hppa1.1" ;; # CPU_PA_RISC1_1
-                      532)                      # CPU_PA_RISC2_0
-                        case "${sc_kernel_bits}" in
-                          32) HP_ARCH="hppa2.0n" ;;
-                          64) HP_ARCH="hppa2.0w" ;;
-			  '') HP_ARCH="hppa2.0" ;;   # HP-UX 10.20
-                        esac ;;
-                    esac
-		fi
-		if [ "${HP_ARCH}" = "" ]; then
-		    eval $set_cc_for_build
-		    sed 's/^              //' << EOF >$dummy.c
-
-              #define _HPUX_SOURCE
+              sed 's/^              //' << EOF >$dummy.c
               #include <stdlib.h>
               #include <unistd.h>
 
@@ -598,19 +569,13 @@ EOF
                   exit (0);
               }
 EOF
-		    (CCOPTS= $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null) && HP_ARCH=`./$dummy`
-		    if test -z "$HP_ARCH"; then HP_ARCH=hppa; fi
-		    rm -f $dummy.c $dummy
-		fi ;;
+	($CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null ) && HP_ARCH=`./$dummy`
+	rm -f $dummy.c $dummy
 	esac
-	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
-	exit 0 ;;
-    ia64:HP-UX:*:*)
 	HPUX_REV=`echo ${UNAME_RELEASE}|sed -e 's/[^.]*.[0B]*//'`
-	echo ia64-hp-hpux${HPUX_REV}
+	echo ${HP_ARCH}-hp-hpux${HPUX_REV}
 	exit 0 ;;
     3050*:HI-UX:*:*)
-	eval $set_cc_for_build
 	sed 's/^	//' << EOF >$dummy.c
 	#include <unistd.h>
 	int
@@ -636,7 +601,7 @@ EOF
 	  exit (0);
 	}
 EOF
-	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm -f $dummy.c $dummy && exit 0
+	$CC_FOR_BUILD $dummy.c -o $dummy && ./$dummy && rm $dummy.c $dummy && exit 0
 	rm -f $dummy.c $dummy
 	echo unknown-hitachi-hiuxwe2
 	exit 0 ;;
@@ -645,17 +610,17 @@ EOF
 	exit 0 ;;
     9000/8??:4.3bsd:*:*)
 	echo hppa1.0-hp-bsd
-	exit 0 ;;
-    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
-	echo hppa1.0-hp-mpeix
 	exit 0 ;;
+    *9??*:MPE/iX:*:*)
+        echo hppa1.0-hp-mpeix
+        exit 0 ;;
     hp7??:OSF1:*:* | hp8?[79]:OSF1:*:* )
 	echo hppa1.1-hp-osf
 	exit 0 ;;
     hp8??:OSF1:*:*)
 	echo hppa1.0-hp-osf
 	exit 0 ;;
-    i*86:OSF1:*:*)
+    i?86:OSF1:*:*)
 	if [ -x /usr/sbin/sysversion ] ; then
 	    echo ${UNAME_MACHINE}-unknown-osf1mk
 	else
@@ -665,6 +630,9 @@ EOF
     parisc*:Lites*:*:*)
 	echo hppa1.1-hp-lites
 	exit 0 ;;
+    hppa*:OpenBSD:*:*)
+        echo hppa-unknown-openbsd
+        exit 0 ;;
     C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
 	echo c1-convex-bsd
         exit 0 ;;
@@ -683,44 +651,63 @@ EOF
     C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
 	echo c4-convex-bsd
         exit 0 ;;
+    CRAY*X-MP:*:*:*)
+	echo xmp-cray-unicos
+        exit 0 ;;
     CRAY*Y-MP:*:*:*)
-	echo ymp-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo ymp-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
     CRAY*[A-Z]90:*:*:*)
 	echo ${UNAME_MACHINE}-cray-unicos${UNAME_RELEASE} \
 	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
-	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
-	      -e 's/\.[^.]*$/.X/'
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/
 	exit 0 ;;
     CRAY*TS:*:*:*)
-	echo t90-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+	echo t90-cray-unicos${UNAME_RELEASE}
 	exit 0 ;;
-    CRAY*T3D:*:*:*)
-	echo alpha-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
-	exit 0 ;;
     CRAY*T3E:*:*:*)
-	echo alphaev5-cray-unicosmk${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+        echo alpha-cray-unicosmk${UNAME_RELEASE}
+        exit 0 ;;
+    CRAY-2:*:*:*)
+	echo cray2-cray-unicos
+        exit 0 ;;
+    F300:UNIX_System_V:*:*)
+	FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
+	FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
+	echo "f300-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit 0 ;;
+    F301:UNIX_System_V:*:*)
+	echo f301-fujitsu-uxpv`echo $UNAME_RELEASE | sed 's/ .*//'`
 	exit 0 ;;
-    CRAY*SV1:*:*:*)
-	echo sv1-cray-unicos${UNAME_RELEASE} | sed -e 's/\.[^.]*$/.X/'
+    hp3[0-9][05]:NetBSD:*:*)
+	echo m68k-hp-netbsd${UNAME_RELEASE}
 	exit 0 ;;
-    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
-	FUJITSU_PROC=`uname -m | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz'`
-        FUJITSU_SYS=`uname -p | tr 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' 'abcdefghijklmnopqrstuvwxyz' | sed -e 's/\///'`
-        FUJITSU_REL=`echo ${UNAME_RELEASE} | sed -e 's/ /_/'`
-        echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+    hp300:OpenBSD:*:*)
+        echo m68k-unknown-openbsd${UNAME_RELEASE}
         exit 0 ;;
-    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+    i?86:BSD/386:*:* | i?86:BSD/OS:*:*)
 	echo ${UNAME_MACHINE}-pc-bsdi${UNAME_RELEASE}
 	exit 0 ;;
     sparc*:BSD/OS:*:*)
-	echo sparc-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+        echo sparc-unknown-bsdi${UNAME_RELEASE}
+        exit 0 ;;
     *:BSD/OS:*:*)
-	echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
-	exit 0 ;;
+        echo ${UNAME_MACHINE}-unknown-bsdi${UNAME_RELEASE}
+        exit 0 ;;
     *:FreeBSD:*:*)
-	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`
+	if test -x /usr/bin/objformat; then
+	    if test "elf" = "`/usr/bin/objformat`"; then
+		echo ${UNAME_MACHINE}-unknown-freebsdelf`echo ${UNAME_RELEASE}|sed -e 's/[-_].*//'`
+		exit 0
+	    fi
+	fi
+	echo ${UNAME_MACHINE}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-=(].*//'`
+	exit 0 ;;
+    *:NetBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-netbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
+	exit 0 ;;
+    *:OpenBSD:*:*)
+	echo ${UNAME_MACHINE}-unknown-openbsd`echo ${UNAME_RELEASE}|sed -e 's/[-_].*/\./'`
 	exit 0 ;;
     i*:CYGWIN*:*)
 	echo ${UNAME_MACHINE}-pc-cygwin
@@ -728,190 +715,225 @@ EOF
     i*:MINGW*:*)
 	echo ${UNAME_MACHINE}-pc-mingw32
 	exit 0 ;;
-    i*:PW*:*)
-	echo ${UNAME_MACHINE}-pc-pw32
-	exit 0 ;;
-    x86:Interix*:3*)
-	echo i386-pc-interix3
-	exit 0 ;;
     i*:Windows_NT*:* | Pentium*:Windows_NT*:*)
-	# How do we know it's Interix rather than the generic POSIX subsystem?
-	# It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
-	# UNAME_MACHINE based on the output of uname instead of i386?
-	echo i386-pc-interix
-	exit 0 ;;
+        # How do we know it's Interix rather than the generic POSIX subsystem?
+        # It also conflicts with pre-2.0 versions of AT&T UWIN. Should we
+        # UNAME_MACHINE based on the output of uname instead of i386?
+        echo i386-pc-interix
+        exit 0 ;;
     i*:UWIN*:*)
-	echo ${UNAME_MACHINE}-pc-uwin
-	exit 0 ;;
+        echo ${UNAME_MACHINE}-pc-uwin
+        exit 0 ;;
     p*:CYGWIN*:*)
 	echo powerpcle-unknown-cygwin
-	exit 0 ;;
+	exit 0 ;;    
     prep*:SunOS:5.*:*)
 	echo powerpcle-unknown-solaris2`echo ${UNAME_RELEASE}|sed -e 's/[^.]*//'`
 	exit 0 ;;
     *:GNU:*:*)
 	echo `echo ${UNAME_MACHINE}|sed -e 's,[-/].*$,,'`-unknown-gnu`echo ${UNAME_RELEASE}|sed -e 's,/.*$,,'`
 	exit 0 ;;
-    i*86:Minix:*:*)
-	echo ${UNAME_MACHINE}-pc-minix
-	exit 0 ;;
-    arm*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    ia64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux
-	exit 0 ;;
-    m68*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    mips:Linux:*:*)
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#undef CPU
-	#undef mips
-	#undef mipsel
-	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL) 
-	CPU=mipsel 
-	#else
-	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB) 
-	CPU=mips
-	#else
-	CPU=
-	#endif
-	#endif 
-EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^CPU=`
-	rm -f $dummy.c
-	test x"${CPU}" != x && echo "${CPU}-pc-linux-gnu" && exit 0
-	;;
-    ppc:Linux:*:*)
-	echo powerpc-unknown-linux-gnu
-	exit 0 ;;
-    ppc64:Linux:*:*)
-	echo powerpc64-unknown-linux-gnu
-	exit 0 ;;
-    alpha:Linux:*:*)
-	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' < /proc/cpuinfo` in
-	  EV5)   UNAME_MACHINE=alphaev5 ;;
-	  EV56)  UNAME_MACHINE=alphaev56 ;;
-	  PCA56) UNAME_MACHINE=alphapca56 ;;
-	  PCA57) UNAME_MACHINE=alphapca56 ;;
-	  EV6)   UNAME_MACHINE=alphaev6 ;;
-	  EV67)  UNAME_MACHINE=alphaev67 ;;
-	  EV68*) UNAME_MACHINE=alphaev68 ;;
+    *:Linux:*:*)
+        # uname on the ARM produces all sorts of strangeness, and we need to
+        # filter it out.
+        case "$UNAME_MACHINE" in
+          armv*)                      UNAME_MACHINE=$UNAME_MACHINE ;;
+          arm* | sa110*)              UNAME_MACHINE="arm" ;;
         esac
-	objdump --private-headers /bin/sh | grep ld.so.1 >/dev/null
-	if test "$?" = 0 ; then LIBC="libc1" ; else LIBC="" ; fi
-	echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC}
-	exit 0 ;;
-    parisc:Linux:*:* | hppa:Linux:*:*)
-	# Look for CPU level
-	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
-	  PA7*) echo hppa1.1-unknown-linux-gnu ;;
-	  PA8*) echo hppa2.0-unknown-linux-gnu ;;
-	  *)    echo hppa-unknown-linux-gnu ;;
-	esac
-	exit 0 ;;
-    parisc64:Linux:*:* | hppa64:Linux:*:*)
-	echo hppa64-unknown-linux-gnu
-	exit 0 ;;
-    s390:Linux:*:* | s390x:Linux:*:*)
-	echo ${UNAME_MACHINE}-ibm-linux
-	exit 0 ;;
-    sh*:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    sparc:Linux:*:* | sparc64:Linux:*:*)
-	echo ${UNAME_MACHINE}-unknown-linux-gnu
-	exit 0 ;;
-    x86_64:Linux:*:*)
-	echo x86_64-unknown-linux-gnu
-	exit 0 ;;
-    i*86:Linux:*:*)
+
 	# The BFD linker knows what the default object file format is, so
-	# first see if it will tell us. cd to the root directory to prevent
+	# first see if it will tell us.  cd to the root directory to prevent
 	# problems with other programs or directories called `ld' in the path.
-	# Set LC_ALL=C to ensure ld outputs messages in English.
-	ld_supported_targets=`cd /; LC_ALL=C ld --help 2>&1 \
-			 | sed -ne '/supported targets:/!d
+	ld_help_string=`cd /; ld --help 2>&1`
+	ld_supported_emulations=`echo $ld_help_string \
+			 | sed -ne '/supported emulations:/!d
 				    s/[ 	][ 	]*/ /g
-				    s/.*supported targets: *//
+				    s/.*supported emulations: *//
 				    s/ .*//
 				    p'`
-        case "$ld_supported_targets" in
-	  elf32-i386)
-		TENTATIVE="${UNAME_MACHINE}-pc-linux-gnu"
-		;;
-	  a.out-i386-linux)
-		echo "${UNAME_MACHINE}-pc-linux-gnuaout"
-		exit 0 ;;		
-	  coff-i386)
-		echo "${UNAME_MACHINE}-pc-linux-gnucoff"
-		exit 0 ;;
-	  "")
-		# Either a pre-BFD a.out linker (linux-gnuoldld) or
-		# one that does not give us useful --help.
-		echo "${UNAME_MACHINE}-pc-linux-gnuoldld"
-		exit 0 ;;
-	esac
-	# Determine whether the default compiler is a.out or elf
-	eval $set_cc_for_build
-	sed 's/^	//' << EOF >$dummy.c
-	#include <features.h>
-	#ifdef __ELF__
-	# ifdef __GLIBC__
-	#  if __GLIBC__ >= 2
-	LIBC=gnu
-	#  else
-	LIBC=gnulibc1
-	#  endif
-	# else
-	LIBC=gnulibc1
-	# endif
-	#else
-	#ifdef __INTEL_COMPILER
-	LIBC=gnu
-	#else
-	LIBC=gnuaout
-	#endif
-	#endif
+	case "$ld_supported_emulations" in
+	  *ia64)      echo "${UNAME_MACHINE}-unknown-linux"         ; exit 0 ;;
+	  i?86linux)  echo "${UNAME_MACHINE}-pc-linux-gnuaout"      ; exit 0 ;;
+	  i?86coff)   echo "${UNAME_MACHINE}-pc-linux-gnucoff"      ; exit 0 ;;
+	  sparclinux) echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  armlinux)   echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  m68klinux)  echo "${UNAME_MACHINE}-unknown-linux-gnuaout" ; exit 0 ;;
+	  elf32ppc | elf32ppclinux)
+		# Determine Lib Version
+		cat >$dummy.c <<EOF
+#include <features.h>
+#if defined(__GLIBC__)
+extern char __libc_version[];
+extern char __libc_release[];
+#endif
+main(argc, argv)
+     int argc;
+     char *argv[];
+{
+#if defined(__GLIBC__)
+  printf("%s %s\n", __libc_version, __libc_release);
+#else
+  printf("unkown\n");
+#endif
+  return 0;
+}
+EOF
+		LIBC=""
+		$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null
+		if test "$?" = 0 ; then
+			./$dummy | grep 1\.99 > /dev/null
+			if test "$?" = 0 ; then
+				LIBC="libc1"
+			fi
+		fi	
+		rm -f $dummy.c $dummy
+		echo powerpc-unknown-linux-gnu${LIBC} ; exit 0 ;;
+ 	esac
+
+	if test "${UNAME_MACHINE}" = "alpha" ; then
+		sed 's/^	//'  <<EOF >$dummy.s
+		.globl main
+		.ent main
+	main:
+		.frame \$30,0,\$26,0
+		.prologue 0
+		.long 0x47e03d80 # implver $0
+		lda \$2,259
+		.long 0x47e20c21 # amask $2,$1
+		srl \$1,8,\$2
+		sll \$2,2,\$2
+		sll \$0,3,\$0
+		addl \$1,\$0,\$0
+		addl \$2,\$0,\$0
+		ret \$31,(\$26),1
+		.end main
+EOF
+		LIBC=""
+		$CC_FOR_BUILD $dummy.s -o $dummy 2>/dev/null
+		if test "$?" = 0 ; then
+			./$dummy
+			case "$?" in
+			7)
+				UNAME_MACHINE="alpha"
+				;;
+			15)
+				UNAME_MACHINE="alphaev5"
+				;;
+			14)
+				UNAME_MACHINE="alphaev56"
+				;;
+			10)
+				UNAME_MACHINE="alphapca56"
+				;;
+			16)
+				UNAME_MACHINE="alphaev6"
+				;;
+			esac
+
+			objdump --private-headers $dummy | \
+			  grep ld.so.1 > /dev/null
+			if test "$?" = 0 ; then
+				LIBC="libc1"
+			fi
+		fi
+		rm -f $dummy.s $dummy
+		echo ${UNAME_MACHINE}-unknown-linux-gnu${LIBC} ; exit 0
+	elif test "${UNAME_MACHINE}" = "mips" ; then
+	  cat >$dummy.c <<EOF
+#ifdef __cplusplus
+int main (int argc, char *argv[]) {
+#else
+int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __MIPSEB__
+  printf ("%s-unknown-linux-gnu\n", argv[1]);
+#endif
+#ifdef __MIPSEL__
+  printf ("%sel-unknown-linux-gnu\n", argv[1]);
+#endif
+  return 0;
+}
+EOF
+	  $CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
+	  rm -f $dummy.c $dummy
+	else
+	  # Either a pre-BFD a.out linker (linux-gnuoldld)
+	  # or one that does not give us useful --help.
+	  # GCC wants to distinguish between linux-gnuoldld and linux-gnuaout.
+	  # If ld does not provide *any* "supported emulations:"
+	  # that means it is gnuoldld.
+	  echo "$ld_help_string" | grep >/dev/null 2>&1 "supported emulations:"
+	  test $? != 0 && echo "${UNAME_MACHINE}-pc-linux-gnuoldld" && exit 0
+
+	  case "${UNAME_MACHINE}" in
+	  i?86)
+	    VENDOR=pc;
+	    ;;
+	  *)
+	    VENDOR=unknown;
+	    ;;
+	  esac
+	  # Determine whether the default compiler is a.out or elf
+	  cat >$dummy.c <<EOF
+#include <features.h>
+#ifdef __cplusplus
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+#ifdef __ELF__
+# ifdef __GLIBC__
+#  if __GLIBC__ >= 2
+    printf ("%s-${VENDOR}-linux-gnu\n", argv[1]);
+#  else
+    printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+#  endif
+# else
+   printf ("%s-${VENDOR}-linux-gnulibc1\n", argv[1]);
+# endif
+#else
+  printf ("%s-${VENDOR}-linux-gnuaout\n", argv[1]);
+#endif
+  return 0;
+}
 EOF
-	eval `$CC_FOR_BUILD -E $dummy.c 2>/dev/null | grep ^LIBC=`
-	rm -f $dummy.c
-	test x"${LIBC}" != x && echo "${UNAME_MACHINE}-pc-linux-${LIBC}" && exit 0
-	test x"${TENTATIVE}" != x && echo "${TENTATIVE}" && exit 0
-	;;
-    i*86:DYNIX/ptx:4*:*)
-	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
-	# earlier versions are messed up and put the nodename in both
-	# sysname and nodename.
+	  ${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy "${UNAME_MACHINE}" && rm $dummy.c $dummy && exit 0
+	  rm -f $dummy.c $dummy
+	fi ;;
+# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.  earlier versions
+# are messed up and put the nodename in both sysname and nodename.
+    i?86:DYNIX/ptx:4*:*)
 	echo i386-sequent-sysv4
 	exit 0 ;;
-    i*86:UNIX_SV:4.2MP:2.*)
-        # Unixware is an offshoot of SVR4, but it has its own version
-        # number series starting with 2...
-        # I am not positive that other SVR4 systems won't match this,
+# added by chet for bash based on usenet posting from <hops@sco.com> and
+# documentation on SCO's web site -- UnixWare 7 (SVR5)
+#    i?86:UnixWare:5*:*)
+#	echo ${UNAME_MACHINE}-pc-sysv5uw${UNAME_VERSION}
+#	exit 0 ;;
+    i?86:UNIX_SV:4.2MP:2.*)
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
 	# I just have to hope.  -- rms.
-        # Use sysv4.2uw... so that sysv4* matches it.
+	# Use sysv4.2uw... so that sysv4* matches it.
 	echo ${UNAME_MACHINE}-pc-sysv4.2uw${UNAME_VERSION}
 	exit 0 ;;
-    i*86:*:4.*:* | i*86:SYSTEM_V:4.*:*)
-	UNAME_REL=`echo ${UNAME_RELEASE} | sed 's/\/MP$//'`
+    i?86:*:4.*:* | i?86:SYSTEM_V:4.*:* | i?86:UNIX_SV:4.*:*)
 	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
-		echo ${UNAME_MACHINE}-univel-sysv${UNAME_REL}
+		echo ${UNAME_MACHINE}-univel-sysv${UNAME_RELEASE}
 	else
-		echo ${UNAME_MACHINE}-pc-sysv${UNAME_REL}
+		echo ${UNAME_MACHINE}-pc-sysv${UNAME_RELEASE}
 	fi
-	exit 0 ;;
-    i*86:*:5:[78]*)
-	case `/bin/uname -X | grep "^Machine"` in
-	    *486*)	     UNAME_MACHINE=i486 ;;
-	    *Pentium)	     UNAME_MACHINE=i586 ;;
-	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
-	esac
-	echo ${UNAME_MACHINE}-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}
 	exit 0 ;;
-    i*86:*:3.2:*)
+    i?86:*:5:7*)
+        UNAME_REL=`(/bin/uname -X|egrep Release|sed -e 's/.*= //')`
+        (/bin/uname -X|egrep i80486 >/dev/null) && UNAME_MACHINE=i486
+        (/bin/uname -X|egrep '^Machine.*Pentium' >/dev/null) && UNAME_MACHINE=i586
+        (/bin/uname -X|egrep '^Machine.*Pent.*II' >/dev/null) && UNAME_MACHINE=i686
+        (/bin/uname -X|egrep '^Machine.*Pentium Pro' >/dev/null) && UNAME_MACHINE=i585
+        echo ${UNAME_MACHINE}-${UNAME_SYSTEM}${UNAME_VERSION}-sysv${UNAME_RELEASE}
+        exit 0 ;;
+    i?86:*:3.2:*)
 	if test -f /usr/options/cb.name; then
 		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
 		echo ${UNAME_MACHINE}-pc-isc$UNAME_REL
@@ -929,15 +951,11 @@ EOF
 		echo ${UNAME_MACHINE}-pc-sysv32
 	fi
 	exit 0 ;;
-    i*86:*DOS:*:*)
-	echo ${UNAME_MACHINE}-pc-msdosdjgpp
-	exit 0 ;;
     pc:*:*:*)
-	# Left here for compatibility:
-        # uname -m prints for DJGPP always 'pc', but it prints nothing about
-        # the processor, so we play safe by assuming i386.
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i386.
 	echo i386-pc-msdosdjgpp
-        exit 0 ;;
+	exit 0 ;;
     Intel:Mach:3*:*)
 	echo i386-pc-mach3
 	exit 0 ;;
@@ -957,7 +975,7 @@ EOF
 	exit 0 ;;
     M68*:*:R3V[567]*:*)
 	test -r /sysV68 && echo 'm68k-motorola-sysv' && exit 0 ;;
-    3[34]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0)
+    3[34]??:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 4850:*:4.0:3.0)
 	OS_REL=''
 	test -r /etc/.relid \
 	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
@@ -966,35 +984,32 @@ EOF
 	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
 	  && echo i586-ncr-sysv4.3${OS_REL} && exit 0 ;;
     3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
-        /bin/uname -p 2>/dev/null | grep 86 >/dev/null \
-          && echo i486-ncr-sysv4 && exit 0 ;;
-    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
-	echo m68k-unknown-lynxos${UNAME_RELEASE}
-	exit 0 ;;
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && echo i486-ncr-sysv4 && exit 0 ;;
     mc68030:UNIX_System_V:4.*:*)
 	echo m68k-atari-sysv4
 	exit 0 ;;
-    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.0*:*)
-	echo i386-unknown-lynxos${UNAME_RELEASE}
+    m68*:LynxOS:2.*:*)
+	echo m68k-unknown-lynxos${UNAME_RELEASE}
+	exit 0 ;;
+    i?86:LynxOS:2.*:* | i?86:LynxOS:3.[01]*:*)
+	echo i386-pc-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     TSUNAMI:LynxOS:2.*:*)
 	echo sparc-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
-    rs6000:LynxOS:2.*:*)
+    rs6000:LynxOS:2.*:* | PowerPC:LynxOS:2.*:*)
 	echo rs6000-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
-    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.0*:*)
-	echo powerpc-unknown-lynxos${UNAME_RELEASE}
+    *:LynxOS:*:*)
+	echo ${UNAME_MACHINE}-unknown-lynxos${UNAME_RELEASE}
 	exit 0 ;;
     SM[BE]S:UNIX_SV:*:*)
 	echo mips-dde-sysv${UNAME_RELEASE}
 	exit 0 ;;
-    RM*:ReliantUNIX-*:*:*)
+    RM*:SINIX-*:*:* | RM*:ReliantUNIX-*:*:*)
 	echo mips-sni-sysv4
 	exit 0 ;;
-    RM*:SINIX-*:*:*)
-	echo mips-sni-sysv4
-	exit 0 ;;
     *:SINIX-*:*:*)
 	if uname -p 2>/dev/null >/dev/null ; then
 		UNAME_MACHINE=`(uname -p) 2>/dev/null`
@@ -1003,10 +1018,10 @@ EOF
 		echo ns32k-sni-sysv
 	fi
 	exit 0 ;;
-    PENTIUM:*:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
-                      # says <Richard.M.Bartel@ccMail.Census.GOV>
-        echo i586-unisys-sysv4
-        exit 0 ;;
+    PENTIUM:CPunix:4.0*:*) # Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			   # says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit 0 ;;
     *:UNIX_System_V:4*:FTX*)
 	# From Gerald Hewes <hewes@openmarket.com>.
 	# How about differentiating between stratus architectures? -djm
@@ -1015,31 +1030,27 @@ EOF
     *:*:*:FTX*)
 	# From seanf@swdc.stratus.com.
 	echo i860-stratus-sysv4
-	exit 0 ;;
-    *:VOS:*:*)
-	# From Paul.Green@stratus.com.
-	echo hppa1.1-stratus-vos
-	exit 0 ;;
+	exit 0 ;;              
     mc68*:A/UX:*:*)
 	echo m68k-apple-aux${UNAME_RELEASE}
 	exit 0 ;;
-    news*:NEWS-OS:6*:*)
+    news*:NEWS-OS:*:6*)
 	echo mips-sony-newsos6
 	exit 0 ;;
-    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+    R3000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
 	if [ -d /usr/nec ]; then
-	        echo mips-nec-sysv${UNAME_RELEASE}
+		echo mips-nec-sysv${UNAME_RELEASE}
 	else
-	        echo mips-unknown-sysv${UNAME_RELEASE}
+		echo mips-unknown-sysv${UNAME_RELEASE}
 	fi
-        exit 0 ;;
-    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
-	echo powerpc-be-beos
+	exit 0 ;;
+    BeBox:BeOS:*:*)    # BeOS running on hardware made by Be, PPC only.
+	echo powerpc-apple-beos
 	exit 0 ;;
-    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+    BeMac:BeOS:*:*)
 	echo powerpc-apple-beos
 	exit 0 ;;
-    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+    BePC:BeOS:*:*)
 	echo i586-pc-beos
 	exit 0 ;;
     SX-4:SUPER-UX:*:*)
@@ -1053,79 +1064,18 @@ EOF
 	exit 0 ;;
     *:Rhapsody:*:*)
 	echo ${UNAME_MACHINE}-apple-rhapsody${UNAME_RELEASE}
-	exit 0 ;;
-    *:Darwin:*:*)
-	echo `uname -p`-apple-darwin${UNAME_RELEASE}
-	exit 0 ;;
-    *:procnto*:*:* | *:QNX:[0123456789]*:*)
-	if test "${UNAME_MACHINE}" = "x86pc"; then
-		UNAME_MACHINE=pc
-		echo i386-${UNAME_MACHINE}-nto-qnx
-	else
-		echo `uname -p`-${UNAME_MACHINE}-nto-qnx
-	fi
-	exit 0 ;;
-    *:QNX:*:4*)
-	echo i386-pc-qnx
-	exit 0 ;;
-    NSR-[GKLNPTVW]:NONSTOP_KERNEL:*:*)
-	echo nsr-tandem-nsk${UNAME_RELEASE}
-	exit 0 ;;
-    *:NonStop-UX:*:*)
-	echo mips-compaq-nonstopux
-	exit 0 ;;
-    BS2000:POSIX*:*:*)
-	echo bs2000-siemens-sysv
-	exit 0 ;;
-    DS/*:UNIX_System_V:*:*)
-	echo ${UNAME_MACHINE}-${UNAME_SYSTEM}-${UNAME_RELEASE}
-	exit 0 ;;
-    *:Plan9:*:*)
-	# "uname -m" is not consistent, so use $cputype instead. 386
-	# is converted to i386 for consistency with other x86
-	# operating systems.
-	if test "$cputype" = "386"; then
-	    UNAME_MACHINE=i386
-	else
-	    UNAME_MACHINE="$cputype"
-	fi
-	echo ${UNAME_MACHINE}-unknown-plan9
-	exit 0 ;;
-    i*86:OS/2:*:*)
-	# If we were able to find `uname', then EMX Unix compatibility
-	# is probably installed.
-	echo ${UNAME_MACHINE}-pc-os2-emx
-	exit 0 ;;
-    *:TOPS-10:*:*)
-	echo pdp10-unknown-tops10
-	exit 0 ;;
-    *:TENEX:*:*)
-	echo pdp10-unknown-tenex
-	exit 0 ;;
-    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
-	echo pdp10-dec-tops20
 	exit 0 ;;
-    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
-	echo pdp10-xkl-tops20
+    Power*:Darwin:*:*)
+	echo powerpc-apple-darwin${UNAME_RELEASE}
 	exit 0 ;;
-    *:TOPS-20:*:*)
-	echo pdp10-unknown-tops20
-	exit 0 ;;
-    *:ITS:*:*)
-	echo pdp10-unknown-its
-	exit 0 ;;
-    i*86:XTS-300:*:STOP)
-	echo ${UNAME_MACHINE}-unknown-stop
-	exit 0 ;;
-    i*86:atheos:*:*)
-	echo ${UNAME_MACHINE}-unknown-atheos
+    *:Darwin:*:*)
+	echo ${UNAME_MACHINE}-apple-darwin${UNAME_RELEASE}
 	exit 0 ;;
 esac
 
 #echo '(No uname command or uname output not recognized.)' 1>&2
 #echo "${UNAME_MACHINE}:${UNAME_SYSTEM}:${UNAME_RELEASE}:${UNAME_VERSION}" 1>&2
 
-eval $set_cc_for_build
 cat >$dummy.c <<EOF
 #ifdef _SEQUENT_
 # include <sys/types.h>
@@ -1151,7 +1101,11 @@ main ()
 #endif
 
 #if defined (__arm) && defined (__acorn) && defined (__unix)
-  printf ("arm-acorn-riscix"); exit (0);
+  printf ("arm-acorn-riscix\n"); exit (0);
+#endif
+
+#if defined (hp9000) && !defined (hpux)
+  printf ("m68k-hp-bsd\n"); exit (0);
 #endif
 
 #if defined (hp300) && !defined (hpux)
@@ -1212,35 +1166,129 @@ main ()
 #endif
 
 #if defined (vax)
-# if !defined (ultrix)
-#  include <sys/param.h>
-#  if defined (BSD)
-#   if BSD == 43
-      printf ("vax-dec-bsd4.3\n"); exit (0);
-#   else
-#    if BSD == 199006
-      printf ("vax-dec-bsd4.3reno\n"); exit (0);
-#    else
-      printf ("vax-dec-bsd\n"); exit (0);
-#    endif
-#   endif
-#  else
-    printf ("vax-dec-bsd\n"); exit (0);
-#  endif
-# else
-    printf ("vax-dec-ultrix\n"); exit (0);
-# endif
+#if !defined (ultrix)
+  printf ("vax-dec-bsd\n"); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
 #endif
 
 #if defined (alliant) && defined (i860)
   printf ("i860-alliant-bsd\n"); exit (0);
 #endif
 
+/* Begin cases added for Bash */
+#if defined (tahoe)
+  printf ("tahoe-cci-bsd\n"); exit (0);
+#endif
+
+#if defined (nec_ews)
+#  if defined (SYSTYPE_SYSV)
+  printf ("ews4800-nec-sysv4\n"); exit 0;
+#  else
+  printf ("ews4800-nec-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (sony)
+#  if defined (SYSTYPE_SYSV)
+  printf ("mips-sony-sysv4\n"); exit 0;
+#  else
+  printf ("mips-sony-bsd\n"); exit (0);
+#  endif
+#endif
+
+#if defined (ardent)
+  printf ("titan-ardent-bsd\n"); exit (0);
+#endif
+
+#if defined (stardent)
+  printf ("stardent-stardent-sysv\n"); exit (0);
+#endif
+
+#if defined (ibm032)
+  printf ("ibmrt-ibm-bsd4.3\n"); exit (0);
+#endif
+
+#if defined (sequent) && defined (i386)
+  printf ("i386-sequent-bsd\n"); exit (0);
+#endif
+
+#if defined (qnx) && defined (i386)
+  printf ("i386-pc-qnx\n"); exit (0);
+#endif
+
+#if defined (gould)
+  printf ("gould-gould-bsd\n"); exit (0);
+#endif
+
+#if defined (unixpc)
+  printf ("unixpc-att-sysv\n"); exit (0);
+#endif
+
+#if defined (att386)
+  printf ("i386-att-sysv3\n"); exit (0);
+#endif
+
+#if defined (__m88k) && defined (__UMAXV__)
+  printf ("m88k-encore-sysv3\n"); exit (0);
+#endif
+
+#if defined (drs6000)
+  printf ("drs6000-icl-sysv4.2\n"); exit (0);
+#endif
+
+#if defined (clipper)
+  printf ("clipper-orion-bsd\n"); exit (0);
+#endif
+
+#if defined (is68k)
+  printf ("m68k-isi-bsd\n"); exit (0);
+#endif
+
+#if defined (luna88k)
+  printf ("luna88k-omron-bsd\n"); exit (0);
+#endif
+
+#if defined (butterfly) && defined (BFLY1)
+  printf ("butterfly-bbn-mach\n"); exit (0);
+#endif
+
+#if defined (tower32)
+  printf ("tower32-ncr-sysv4\n"); exit (0);
+#endif
+
+#if defined (MagicStation)
+  printf ("magicstation-unknown-bsd\n"); exit (0);
+#endif
+
+#if defined (scs)
+  printf ("symmetric-scs-bsd4.2\n"); exit (0);
+#endif
+
+#if defined (tandem)
+  printf ("tandem-tandem-sysv\n"); exit (0);
+#endif
+
+#if defined (cadmus)
+  printf ("cadmus-pcs-sysv\n"); exit (0);
+#endif
+
+#if defined (masscomp)
+  printf ("masscomp-masscomp-sysv3\n"); exit (0);
+#endif
+
+#if defined (hbullx20)
+  printf ("hbullx20-bull-sysv3\n"); exit (0);
+#endif
+
+/* End cases added for Bash */
+
   exit (1);
 }
 EOF
 
-$CC_FOR_BUILD $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm -f $dummy.c $dummy && exit 0
+${CC-cc} $dummy.c -o $dummy 2>/dev/null && ./$dummy && rm $dummy.c $dummy && exit 0
 rm -f $dummy.c $dummy
 
 # Apollos put the system type in the environment.
@@ -1273,48 +1321,21 @@ then
     esac
 fi
 
-cat >&2 <<EOF
-$0: unable to guess system type
+# Begin cases added for Bash
+case "$UNAME" in
+uts) echo uts-amdahl-sysv${UNAME_RELEASE}; exit 0 ;;
+esac
 
-This script, last modified $timestamp, has failed to recognize
-the operating system you are using. It is advised that you
-download the most up to date version of the config scripts from
-
-    ftp://ftp.gnu.org/pub/gnu/config/
-
-If the version you run ($0) is already up to date, please
-send the following data and any information you think might be
-pertinent to <config-patches@gnu.org> in order to provide the needed
-information to handle your system.
-
-config.guess timestamp = $timestamp
-
-uname -m = `(uname -m) 2>/dev/null || echo unknown`
-uname -r = `(uname -r) 2>/dev/null || echo unknown`
-uname -s = `(uname -s) 2>/dev/null || echo unknown`
-uname -v = `(uname -v) 2>/dev/null || echo unknown`
-
-/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
-/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
-
-hostinfo               = `(hostinfo) 2>/dev/null`
-/bin/universe          = `(/bin/universe) 2>/dev/null`
-/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
-/bin/arch              = `(/bin/arch) 2>/dev/null`
-/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
-/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
-
-UNAME_MACHINE = ${UNAME_MACHINE}
-UNAME_RELEASE = ${UNAME_RELEASE}
-UNAME_SYSTEM  = ${UNAME_SYSTEM}
-UNAME_VERSION = ${UNAME_VERSION}
-EOF
+if [ -d /usr/amiga ]; then
+	echo m68k-cbm-sysv${UNAME_RELEASE}; exit 0;
+fi
 
-exit 1
+if [ -f /bin/fxc.info ]; then
+	echo fxc-alliant-concentrix
+	exit 0
+fi
+# end cases added for Bash
 
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
+#echo '(Unable to guess system type)' 1>&2
+
+exit 1
Index: readline/support/config.sub
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/support/config.sub,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 config.sub
--- readline/support/config.sub	2003/02/16 21:36:34	1.1.1.1
+++ readline/support/config.sub	2001/02/12 17:50:05
@@ -1,10 +1,6 @@
 #! /bin/sh
-# Configuration validation subroutine script.
-#   Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
-#   2000, 2001, 2002 Free Software Foundation, Inc.
-
-timestamp='2002-02-22'
-
+# Configuration validation subroutine script, version 1.1.
+#   Copyright (C) 1991, 92, 93, 94, 95, 1996 Free Software Foundation, Inc.
 # This file is (in principle) common to ALL GNU software.
 # The presence of a machine in this file suggests that SOME GNU software
 # can handle that machine.  It does not imply ALL GNU software can.
@@ -29,9 +25,6 @@ timestamp='2002-02-22'
 # configuration script generated by Autoconf, you may include it under
 # the same distribution terms that you use for the rest of that program.
 
-# Please send patches to <config-patches@gnu.org>.  Submit a context
-# diff and a properly formatted ChangeLog entry.
-#
 # Configuration subroutine to validate and canonicalize a configuration type.
 # Supply the specified configuration type as an argument.
 # If it is invalid, we print an error message on stderr and exit with code 1.
@@ -52,73 +45,30 @@ timestamp='2002-02-22'
 #	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
 # It is wrong to echo any other type of specification.
 
-me=`echo "$0" | sed -e 's,.*/,,'`
+if [ x$1 = x ]
+then
+	echo Configuration name missing. 1>&2
+	echo "Usage: $0 CPU-MFR-OPSYS" 1>&2
+	echo "or     $0 ALIAS" 1>&2
+	echo where ALIAS is a recognized configuration type. 1>&2
+	exit 1
+fi
 
-usage="\
-Usage: $0 [OPTION] CPU-MFR-OPSYS
-       $0 [OPTION] ALIAS
-
-Canonicalize a configuration name.
-
-Operation modes:
-  -h, --help         print this help, then exit
-  -t, --time-stamp   print date of last modification, then exit
-  -v, --version      print version number, then exit
-
-Report bugs and patches to <config-patches@gnu.org>."
-
-version="\
-GNU config.sub ($timestamp)
-
-Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
-Free Software Foundation, Inc.
-
-This is free software; see the source for copying conditions.  There is NO
-warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
-
-help="
-Try \`$me --help' for more information."
-
-# Parse command line
-while test $# -gt 0 ; do
-  case $1 in
-    --time-stamp | --time* | -t )
-       echo "$timestamp" ; exit 0 ;;
-    --version | -v )
-       echo "$version" ; exit 0 ;;
-    --help | --h* | -h )
-       echo "$usage"; exit 0 ;;
-    -- )     # Stop option processing
-       shift; break ;;
-    - )	# Use stdin as input.
-       break ;;
-    -* )
-       echo "$me: invalid option $1$help"
-       exit 1 ;;
-
-    *local*)
-       # First pass through any local machine types.
-       echo $1
-       exit 0;;
-
-    * )
-       break ;;
-  esac
-done
-
-case $# in
- 0) echo "$me: missing argument$help" >&2
-    exit 1;;
- 1) ;;
- *) echo "$me: too many arguments$help" >&2
-    exit 1;;
+# First pass through any local machine types.
+case $1 in
+	*local*)
+		echo $1
+		exit 0
+		;;
+	*)
+	;;
 esac
 
 # Separate what the user gave into CPU-COMPANY and OS or KERNEL-OS (if any).
 # Here we must recognize all the valid KERNEL-OS combinations.
 maybe_os=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\2/'`
 case $maybe_os in
-  nto-qnx* | linux-gnu* | storm-chaos* | os2-emx* | windows32-* | rtmk-nova*)
+  linux-gnu*)
     os=-$maybe_os
     basic_machine=`echo $1 | sed 's/^\(.*\)-\([^-]*-[^-]*\)$/\1/'`
     ;;
@@ -144,7 +94,7 @@ case $os in
 	-convergent* | -ncr* | -news | -32* | -3600* | -3100* | -hitachi* |\
 	-c[123]* | -convex* | -sun | -crds | -omron* | -dg | -ultra | -tti* | \
 	-harris | -dolphin | -highlevel | -gould | -cbm | -ns | -masscomp | \
-	-apple | -axis)
+	-apple )
 		os=
 		basic_machine=$1
 		;;
@@ -155,17 +105,9 @@ case $os in
 	-scout)
 		;;
 	-wrs)
-		os=-vxworks
-		basic_machine=$1
-		;;
-	-chorusos*)
-		os=-chorusos
+		os=vxworks
 		basic_machine=$1
 		;;
- 	-chorusrdb)
- 		os=-chorusrdb
-		basic_machine=$1
- 		;;
 	-hiux*)
 		os=-hiuxwe2
 		;;
@@ -214,60 +156,33 @@ case $os in
 	-psos*)
 		os=-psos
 		;;
-	-mint | -mint[0-9]*)
-		basic_machine=m68k-atari
-		os=-mint
-		;;
 esac
 
 # Decode aliases for certain CPU-COMPANY combinations.
 case $basic_machine in
 	# Recognize the basic CPU types without company name.
 	# Some are omitted here because they have special meanings below.
-	1750a | 580 \
-	| a29k \
-	| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] | alphapca5[67] \
-	| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] | alpha64pca5[67] \
-	| arc | arm | arm[bl]e | arme[lb] | armv[2345] | armv[345][lb] | avr \
-	| c4x | clipper \
-	| d10v | d30v | dsp16xx \
-	| fr30 \
-	| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
-	| i370 | i860 | i960 | ia64 \
-	| m32r | m68000 | m68k | m88k | mcore \
-	| mips | mips16 | mips64 | mips64el | mips64orion | mips64orionel \
-	| mips64vr4100 | mips64vr4100el | mips64vr4300 \
-	| mips64vr4300el | mips64vr5000 | mips64vr5000el \
-	| mipsbe | mipseb | mipsel | mipsle | mipstx39 | mipstx39el \
-	| mipsisa32 \
-	| mn10200 | mn10300 \
-	| ns16k | ns32k \
-	| openrisc | or32 \
-	| pdp10 | pdp11 | pj | pjl \
-	| powerpc | powerpc64 | powerpc64le | powerpcle | ppcbe \
-	| pyramid \
-	| sh | sh[34] | sh[34]eb | shbe | shle | sh64 \
-	| sparc | sparc64 | sparclet | sparclite | sparcv9 | sparcv9b \
-	| strongarm \
-	| tahoe | thumb | tic80 | tron \
-	| v850 | v850e \
-	| we32k \
-	| x86 | xscale | xstormy16 | xtensa \
-	| z8k)
-		basic_machine=$basic_machine-unknown
-		;;
-	m6811 | m68hc11 | m6812 | m68hc12)
-		# Motorola 68HC11/12.
+	tahoe | i860 | ia64 | m32r | m68k | m68000 | m88k | ns32k | arc | arm \
+		| arme[lb] | pyramid | mn10200 | mn10300 | tron | a29k \
+		| 580 | i960 | h8300 \
+		| hppa | hppa1.0 | hppa1.1 | hppa2.0 | hppa2.0w | hppa2.0n \
+		| alpha | alphaev[4-7] | alphaev56 | alphapca5[67] \
+		| we32k | ns16k | clipper | i370 | sh | powerpc | powerpcle \
+		| 1750a | dsp16xx | pdp11 | mips16 | mips64 | mipsel | mips64el \
+		| mips64orion | mips64orionel | mipstx39 | mipstx39el \
+		| mips64vr4300 | mips64vr4300el | mips64vr4100 | mips64vr4100el \
+		| mips64vr5000 | miprs64vr5000el | mcore \
+		| sparc | sparclet | sparclite | sparc64 | sparcv9 | v850 | c4x \
+	        | thumb | d10v | s390)
 		basic_machine=$basic_machine-unknown
-		os=-none
 		;;
-	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | v70 | w65 | z8k)
+	m88110 | m680[12346]0 | m683?2 | m68360 | m5200 | z8k | v70 | h8500 | w65)
 		;;
 
 	# We use `pc' rather than `unknown'
 	# because (1) that's what they normally are, and
 	# (2) the word "unknown" tends to confuse beginning users.
-	i*86 | x86_64)
+	i[34567]86)
 	  basic_machine=$basic_machine-pc
 	  ;;
 	# Object if more than one company name word.
@@ -276,46 +191,33 @@ case $basic_machine in
 		exit 1
 		;;
 	# Recognize the basic CPU types with company name.
-	580-* \
-	| a29k-* \
-	| alpha-* | alphaev[4-8]-* | alphaev56-* | alphaev6[78]-* \
-	| alpha64-* | alpha64ev[4-8]-* | alpha64ev56-* | alpha64ev6[78]-* \
-	| alphapca5[67]-* | alpha64pca5[67]-* | arc-* \
-	| arm-*  | armbe-* | armle-* | armv*-* \
-	| avr-* \
-	| bs2000-* \
-	| c[123]* | c30-* | [cjt]90-* | c54x-* \
-	| clipper-* | cydra-* \
-	| d10v-* | d30v-* \
-	| elxsi-* \
-	| f30[01]-* | f700-* | fr30-* | fx80-* \
-	| h8300-* | h8500-* \
-	| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \
-	| i*86-* | i860-* | i960-* | ia64-* \
-	| m32r-* \
-	| m68000-* | m680[012346]0-* | m68360-* | m683?2-* | m68k-* \
-	| m88110-* | m88k-* | mcore-* \
-	| mips-* | mips16-* | mips64-* | mips64el-* | mips64orion-* \
-	| mips64orionel-* | mips64vr4100-* | mips64vr4100el-* \
-	| mips64vr4300-* | mips64vr4300el-* | mipsbe-* | mipseb-* \
-	| mipsle-* | mipsel-* | mipstx39-* | mipstx39el-* \
-	| none-* | np1-* | ns16k-* | ns32k-* \
-	| orion-* \
-	| pdp10-* | pdp11-* | pj-* | pjl-* | pn-* | power-* \
-	| powerpc-* | powerpc64-* | powerpc64le-* | powerpcle-* | ppcbe-* \
-	| pyramid-* \
-	| romp-* | rs6000-* \
-	| sh-* | sh[34]-* | sh[34]eb-* | shbe-* | shle-* | sh64-* \
-	| sparc-* | sparc64-* | sparc86x-* | sparclite-* \
-	| sparcv9-* | sparcv9b-* | strongarm-* | sv1-* | sx?-* \
-	| tahoe-* | thumb-* | tic30-* | tic54x-* | tic80-* | tron-* \
-	| v850-* | v850e-* | vax-* \
-	| we32k-* \
-	| x86-* | x86_64-* | xps100-* | xscale-* | xstormy16-* \
-	| xtensa-* \
-	| ymp-* \
-	| z8k-*)
+	# FIXME: clean up the formatting here.
+	vax-* | tahoe-* | i[34567]86-* | i860-* | ia64-* | m32r-* | m68k-* | m68000-* \
+	      | m88k-* | sparc-* | ns32k-* | fx80-* | arc-* | arm-* | c[123]* \
+	      | mips-* | pyramid-* | tron-* | a29k-* | romp-* | rs6000-* \
+	      | power-* | none-* | 580-* | cray2-* | h8300-* | h8500-* | i960-* \
+	      | xmp-* | ymp-* \
+	      | hppa-* | hppa1.0-* | hppa1.1-* | hppa2.0-* | hppa2.0w-* | hppa2.0n-* \
+	      | alpha-* | alphaev[4-7]-* | alphaev56-* | alphapca5[67]-* \
+	      | we32k-* | cydra-* | ns16k-* | pn-* | np1-* | xps100-* \
+	      | clipper-* | orion-* \
+	      | sparclite-* | pdp11-* | sh-* | powerpc-* | powerpcle-* \
+	      | sparc64-* | sparcv9-* | sparc86x-* | mips16-* | mips64-* | mipsel-* \
+	      | mips64el-* | mips64orion-* | mips64orionel-* \
+	      | mips64vr4100-* | mips64vr4100el-* | mips64vr4300-* | mips64vr4300el-* \
+	      | mipstx39-* | mipstx39el-* | mcore-* \
+	      | f301-* | armv*-* | t3e-* \
+	      | m88110-* | m680[01234]0-* | m683?2-* | m68360-* | z8k-* | d10v-* \
+	      | thumb-* | v850-* | d30v-* | tic30-* | c30-* )
+		;;
+	# BEGIN cases added for Bash
+	butterfly-bbn* | cadmus-* | ews*-nec | ibmrt-ibm* | masscomp-masscomp \
+	      | tandem-* | symmetric-* | drs6000-icl | *-*ardent | gould-gould \
+	      | concurrent-* | ksr1-* | esa-ibm | fxc-alliant | *370-amdahl \
+	      | *-convex | sx[45]*-nec )
 		;;
+	# END cases added for Bash
+
 	# Recognize the various machine names and aliases which stand
 	# for a CPU type and a company and sometimes even an OS.
 	386bsd)
@@ -351,14 +253,15 @@ case $basic_machine in
 		os=-sysv
 		;;
 	amiga | amiga-*)
+#		basic_machine=m68k-cbm
 		basic_machine=m68k-unknown
 		;;
 	amigaos | amigados)
-		basic_machine=m68k-unknown
+		basic_machine=m68k-cbm
 		os=-amigaos
 		;;
 	amigaunix | amix)
-		basic_machine=m68k-unknown
+		basic_machine=m68k-cbm
 		os=-sysv4
 		;;
 	apollo68)
@@ -377,10 +280,6 @@ case $basic_machine in
 		basic_machine=ns32k-sequent
 		os=-dynix
 		;;
-	c90)
-		basic_machine=c90-cray
-		os=-unicos
-		;;
 	convex-c1)
 		basic_machine=c1-convex
 		os=-bsd
@@ -401,30 +300,27 @@ case $basic_machine in
 		basic_machine=c38-convex
 		os=-bsd
 		;;
-	cray | j90)
-		basic_machine=j90-cray
+	cray | ymp)
+		basic_machine=ymp-cray
 		os=-unicos
 		;;
+	cray2)
+		basic_machine=cray2-cray
+		os=-unicos
+		;;
+	[ctj]90-cray)
+		basic_machine=c90-cray
+		os=-unicos
+		;;
 	crds | unos)
 		basic_machine=m68k-crds
 		;;
-	cris | cris-* | etrax*)
-		basic_machine=cris-axis
-		;;
 	da30 | da30-*)
 		basic_machine=m68k-da30
 		;;
 	decstation | decstation-3100 | pmax | pmax-* | pmin | dec3100 | decstatn)
 		basic_machine=mips-dec
 		;;
-	decsystem10* | dec10*)
-		basic_machine=pdp10-dec
-		os=-tops10
-		;;
-	decsystem20* | dec20*)
-		basic_machine=pdp10-dec
-		os=-tops20
-		;;
 	delta | 3300 | motorola-3300 | motorola-delta \
 	      | 3300-motorola | delta-motorola)
 		basic_machine=m68k-motorola
@@ -441,6 +337,9 @@ case $basic_machine in
 		basic_machine=m68k-bull
 		os=-sysv3
 		;;
+	hbullx20-bull)
+		basic_machine=m68k-bull
+		;;
 	ebmon29k)
 		basic_machine=a29k-amd
 		os=-ebmon
@@ -449,7 +348,7 @@ case $basic_machine in
 		basic_machine=elxsi-elxsi
 		os=-bsd
 		;;
-	encore | umax | mmax)
+	encore | umax | mmax | multimax)
 		basic_machine=ns32k-encore
 		;;
 	es1800 | OSE68k | ose68k | ose | OSE)
@@ -466,10 +365,6 @@ case $basic_machine in
 		basic_machine=tron-gmicro
 		os=-sysv
 		;;
-	go32)
-		basic_machine=i386-pc
-		os=-go32
-		;;
 	h3050r* | hiux*)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
@@ -541,23 +436,27 @@ case $basic_machine in
 		basic_machine=hppa1.1-hp
 		os=-proelf
 		;;
+	ibm032-*)
+		basic_machine=ibmrt-ibm
+		;;
 	i370-ibm* | ibm*)
 		basic_machine=i370-ibm
+		os=-mvs
 		;;
 # I'm not sure what "Sysv32" means.  Should this be sysv3.2?
-	i*86v32)
+	i[34567]86v32)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv32
 		;;
-	i*86v4*)
+	i[34567]86v4*)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv4
 		;;
-	i*86v)
+	i[34567]86v)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-sysv
 		;;
-	i*86sol2)
+	i[34567]86sol2)
 		basic_machine=`echo $1 | sed -e 's/86.*/86-pc/'`
 		os=-solaris2
 		;;
@@ -569,6 +468,14 @@ case $basic_machine in
 		basic_machine=i386-unknown
 		os=-vsta
 		;;
+	i386-go32 | go32)
+		basic_machine=i386-unknown
+		os=-go32
+		;;
+	i386-mingw32 | mingw32)
+		basic_machine=i386-unknown
+		os=-mingw32
+		;;
 	iris | iris4d)
 		basic_machine=mips-sgi
 		case $os in
@@ -583,9 +490,12 @@ case $basic_machine in
 		basic_machine=m68k-isi
 		os=-sysv
 		;;
-	m88k-omron*)
+	luna88k-omron* | m88k-omron*)
 		basic_machine=m88k-omron
 		;;
+	magicstation*)
+		basic_machine=magicstation-unknown
+		;;
 	magnum | m3230)
 		basic_machine=mips-mips
 		os=-sysv
@@ -594,43 +504,35 @@ case $basic_machine in
 		basic_machine=ns32k-utek
 		os=-sysv
 		;;
-	mingw32)
-		basic_machine=i386-pc
-		os=-mingw32
-		;;
 	miniframe)
 		basic_machine=m68000-convergent
 		;;
-	*mint | -mint[0-9]* | *MiNT | *MiNT[0-9]*)
+	*mint | *MiNT)
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	mipsel*-linux*)
+		basic_machine=mipsel-unknown
+		os=-linux-gnu
+		;;
+	mips*-linux*)
+		basic_machine=mips-unknown
+		os=-linux-gnu
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
 	mips3*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`-unknown
 		;;
-	mmix*)
-		basic_machine=mmix-knuth
-		os=-mmixware
-		;;
 	monitor)
 		basic_machine=m68k-rom68k
 		os=-coff
 		;;
-	morphos)
-		basic_machine=powerpc-unknown
-		os=-morphos
-		;;
 	msdos)
-		basic_machine=i386-pc
+		basic_machine=i386-unknown
 		os=-msdos
 		;;
-	mvs)
-		basic_machine=i370-ibm
-		os=-mvs
-		;;
 	ncr3000)
 		basic_machine=i486-ncr
 		os=-sysv4
@@ -640,7 +542,7 @@ case $basic_machine in
 		os=-netbsd
 		;;
 	netwinder)
-		basic_machine=armv4l-rebel
+		basic_machine=armv4l-corel
 		os=-linux
 		;;
 	news | news700 | news800 | news900)
@@ -654,11 +556,11 @@ case $basic_machine in
 	news-3600 | risc-news)
 		basic_machine=mips-sony
 		os=-newsos
-		;;
-	necv70)
-		basic_machine=v70-nec
-		os=-sysv
 		;;
+        necv70)
+                basic_machine=v70-nec
+                os=-sysv
+                ;;
 	next | m*-next )
 		basic_machine=m68k-next
 		case $os in
@@ -684,36 +586,33 @@ case $basic_machine in
 		basic_machine=i960-intel
 		os=-nindy
 		;;
-	mon960)
-		basic_machine=i960-intel
-		os=-mon960
-		;;
-	nonstopux)
-		basic_machine=mips-compaq
-		os=-nonstopux
-		;;
+        mon960)
+                basic_machine=i960-intel
+                os=-mon960
+                ;;
 	np1)
 		basic_machine=np1-gould
-		;;
-	nsr-tandem)
-		basic_machine=nsr-tandem
-		;;
-	op50n-* | op60c-*)
-		basic_machine=hppa1.1-oki
-		os=-proelf
 		;;
-	or32 | or32-*)
-		basic_machine=or32-unknown
-		os=-coff
-		;;
-	OSE68000 | ose68000)
-		basic_machine=m68000-ericsson
-		os=-ose
+	osr5 | sco5)	# SCO Open Server
+		basic_machine=i386-pc
+		os=-sco3.2v5
 		;;
-	os68k)
-		basic_machine=m68k-none
-		os=-os68k
+	odt | odt3 | odt4)	# SCO Open Desktop
+		basic_machine=i386-pc
+		os=-sco3.2v4
 		;;
+        op50n-* | op60c-*)
+                basic_machine=hppa1.1-oki
+                os=-proelf
+                ;;
+        OSE68000 | ose68000)
+                basic_machine=m68000-ericsson
+                os=-ose
+                ;;
+        os68k)
+                basic_machine=m68k-none
+                os=-os68k
+                ;;
 	pa-hitachi)
 		basic_machine=hppa1.1-hitachi
 		os=-hiuxwe2
@@ -728,79 +627,63 @@ case $basic_machine in
 	pbb)
 		basic_machine=m68k-tti
 		;;
-        pc532 | pc532-*)
+	pc532 | pc532-*)
 		basic_machine=ns32k-pc532
-		;;
-	pentium | p5 | k5 | k6 | nexgen | viac3)
-		basic_machine=i586-pc
 		;;
-	pentiumpro | p6 | 6x86 | athlon)
-		basic_machine=i686-pc
+	pentium | p5 | k5 | k6 | nexen)
+		basic_machine=i586-intel
 		;;
+        pentiumpro | p6 | 6x86)
+                basic_machine=i686-pc
+                ;;
 	pentiumii | pentium2)
-		basic_machine=i686-pc
+		basic_machine=i786-pc
 		;;
-	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+	pentium-* | p5-* | k5-* | k6-* | nexen-*)
 		basic_machine=i586-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	pentiumpro-* | p6-* | 6x86-* | athlon-*)
+	pentiumpro-* | p6-* | 6x86*)
 		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pentiumii-* | pentium2-*)
-		basic_machine=i686-`echo $basic_machine | sed 's/^[^-]*-//'`
+		basic_machine=i786-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	pn)
 		basic_machine=pn-gould
 		;;
-	power)	basic_machine=power-ibm
+	power)	basic_machine=rs6000-ibm
 		;;
 	ppc)	basic_machine=powerpc-unknown
-	        ;;
+		;;
 	ppc-*)	basic_machine=powerpc-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
 	ppcle | powerpclittle | ppc-le | powerpc-little)
 		basic_machine=powerpcle-unknown
-	        ;;
+		;;
 	ppcle-* | powerpclittle-*)
 		basic_machine=powerpcle-`echo $basic_machine | sed 's/^[^-]*-//'`
 		;;
-	ppc64)	basic_machine=powerpc64-unknown
-	        ;;
-	ppc64-*) basic_machine=powerpc64-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
-	ppc64le | powerpc64little | ppc64-le | powerpc64-little)
-		basic_machine=powerpc64le-unknown
-	        ;;
-	ppc64le-* | powerpc64little-*)
-		basic_machine=powerpc64le-`echo $basic_machine | sed 's/^[^-]*-//'`
-		;;
 	ps2)
 		basic_machine=i386-ibm
 		;;
-	pw32)
-		basic_machine=i586-unknown
-		os=-pw32
-		;;
-	rom68k)
-		basic_machine=m68k-rom68k
-		os=-coff
-		;;
+        rom68k)
+                basic_machine=m68k-rom68k
+                os=-coff
+                ;;
 	rm[46]00)
 		basic_machine=mips-siemens
 		;;
 	rtpc | rtpc-*)
 		basic_machine=romp-ibm
 		;;
-	s390 | s390-*)
+	s390-*)
 		basic_machine=s390-ibm
-		;;
-	s390x | s390x-*)
-		basic_machine=s390x-ibm
-		;;
-	sa29200)
-		basic_machine=a29k-amd
-		os=-udi
+		os=-linux
 		;;
+        sa29200)
+                basic_machine=a29k-amd
+                os=-udi
+                ;;
 	sequent)
 		basic_machine=i386-sequent
 		;;
@@ -808,24 +691,24 @@ case $basic_machine in
 		basic_machine=sh-hitachi
 		os=-hms
 		;;
-	sparclite-wrs | simso-wrs)
-		basic_machine=sparclite-wrs
-		os=-vxworks
-		;;
+        sparclite-wrs)
+                basic_machine=sparclite-wrs
+                os=-vxworks
+                ;;
 	sps7)
 		basic_machine=m68k-bull
 		os=-sysv2
 		;;
 	spur)
 		basic_machine=spur-unknown
-		;;
-	st2000)
-		basic_machine=m68k-tandem
 		;;
-	stratus)
-		basic_machine=i860-stratus
-		os=-sysv4
-		;;
+        st2000)
+                basic_machine=m68k-tandem
+                ;;
+        stratus)
+                basic_machine=i860-stratus
+                os=-sysv4
+                ;;
 	sun2)
 		basic_machine=m68000-sun
 		;;
@@ -866,40 +749,20 @@ case $basic_machine in
 	sun386 | sun386i | roadrunner)
 		basic_machine=i386-sun
 		;;
-        sv1)
-		basic_machine=sv1-cray
-		os=-unicos
-		;;
 	symmetry)
 		basic_machine=i386-sequent
 		os=-dynix
 		;;
-	t3d)
-		basic_machine=alpha-cray
-		os=-unicos
-		;;
-	t3e)
-		basic_machine=alphaev5-cray
-		os=-unicos
-		;;
-	t90)
-		basic_machine=t90-cray
-		os=-unicos
-		;;
-	tic54x | c54x*)
-		basic_machine=tic54x-unknown
-		os=-coff
-		;;
-	tx39)
-		basic_machine=mipstx39-unknown
-		;;
-	tx39el)
-		basic_machine=mipstx39el-unknown
-		;;
-	toad1)
-		basic_machine=pdp10-xkl
-		os=-tops20
-		;;
+        t3e)
+                basic_machine=t3e-cray
+                os=-unicos
+                ;;
+        tx39)
+                basic_machine=mipstx39-unknown
+                ;;
+        tx39el)
+                basic_machine=mipstx39el-unknown
+                ;;
 	tower | tower-32)
 		basic_machine=m68k-ncr
 		;;
@@ -911,10 +774,18 @@ case $basic_machine in
 		basic_machine=a29k-nyu
 		os=-sym1
 		;;
-	v810 | necv810)
-		basic_machine=v810-nec
-		os=-none
+	uw2 | unixware | unixware2)
+		basic_machine=i386-pc
+		os=-sysv4.2uw2.1
 		;;
+	uw7 | unixware7)
+		basic_machine=i386-pc
+		os=-sysv5uw7
+		;;
+        v810 | necv810)
+                basic_machine=v810-nec
+                os=-none
+                ;;
 	vaxv)
 		basic_machine=vax-dec
 		os=-sysv
@@ -924,8 +795,8 @@ case $basic_machine in
 		os=-vms
 		;;
 	vpp*|vx|vx-*)
-               basic_machine=f301-fujitsu
-               ;;
+		basic_machine=f301-fujitsu
+		;;
 	vxworks960)
 		basic_machine=i960-wrs
 		os=-vxworks
@@ -937,30 +808,26 @@ case $basic_machine in
 	vxworks29k)
 		basic_machine=a29k-wrs
 		os=-vxworks
-		;;
-	w65*)
-		basic_machine=w65-wdc
-		os=-none
-		;;
-	w89k-*)
-		basic_machine=hppa1.1-winbond
-		os=-proelf
-		;;
-	windows32)
-		basic_machine=i386-pc
-		os=-windows32-msvcrt
 		;;
-        xps | xps100)
-		basic_machine=xps100-honeywell
-		;;
-	ymp)
-		basic_machine=ymp-cray
+        w65*)
+                basic_machine=w65-wdc
+                os=-none
+                ;;
+        w89k-*)
+                basic_machine=hppa1.1-winbond
+                os=-proelf
+                ;;
+	xmp)
+		basic_machine=xmp-cray
 		os=-unicos
 		;;
-	z8k-*-coff)
-		basic_machine=z8k-unknown
-		os=-sim
+	xps | xps100)
+		basic_machine=xps100-honeywell
 		;;
+        z8k-*-coff)
+                basic_machine=z8k-unknown
+                os=-sim
+                ;;
 	none)
 		basic_machine=none-none
 		os=-none
@@ -968,14 +835,21 @@ case $basic_machine in
 
 # Here we handle the default manufacturer of certain CPU types.  It is in
 # some cases the only manufacturer, in others, it is the most popular.
-	w89k)
-		basic_machine=hppa1.1-winbond
-		;;
-	op50n)
-		basic_machine=hppa1.1-oki
-		;;
-	op60c)
-		basic_machine=hppa1.1-oki
+        w89k)
+                basic_machine=hppa1.1-winbond
+                ;;
+        op50n)
+                basic_machine=hppa1.1-oki
+                ;;
+        op60c)
+                basic_machine=hppa1.1-oki
+                ;;
+	mips)
+		if test "x$os" = "x-linux-gnu" ; then
+			basic_machine=mips-unknown
+		else
+			basic_machine=mips-mips
+		fi
 		;;
 	romp)
 		basic_machine=romp-ibm
@@ -986,26 +860,16 @@ case $basic_machine in
 	vax)
 		basic_machine=vax-dec
 		;;
-	pdp10)
-		# there are many clones, so DEC is not a safe bet
-		basic_machine=pdp10-unknown
-		;;
 	pdp11)
 		basic_machine=pdp11-dec
 		;;
 	we32k)
 		basic_machine=we32k-att
-		;;
-	sh3 | sh4 | sh3eb | sh4eb)
-		basic_machine=sh-unknown
-		;;
-	sh64)
-		basic_machine=sh64-unknown
 		;;
-	sparc | sparcv9 | sparcv9b)
+	sparc | sparcv9)
 		basic_machine=sparc-sun
 		;;
-        cydra)
+	cydra)
 		basic_machine=cydra-cydrome
 		;;
 	orion)
@@ -1014,19 +878,16 @@ case $basic_machine in
 	orion105)
 		basic_machine=clipper-highlevel
 		;;
-	mac | mpw | mac-mpw)
-		basic_machine=m68k-apple
-		;;
-	pmac | pmac-mpw)
-		basic_machine=powerpc-apple
-		;;
-	c4x*)
-		basic_machine=c4x-none
-		os=-coff
-		;;
-	*-unknown)
-		# Make sure to match an already-canonicalized machine name.
-		;;
+        mac | mpw | mac-mpw)
+                basic_machine=m68k-apple
+                ;;
+        pmac | pmac-mpw)
+                basic_machine=powerpc-apple
+                ;;
+        c4x*)
+                basic_machine=c4x-none
+                os=-coff
+                ;;
 	*)
 		echo Invalid configuration \`$1\': machine \`$basic_machine\' not recognized 1>&2
 		exit 1
@@ -1050,8 +911,8 @@ esac
 if [ x"$os" != x"" ]
 then
 case $os in
-        # First match some system type aliases
-        # that might get confused with valid system types.
+	# First match some system type aliases
+	# that might get confused with valid system types.
 	# -solaris* is a basic system type, with this one exception.
 	-solaris1 | -solaris1.*)
 		os=`echo $os | sed -e 's|solaris1|sunos4|'`
@@ -1061,9 +922,15 @@ case $os in
 		;;
 	-svr4*)
 		os=-sysv4
+		;;
+	-unixware | -uw | -unixware2* | -uw2*)
+		os=-sysv4.2uw2.1
+		;;
+	-unixware7* | -uw7*)
+		os=-sysv5uw7
 		;;
-	-unixware*)
-		os=-sysv4.2uw
+        -unixware*)
+                os=-sysv4.2uw
 		;;
 	-gnu/linux*)
 		os=`echo $os | sed -e 's|gnu/linux|linux-gnu|'`
@@ -1083,35 +950,23 @@ case $os in
 	      | -lynxos* | -bosx* | -nextstep* | -cxux* | -aout* | -elf* | -oabi* \
 	      | -ptx* | -coff* | -ecoff* | -winnt* | -domain* | -vsta* \
 	      | -udi* | -eabi* | -lites* | -ieee* | -go32* | -aux* \
-	      | -chorusos* | -chorusrdb* \
 	      | -cygwin* | -pe* | -psos* | -moss* | -proelf* | -rtems* \
 	      | -mingw32* | -linux-gnu* | -uxpv* | -beos* | -mpeix* | -udk* \
-	      | -interix* | -uwin* | -rhapsody* | -darwin* | -opened* \
-	      | -openstep* | -oskit* | -conix* | -pw32* | -nonstopux* \
-	      | -storm-chaos* | -tops10* | -tenex* | -tops20* | -its* \
-	      | -os2* | -vos* | -palmos* | -uclinux* | -nucleus* \
-	      | -morphos* | -superux* | -rtmk* | -rtmk-nova*)
+	      | -interix* | -uwin* | -rhapsody* | -openstep* | -oskit*)
 	# Remember, each alternative MUST END IN *, to match a version number.
 		;;
-	-qnx*)
-		case $basic_machine in
-		    x86-* | i*86-*)
-			;;
-		    *)
-			os=-nto$os
-			;;
-		esac
-		;;
-	-nto*)
-		os=-nto-qnx
-		;;
-	-sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
-	      | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
-	      | -macos* | -mpw* | -magic* | -mmixware* | -mon960* | -lnews*)
+	# BEGIN CASES ADDED FOR Bash
+	-qnx* | -powerux* | -superux* | -darwin* | -nonstopux*)
 		;;
-	-mac*)
-		os=`echo $os | sed -e 's|mac|macos|'`
-		;;
+	# END CASES ADDED FOR Bash
+        -sim | -es1800* | -hms* | -xray | -os68k* | -none* | -v88r* \
+              | -windows* | -osx | -abug | -netware* | -os9* | -beos* \
+              | -macos* | -mpw* | -magic* | -mon960* | -lnews*)
+                ;;
+        -mac*)
+                os=`echo $os | sed -e 's|mac|macos|'`
+                ;;
+
 	-linux*)
 		os=`echo $os | sed -e 's|linux|linux-gnu|'`
 		;;
@@ -1121,12 +976,6 @@ case $os in
 	-sunos6*)
 		os=`echo $os | sed -e 's|sunos6|solaris3|'`
 		;;
-	-opened*)
-		os=-openedition
-		;;
-	-wince*)
-		os=-wince
-		;;
 	-osfrose*)
 		os=-osfrose
 		;;
@@ -1141,25 +990,16 @@ case $os in
 		;;
 	-acis*)
 		os=-aos
-		;;
-	-atheos*)
-		os=-atheos
 		;;
-	-386bsd)
-		os=-bsd
-		;;
+        -386bsd)
+                os=-bsd
+                ;;
 	-ctix* | -uts*)
 		os=-sysv
 		;;
-	-nova*)
-		os=-rtmk-nova
-		;;
 	-ns2 )
-	        os=-nextstep2
+		os=-nextstep2
 		;;
-	-nsk*)
-		os=-nsk
-		;;
 	# Preserve the version number of sinix5.
 	-sinix5.*)
 		os=`echo $os | sed -e 's|sinix|sysv|'`
@@ -1181,22 +1021,25 @@ case $os in
 		;;
 	-sysvr4)
 		os=-sysv4
-		;;
-	# This must come after -sysvr4.
-	-sysv*)
 		;;
-	-ose*)
-		os=-ose
+	-sysvr5)
+		os=-sysv5
 		;;
-	-es1800*)
-		os=-ose
+	# This must come after -sysvr[45].
+	-sysv*)
 		;;
+        -ose*)
+                os=-ose
+                ;;
+        -es1800*)
+                os=-ose
+                ;;
 	-xenix)
 		os=-xenix
 		;;
-        -*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-	        os=-mint
-		;;
+        -*mint | -*MiNT)
+                os=-mint
+                ;;
 	-none)
 		;;
 	*)
@@ -1222,17 +1065,10 @@ case $basic_machine in
 	*-acorn)
 		os=-riscix1.2
 		;;
-	arm*-rebel)
-		os=-linux
-		;;
 	arm*-semi)
 		os=-aout
 		;;
-	# This must come before the *-dec entry.
-	pdp10-*)
-		os=-tops20
-		;;
-        pdp11-*)
+	pdp11-*)
 		os=-none
 		;;
 	*-dec | vax-*)
@@ -1249,19 +1085,16 @@ case $basic_machine in
 		# This also exists in the configure program, but was not the
 		# default.
 		# os=-sunos4
-		;;
-	m68*-cisco)
-		os=-aout
 		;;
-	mips*-cisco)
-		os=-elf
-		;;
-	mips*-*)
-		os=-elf
-		;;
-	or32-*)
-		os=-coff
-		;;
+        m68*-cisco)
+                os=-aout
+                ;;
+        mips*-cisco)
+                os=-elf
+                ;;
+        mips*-*)
+                os=-elf
+                ;;
 	*-tti)	# must be before sparc entry or we get the wrong os.
 		os=-sysv3
 		;;
@@ -1273,16 +1106,16 @@ case $basic_machine in
 		;;
 	*-ibm)
 		os=-aix
-		;;
-	*-wec)
-		os=-proelf
-		;;
-	*-winbond)
-		os=-proelf
 		;;
-	*-oki)
-		os=-proelf
-		;;
+        *-wec)
+                os=-proelf
+                ;;
+        *-winbond)
+                os=-proelf
+                ;;
+        *-oki)
+                os=-proelf
+                ;;
 	*-hp)
 		os=-hpux
 		;;
@@ -1325,39 +1158,39 @@ case $basic_machine in
 	*-next)
 		os=-nextstep3
 		;;
-        *-gould)
+	*-gould)
 		os=-sysv
 		;;
-        *-highlevel)
+	*-highlevel)
 		os=-bsd
 		;;
 	*-encore)
 		os=-bsd
 		;;
-        *-sgi)
+	*-sgi)
 		os=-irix
 		;;
-        *-siemens)
+	*-siemens)
 		os=-sysv4
 		;;
 	*-masscomp)
 		os=-rtu
 		;;
-	f30[01]-fujitsu | f700-fujitsu)
+	f301-fujitsu)
 		os=-uxpv
-		;;
-	*-rom68k)
-		os=-coff
-		;;
-	*-*bug)
-		os=-coff
-		;;
-	*-apple)
-		os=-macos
-		;;
-	*-atari*)
-		os=-mint
 		;;
+        *-rom68k)
+                os=-coff
+                ;;
+        *-*bug)
+                os=-coff
+                ;;
+        *-apple)
+                os=-macos
+                ;;
+        *-atari*)
+                os=-mint
+                ;;
 	*)
 		os=-none
 		;;
@@ -1376,18 +1209,18 @@ case $basic_machine in
 			-sunos*)
 				vendor=sun
 				;;
+			-lynxos*)
+				vendor=lynx
+				;;
 			-aix*)
 				vendor=ibm
-				;;
-			-beos*)
-				vendor=be
 				;;
+                        -beos*)
+                                vendor=be
+                                ;;
 			-hpux*)
 				vendor=hp
 				;;
-			-mpeix*)
-				vendor=hp
-				;;
 			-hiux*)
 				vendor=hitachi
 				;;
@@ -1403,7 +1236,7 @@ case $basic_machine in
 			-genix*)
 				vendor=ns
 				;;
-			-mvs* | -opened*)
+			-mvs*)
 				vendor=ibm
 				;;
 			-ptx*)
@@ -1414,30 +1247,19 @@ case $basic_machine in
 				;;
 			-aux*)
 				vendor=apple
-				;;
-			-hms*)
-				vendor=hitachi
 				;;
-			-mpw* | -macos*)
-				vendor=apple
-				;;
-			-*mint | -mint[0-9]* | -*MiNT | -MiNT[0-9]*)
-				vendor=atari
-				;;
-			-vos*)
-				vendor=stratus
-				;;
+                        -hms*)
+                                vendor=hitachi
+                                ;;
+                        -mpw* | -macos*)
+                                vendor=apple
+                                ;;
+                        -*mint | -*MiNT)
+                                vendor=atari
+                                ;;
 		esac
 		basic_machine=`echo $basic_machine | sed "s/unknown/$vendor/"`
 		;;
 esac
 
 echo $basic_machine$os
-exit 0
-
-# Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
-# time-stamp-start: "timestamp='"
-# time-stamp-format: "%:y-%02m-%02d"
-# time-stamp-end: "'"
-# End:
Index: readline/support/shlib-install
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/support/shlib-install,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 shlib-install
--- readline/support/shlib-install	2003/02/16 21:36:34	1.1.1.1
+++ readline/support/shlib-install	2000/09/12 14:26:14
@@ -66,7 +66,7 @@ fi
 # HP-UX requires that a shared library have execute permission
 case "$host_os" in
 hpux*)	if [ -z "$uninstall" ]; then
-		chmod 755 ${INSTALLDIR}/${LIBNAME}
+		chmod 555 ${INSTALLDIR}/${LIBNAME}
 	fi ;;
 *)	;;
 esac
@@ -84,6 +84,9 @@ case "$LIBNAME" in
 	;;
 esac
 
+INSTALL_LINK1='cd $INSTALLDIR ; ln -s $LIBNAME $LINK1'
+INSTALL_LINK2='cd $INSTALLDIR ; ln -s $LIBNAME $LINK2'
+
 #
 # Create symlinks to the installed library.  This section is incomplete.
 #
@@ -92,13 +95,13 @@ case "$host_os" in
 	# libname.so.M -> libname.so.M.N
 	${echo} ${RM} ${INSTALLDIR}/$LINK2
 	if [ -z "$uninstall" ]; then
-		${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK2
+		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK2
 	fi
 
 	# libname.so -> libname.so.M.N
 	${echo} ${RM} ${INSTALLDIR}/$LINK1
 	if [ -z "$uninstall" ]; then
-		${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK1
+		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
 	fi
 	;;
 
@@ -106,7 +109,7 @@ solaris2*|aix4.[2-9]*|osf*|irix[56]*)
 	# libname.so -> libname.so.M
 	${echo} ${RM} ${INSTALLDIR}/$LINK1
 	if [ -z "$uninstall" ]; then
-		${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK1
+		${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
 	fi
 	;;
 
@@ -117,19 +120,19 @@ freebsd3*)
 		# libname.so -> libname.so.M
 		${echo} ${RM} ${INSTALLDIR}/$LINK1
 		if [ -z "$uninstall" ]; then
-			${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK1
+			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
 		fi
 	else
 		# libname.so.M -> libname.so.M.N
 		${echo} ${RM} ${INSTALLDIR}/$LINK2
 		if [ -z "$uninstall" ]; then
-			${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK2
+			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK2
 		fi
 
 		# libname.so -> libname.so.M.N
 		${echo} ${RM} ${INSTALLDIR}/$LINK1
 		if [ -z "$uninstall" ]; then
-			${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/$LINK1
+			${echo} ln -s $LIBNAME ${INSTALLDIR}/$LINK1
 		fi
 	fi
 	;;
@@ -138,7 +141,8 @@ hpux1*)
 	# libname.sl -> libname.M
 	${echo} ${RM} ${INSTALLDIR}/$LINK1.sl
 	if [ -z "$uninstall" ]; then
-		${echo} ln -s $INSTALLDIR/$LIBNAME ${INSTALLDIR}/${LINK1}.sl
+#		${echo} ln -s $LIBNAME ${INSTALLDIR}/${LINK1}.sl
+		${echo} ln -s $LIBNAME ${INSTALLDIR}/${LINK1}
 	fi
 	;;
 
Index: readline/support/shobj-conf
===================================================================
RCS file: /prjz/.cvsroot/gdb/readline/support/shobj-conf,v
retrieving revision 1.1.1.1
diff -u -3 -p -r1.1.1.1 shobj-conf
--- readline/support/shobj-conf	2003/02/16 21:36:34	1.1.1.1
+++ readline/support/shobj-conf	2001/01/02 16:15:44
@@ -43,7 +43,7 @@ while [ $# -gt 0 ]; do
 done
 
 case "${host_os}-${SHOBJ_CC}" in
-sunos4*-gcc*)
+sunos4*-*gcc*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD=/usr/bin/ld
 	SHOBJ_LDFLAGS='-assert pure-text'
@@ -59,7 +59,7 @@ sunos4*)
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
 	;;
 
-sunos5*-gcc*|solaris2*-gcc*)
+sunos5*-*gcc*|solaris2*-*gcc*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-i -Wl,-h,$@'
@@ -97,7 +97,7 @@ freebsd2* | netbsd* | openbsd*)
 #	;;
 
 # FreeBSD-3.x ELF
-freebsd3*)
+freebsd[3-9]*|freebsdelf[3-9]*|freebsdaout[3-9]*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='${CC}'
 
@@ -113,13 +113,13 @@ freebsd3*)
 		SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
 	fi
 	;;
-
-linux*)
+# All versions of Linux or the semi-mythical GNU Hurd.
+linux*|gnu*)
 	SHOBJ_CFLAGS=-fPIC
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
 
-	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir)'
+	SHLIB_XLDFLAGS='-Wl,-rpath,$(libdir) -Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
 	;;
 
@@ -158,10 +158,11 @@ bsdi4*)
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
 
+	SHLIB_XLDFLAGS='-Wl,-soname,`basename $@ $(SHLIB_MINOR)`'
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)$(SHLIB_MINOR)'
 	;;
 
-osf*-gcc*)
+osf*-*gcc*)
 	# Fix to use gcc linker driver from bfischer@TechFak.Uni-Bielefeld.DE
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
@@ -178,7 +179,7 @@ osf*)
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-aix4.[2-9]*-gcc*)		# lightly tested by jik@cisco.com
+aix4.[2-9]*-*gcc*)		# lightly tested by jik@cisco.com
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='ld'
 	SHOBJ_LDFLAGS='-bdynamic -bnoentry -bexpall'
@@ -203,7 +204,7 @@ aix4.[2-9]*)
 #
 # THE FOLLOWING ARE UNTESTED -- and some may not support the dlopen interface
 #
-irix[56]*-gcc*)
+irix[56]*-*gcc*)
 	SHOBJ_CFLAGS='-fpic'
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared -Wl,-soname,$@'
@@ -216,14 +217,15 @@ irix[56]*)
 	SHOBJ_CFLAGS='-K PIC'
 	SHOBJ_LD=ld
 #	SHOBJ_LDFLAGS='-call_shared -hidden_symbol -no_unresolved -soname $@'
-#	Change from David Kaelbling <drk@sgi.com>
+#	Change from David Kaelbling <drk@sgi.com>.  If you have problems,
+#	remove the `-no_unresolved'
 	SHOBJ_LDFLAGS='-shared -no_unresolved -soname $@'
 
 	SHLIB_XLDFLAGS='-rpath $(libdir)'
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-hpux9*-gcc*)
+hpux9*-*gcc*)
 	# must use gcc; the bundled cc cannot compile PIC code
 	SHOBJ_CFLAGS='-fpic'
 	SHOBJ_LD='${CC}'
@@ -239,7 +241,7 @@ hpux9*)
 	SHLIB_STATUS=unsupported
 	;;
 
-hpux10*-gcc*)
+hpux10*-*gcc*)
 	# must use gcc; the bundled cc cannot compile PIC code
 	SHOBJ_CFLAGS='-fpic'
 	SHOBJ_LD='${CC}'
@@ -253,14 +255,27 @@ hpux10*-gcc*)
 hpux10*)
 	SHOBJ_STATUS=unsupported
 	SHLIB_STATUS=unsupported
+
+	# If you are using the HP ANSI C compiler, you can uncomment and use
+	# this code
+#	SHOBJ_STATUS=unsupported
+#	SHLIB_STATUS=unsupported
+#
+#	SHOBJ_CFLAGS='+z'
+#	SHOBJ_LD='ld'
+#	SHOBJ_LDFLAGS='-b'
+#
+#	SHLIB_XLDFLAGS=''
+#	SHLIB_LIBSUFF='sl'
+#	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
 	;;
 
-hpux11*-gcc*)
+hpux11*-*gcc*)
 	# must use gcc; the bundled cc cannot compile PIC code
 	SHOBJ_CFLAGS='-fpic'
 	SHOBJ_LD='${CC}'
 #	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,-B,symbolic -Wl,+s -Wl,+std -Wl,+h,$@'
-	SHOBJ_LDFLAGS='-shared -Wl,-b -Wl,+s -Wl,+h,$@'
+	SHOBJ_LDFLAGS='-shared -fpic -Wl,-b -Wl,+s -Wl,+h,$@'
 
 	SHLIB_XLDFLAGS='-Wl,+b,$(libdir)'
 	SHLIB_LIBSUFF='sl'
@@ -270,9 +285,23 @@ hpux11*-gcc*)
 hpux11*)
 	SHOBJ_STATUS=unsupported
 	SHLIB_STATUS=unsupported
+
+	# If you are using the HP ANSI C compiler, you can uncomment and use
+	# this code
+#	SHOBJ_STATUS=unsupported
+#	SHLIB_STATUS=unsupported
+#
+#	SHOBJ_CFLAGS='+z'
+#	SHOBJ_LD='ld'
+#	SHOBJ_LDFLAGS='-b'
+#
+#	SHLIB_XLDFLAGS=''
+#	SHLIB_LIBSUFF='sl'
+#	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'	
+
 	;;
 
-sysv4*-gcc*)
+sysv4*-*gcc*)
 	SHOBJ_CFLAGS=-shared
 	SHOBJ_LDFLAGS='-shared -h $@'
 	SHOBJ_LD='${CC}'
@@ -288,7 +317,7 @@ sysv4*)
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-sco3.2v5*-gcc*)
+sco3.2v5*-*gcc*)
 	SHOBJ_CFLAGS='-fpic'		# DEFAULTS TO ELF
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared'
@@ -304,7 +333,7 @@ sco3.2v5*)
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 
-sysv5uw7*-gcc*)
+sysv5uw7*-*gcc*)
 	SHOBJ_CFLAGS='-fpic'
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared'
@@ -320,7 +349,7 @@ sysv5uw7*)
 	SHLIB_LIBVERSION='$(SHLIB_LIBSUFF).$(SHLIB_MAJOR)'
 	;;
 	
-dgux*-gcc*)
+dgux*-*gcc*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared'
@@ -344,7 +373,7 @@ msdos*)
 #
 # Rely on correct gcc configuration for everything else
 #
-*-gcc*)
+*-*gcc*)
 	SHOBJ_CFLAGS=-fpic
 	SHOBJ_LD='${CC}'
 	SHOBJ_LDFLAGS='-shared'
