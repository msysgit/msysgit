From 4953f7107fe21f3e8d57e6eaf3af3e77c335625b Mon Sep 17 00:00:00 2001
From: Simon Sasburg <Simon.Sasburg@gmail.com>
Date: Sat, 10 Nov 2007 13:27:59 +0100
Subject: [PATCH] Import test changes from perl-5.6.1-MSYS-1.0.11-src.tar.bz2

---
 t/echo12128            |    1 +
 t/echo12296            |    1 +
 t/echo1432             |    1 +
 t/echo5404             |    1 +
 t/echo5728             |    1 +
 t/echo5888             |    1 +
 t/harness              |    1 +
 t/io/dup.t             |    4 +
 t/io/fs.t              |    6 +-
 t/io/inplace.t         |    6 +
 t/io/tell.t            |    2 +-
 t/lib/filefind-taint.t |  416 ++++++++++++++++++++++++++++++++++++++++++++++++
 t/op/groups.t          |    2 +-
 t/op/magic.t           |    6 +-
 t/op/mkdir.t           |    1 +
 t/op/pat.t             |    1 +
 t/op/readdir.t         |    2 +
 t/op/stat.t            |   10 +-
 18 files changed, 451 insertions(+), 12 deletions(-)
 create mode 100644 t/echo12128
 create mode 100644 t/echo12296
 create mode 100644 t/echo1432
 create mode 100644 t/echo5404
 create mode 100644 t/echo5728
 create mode 100644 t/echo5888
 create mode 100644 t/lib/filefind-taint.t

diff --git a/t/echo12128 b/t/echo12128
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo12128
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/echo12296 b/t/echo12296
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo12296
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/echo1432 b/t/echo1432
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo1432
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/echo5404 b/t/echo5404
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo5404
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/echo5728 b/t/echo5728
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo5728
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/echo5888 b/t/echo5888
new file mode 100644
index 0000000..841ea7f
--- /dev/null
+++ b/t/echo5888
@@ -0,0 +1 @@
+print "@ARGV\n"
diff --git a/t/harness b/t/harness
index b5e3e87..596ddb5 100644
--- a/t/harness
+++ b/t/harness
@@ -7,6 +7,7 @@ BEGIN {
     chdir 't' if -d 't';
     @INC = '../lib';              # pick up only this build's lib
     $ENV{PERL5LIB} = '../lib';    # so children will see it too
+    $ENV{HARNESS_NOTTY} = 1 if $^O eq 'MacOS';
 }
 
 my $torture; # torture testing?
diff --git a/t/io/dup.t b/t/io/dup.t
index 48497fd..2ca95d9 100644
--- a/t/io/dup.t
+++ b/t/io/dup.t
@@ -40,6 +40,10 @@ if( $^O eq 'VMS' ) {
     print "not ok $_ # TODO system() not honoring STDOUT redirect on VMS\n"
       for 6..7;
 }
+elsif ($^O eq 'MacOS') {
+    system 'echo ok 4';
+    system 'echo ok 5';  # no real way to do this, i think
+}
 else {
     system sprintf $echo, 6;
     if ($^O eq 'MacOS') {
diff --git a/t/io/fs.t b/t/io/fs.t
index 7da263a..19bcdce 100644
--- a/t/io/fs.t
+++ b/t/io/fs.t
@@ -25,7 +25,7 @@ my $has_link            = $Config{d_link};
 my $accurate_timestamps =
     !($^O eq 'MSWin32' || $^O eq 'NetWare' ||
       $^O eq 'dos'     || $^O eq 'os2'     ||
-      $^O eq 'mint'    || $^O eq 'cygwin'  ||
+      $^O eq 'mint'    || $^O eq 'cygwin'  || $^O eq 'msys' ||
       $^O eq 'amigaos' || $wd =~ m#$Config{afsroot}/# ||
       $Is_MacOS
      );
@@ -45,7 +45,7 @@ my $needs_fh_reopen =
 $needs_fh_reopen = 1 if (defined &Win32::IsWin95 && Win32::IsWin95());
 
 my $skip_mode_checks =
-    $^O eq 'cygwin' && $ENV{CYGWIN} !~ /ntsec/;
+    $^O eq 'msys' || ($^O eq 'cygwin' && $ENV{CYGWIN} !~ /ntsec/);
 
 plan tests => 42;
 
@@ -383,7 +383,7 @@ SKIP: {
 # check if rename() can be used to just change case of filename
 SKIP: {
     skip "Works in Cygwin only if check_case is set to relaxed", 1
-      if $^O eq 'cygwin';
+      if $^O eq 'cygwin' || $^O eq 'msys';
 
     chdir './tmp';
     open(FH,'>x') || die "Can't create x";
diff --git a/t/io/inplace.t b/t/io/inplace.t
index a97add5..a067cbf 100644
--- a/t/io/inplace.t
+++ b/t/io/inplace.t
@@ -31,6 +31,12 @@ elsif ($^O eq 'VMS') {
   `MCR []perl. -le "print 'foo'" > ./.b`;
   `MCR []perl. -le "print 'foo'" > ./.c`;
 }
+elsif ($^O eq 'MacOS') {
+  $CAT = "$^X -e \"print<>\"";
+  `$^X -le "print 'foo'" > .a`;
+  `$^X -le "print 'foo'" > .b`;
+  `$^X -le "print 'foo'" > .c`;
+}
 else {
   $CAT = 'cat';
   `echo foo | tee .a .b .c`;
diff --git a/t/io/tell.t b/t/io/tell.t
index dcb4ee9..fb55324 100644
--- a/t/io/tell.t
+++ b/t/io/tell.t
@@ -13,7 +13,7 @@ $TST = 'tst';
 
 $Is_Dosish = ($^O eq 'MSWin32' or $^O eq 'NetWare' or $^O eq 'dos' or
               $^O eq 'os2' or $^O eq 'mint' or $^O eq 'cygwin' or
-              $^O =~ /^uwin/);
+              $^O eq 'msys' or $^O =~ /^uwin/);
 
 open($TST, 'harness') || (die "Can't open harness");
 binmode $TST if $Is_Dosish;
diff --git a/t/lib/filefind-taint.t b/t/lib/filefind-taint.t
new file mode 100644
index 0000000..7f9d83f
--- /dev/null
+++ b/t/lib/filefind-taint.t
@@ -0,0 +1,416 @@
+#!./perl -T
+
+
+my %Expect_File = (); # what we expect for $_
+my %Expect_Name = (); # what we expect for $File::Find::name/fullname
+my %Expect_Dir  = (); # what we expect for $File::Find::dir
+my $symlink_exists = eval { symlink("",""); 1 };
+my $cwd;
+my $cwd_untainted;
+
+BEGIN {
+    chdir 't' if -d 't';
+    unshift @INC => '../lib';
+
+    require Config;
+
+    for (keys %ENV) { # untaint ENV
+	($ENV{$_}) = $ENV{$_} =~ /(.*)/;
+    }
+
+    # Remove insecure directories from PATH
+    my @path;
+    my $sep = $Config{path_sep};
+    foreach my $dir (split(/\Q$sep/,$ENV{'PATH'}))
+    {
+	##
+	## Match the directory taint tests in mg.c::Perl_magic_setenv()
+	##
+	push(@path,$dir) unless (length($dir) >= 256
+				 or
+				 substr($dir,0,1) ne "/"
+				 or
+				 (stat $dir)[2] & 002);
+    }
+    $ENV{'PATH'} = join($sep,@path);
+}
+
+
+if ( $symlink_exists ) { print "1..45\n"; }
+else                   { print "1..27\n";  }
+
+use File::Find;
+use File::Spec;
+use Cwd;
+
+
+my $NonTaintedCwd = $^O eq 'MSWin32' || $^O eq 'cygwin' || $^O eq 'os2' || $^O eq 'msys';
+
+cleanup();
+
+find({wanted => sub { print "ok 1\n" if $_ eq 'if.t'; },
+      untaint => 1, untaint_pattern => qr|^(.+)$|}, File::Spec->curdir);
+
+finddepth({wanted => sub { print "ok 2\n" if $_ eq 'if.t'; },
+           untaint => 1, untaint_pattern => qr|^(.+)$|},
+           File::Spec->curdir);
+
+my $case = 2;
+my $FastFileTests_OK = 0;
+
+sub cleanup {
+    if (-d dir_path('for_find')) {
+        chdir(dir_path('for_find'));
+    }
+    if (-d dir_path('fa')) {
+        unlink file_path('fa', 'fa_ord'),
+               file_path('fa', 'fsl'),
+               file_path('fa', 'faa', 'faa_ord'),
+               file_path('fa', 'fab', 'fab_ord'),
+               file_path('fa', 'fab', 'faba', 'faba_ord'),
+               file_path('fb', 'fb_ord'),
+               file_path('fb', 'fba', 'fba_ord');
+        rmdir dir_path('fa', 'faa');
+        rmdir dir_path('fa', 'fab', 'faba');
+        rmdir dir_path('fa', 'fab');
+        rmdir dir_path('fa');
+        rmdir dir_path('fb', 'fba');
+        rmdir dir_path('fb');
+        chdir File::Spec->updir;
+        rmdir dir_path('for_find');
+    }
+}
+
+END {
+    cleanup();
+}
+
+sub Check($) {
+    $case++;
+    if ($_[0]) { print "ok $case\n"; }
+    else       { print "not ok $case\n"; }
+
+}
+
+sub CheckDie($) {
+    $case++;
+    if ($_[0]) { print "ok $case\n"; }
+    else       { print "not ok $case\n"; exit 0; }
+}
+
+sub Skip($) {
+    $case++;
+    print "ok $case # skipped: ",$_[0],"\n";
+}
+
+sub touch {
+    CheckDie( open(my $T,'>',$_[0]) );
+}
+
+sub MkDir($$) {
+    CheckDie( mkdir($_[0],$_[1]) );
+}
+
+sub wanted_File_Dir {
+    print "# \$File::Find::dir => '$File::Find::dir'\n";
+    print "# \$_ => '$_'\n";
+    s#\.$## if ($^O eq 'VMS' && $_ ne '.');
+    Check( $Expect_File{$_} );
+    if ( $FastFileTests_OK ) {
+        delete $Expect_File{ $_}
+          unless ( $Expect_Dir{$_} && ! -d _ );
+    } else {
+        delete $Expect_File{$_}
+          unless ( $Expect_Dir{$_} && ! -d $_ );
+    }
+}
+
+sub wanted_File_Dir_prune {
+    &wanted_File_Dir;
+    $File::Find::prune=1 if  $_ eq 'faba';
+}
+
+
+sub simple_wanted {
+    print "# \$File::Find::dir => '$File::Find::dir'\n";
+    print "# \$_ => '$_'\n";
+}
+
+
+# Use dir_path() to specify a directory path that's expected for
+# $File::Find::dir (%Expect_Dir). Also use it in file operations like
+# chdir, rmdir etc.
+#
+# dir_path() concatenates directory names to form a _relative_
+# directory path, independant from the platform it's run on, although
+# there are limitations.  Don't try to create an absolute path,
+# because that may fail on operating systems that have the concept of
+# volume names (e.g. Mac OS). Be careful when you want to create an
+# updir path like ../fa (Unix) or ::fa: (Mac OS). Plain directory
+# names will work best. As a special case, you can pass it a "." as
+# first argument, to create a directory path like "./fa/dir" on
+# operating systems other than Mac OS (actually, Mac OS will ignore
+# the ".", if it's the first argument). If there's no second argument,
+# this function will return the empty string on Mac OS and the string
+# "./" otherwise.
+
+sub dir_path {
+    my $first_item = shift @_;
+
+    if ($first_item eq '.') {
+        if ($^O eq 'MacOS') {
+            return '' unless @_;
+            # ignore first argument; return a relative path
+            # with leading ":" and with trailing ":"
+            return File::Spec->catdir("", @_);
+        } else { # other OS
+            return './' unless @_;
+            my $path = File::Spec->catdir(@_);
+            # add leading "./"
+            $path = "./$path";
+            return $path;
+        }
+
+    } else { # $first_item ne '.'
+        return $first_item unless @_; # return plain filename
+        if ($^O eq 'MacOS') {
+            # relative path with leading ":" and with trailing ":"
+            return File::Spec->catdir("", $first_item, @_);
+        } else { # other OS
+            return File::Spec->catdir($first_item, @_);
+        }
+    }
+}
+
+
+# Use topdir() to specify a directory path that you want to pass to
+#find/finddepth Basically, topdir() does the same as dir_path() (see
+#above), except that there's no trailing ":" on Mac OS.
+
+sub topdir {
+    my $path = dir_path(@_);
+    $path =~ s/:$// if ($^O eq 'MacOS');
+    return $path;
+}
+
+
+# Use file_path() to specify a file path that's expected for $_ (%Expect_File).
+# Also suitable for file operations like unlink etc.
+
+# file_path() concatenates directory names (if any) and a filename to
+# form a _relative_ file path (the last argument is assumed to be a
+# file). It's independant from the platform it's run on, although
+# there are limitations (see the warnings for dir_path() above). As a
+# special case, you can pass it a "." as first argument, to create a
+# file path like "./fa/file" on operating systems other than Mac OS
+# (actually, Mac OS will ignore the ".", if it's the first
+# argument). If there's no second argument, this function will return
+# the empty string on Mac OS and the string "./" otherwise.
+
+sub file_path {
+    my $first_item = shift @_;
+
+    if ($first_item eq '.') {
+        if ($^O eq 'MacOS') {
+            return '' unless @_;
+            # ignore first argument; return a relative path
+            # with leading ":", but without trailing ":"
+            return File::Spec->catfile("", @_);
+        } else { # other OS
+            return './' unless @_;
+            my $path = File::Spec->catfile(@_);
+            # add leading "./"
+            $path = "./$path";
+            return $path;
+        }
+
+    } else { # $first_item ne '.'
+        return $first_item unless @_; # return plain filename
+        if ($^O eq 'MacOS') {
+            # relative path with leading ":", but without trailing ":"
+            return File::Spec->catfile("", $first_item, @_);
+        } else { # other OS
+            return File::Spec->catfile($first_item, @_);
+        }
+    }
+}
+
+
+# Use file_path_name() to specify a file path that's expected for
+# $File::Find::Name (%Expect_Name). Note: When the no_chdir => 1
+# option is in effect, $_ is the same as $File::Find::Name. In that
+# case, also use this function to specify a file path that's expected
+# for $_.
+#
+# Basically, file_path_name() does the same as file_path() (see
+# above), except that there's always a leading ":" on Mac OS, even for
+# plain file/directory names.
+
+sub file_path_name {
+    my $path = file_path(@_);
+    $path = ":$path" if (($^O eq 'MacOS') && ($path !~ /:/));
+    return $path;
+}
+
+
+
+MkDir( dir_path('for_find'), 0770 );
+CheckDie(chdir( dir_path('for_find')));
+
+$cwd = cwd(); # save cwd
+( $cwd_untainted ) = $cwd =~ m|^(.+)$|; # untaint it
+
+MkDir( dir_path('fa'), 0770 );
+MkDir( dir_path('fb'), 0770  );
+touch( file_path('fb', 'fb_ord') );
+MkDir( dir_path('fb', 'fba'), 0770  );
+touch( file_path('fb', 'fba', 'fba_ord') );
+if ($^O eq 'MacOS') {
+      CheckDie( symlink(':fb',':fa:fsl') ) if $symlink_exists;
+} else {
+      CheckDie( symlink('../fb','fa/fsl') ) if $symlink_exists;
+}
+touch( file_path('fa', 'fa_ord') );
+
+MkDir( dir_path('fa', 'faa'), 0770  );
+touch( file_path('fa', 'faa', 'faa_ord') );
+MkDir( dir_path('fa', 'fab'), 0770  );
+touch( file_path('fa', 'fab', 'fab_ord') );
+MkDir( dir_path('fa', 'fab', 'faba'), 0770  );
+touch( file_path('fa', 'fab', 'faba', 'faba_ord') );
+
+print "# check untainting (no follow)\n";
+
+# untainting here should work correctly
+
+%Expect_File = (File::Spec->curdir => 1, file_path('fsl') =>
+                1,file_path('fa_ord') => 1, file_path('fab') => 1,
+                file_path('fab_ord') => 1, file_path('faba') => 1,
+                file_path('faa') => 1, file_path('faa_ord') => 1);
+delete $Expect_File{ file_path('fsl') } unless $symlink_exists;
+%Expect_Name = ();
+
+%Expect_Dir = ( dir_path('fa') => 1, dir_path('faa') => 1,
+                dir_path('fab') => 1, dir_path('faba') => 1,
+                dir_path('fb') => 1, dir_path('fba') => 1);
+
+delete @Expect_Dir{ dir_path('fb'), dir_path('fba') } unless $symlink_exists;
+
+File::Find::find( {wanted => \&wanted_File_Dir_prune, untaint => 1,
+		   untaint_pattern => qr|^(.+)$|}, topdir('fa') );
+
+Check( scalar(keys %Expect_File) == 0 );
+
+
+# don't untaint at all, should die
+%Expect_File = ();
+%Expect_Name = ();
+%Expect_Dir  = ();
+undef $@;
+eval {File::Find::find( {wanted => \&simple_wanted}, topdir('fa') );};
+Check( $@ =~ m|Insecure dependency| );
+chdir($cwd_untainted);
+
+
+# untaint pattern doesn't match, should die
+undef $@;
+
+eval {File::Find::find( {wanted => \&simple_wanted, untaint => 1,
+                         untaint_pattern => qr|^(NO_MATCH)$|},
+                         topdir('fa') );};
+
+Check( $@ =~ m|is still tainted| );
+chdir($cwd_untainted);
+
+
+# untaint pattern doesn't match, should die when we chdir to cwd
+print "# check untaint_skip (No follow)\n";
+undef $@;
+
+eval {File::Find::find( {wanted => \&simple_wanted, untaint => 1,
+                         untaint_skip => 1, untaint_pattern =>
+                         qr|^(NO_MATCH)$|}, topdir('fa') );};
+
+print "# $@" if $@;
+#$^D = 8;
+if ($NonTaintedCwd) {
+	Skip("$^O does not taint cwd");
+    }
+else {
+	Check( $@ =~ m|insecure cwd| );
+}
+chdir($cwd_untainted);
+
+
+if ( $symlink_exists ) {
+    print "# --- symbolic link tests --- \n";
+    $FastFileTests_OK= 1;
+
+    print "# check untainting (follow)\n";
+
+    # untainting here should work correctly
+    # no_chdir is in effect, hence we use file_path_name to specify the expected paths for %Expect_File
+
+    %Expect_File = (file_path_name('fa') => 1,
+		    file_path_name('fa','fa_ord') => 1,
+		    file_path_name('fa', 'fsl') => 1,
+                    file_path_name('fa', 'fsl', 'fb_ord') => 1,
+                    file_path_name('fa', 'fsl', 'fba') => 1,
+                    file_path_name('fa', 'fsl', 'fba', 'fba_ord') => 1,
+                    file_path_name('fa', 'fab') => 1,
+                    file_path_name('fa', 'fab', 'fab_ord') => 1,
+                    file_path_name('fa', 'fab', 'faba') => 1,
+                    file_path_name('fa', 'fab', 'faba', 'faba_ord') => 1,
+                    file_path_name('fa', 'faa') => 1,
+                    file_path_name('fa', 'faa', 'faa_ord') => 1);
+
+    %Expect_Name = ();
+
+    %Expect_Dir = (dir_path('fa') => 1,
+		   dir_path('fa', 'faa') => 1,
+                   dir_path('fa', 'fab') => 1,
+		   dir_path('fa', 'fab', 'faba') => 1,
+		   dir_path('fb') => 1,
+		   dir_path('fb', 'fba') => 1);
+
+    File::Find::find( {wanted => \&wanted_File_Dir, follow_fast => 1,
+                       no_chdir => 1, untaint => 1, untaint_pattern =>
+                       qr|^(.+)$| }, topdir('fa') );
+
+    Check( scalar(keys %Expect_File) == 0 );
+
+
+    # don't untaint at all, should die
+    undef $@;
+
+    eval {File::Find::find( {wanted => \&simple_wanted, follow => 1},
+			    topdir('fa') );};
+
+    Check( $@ =~ m|Insecure dependency| );
+    chdir($cwd_untainted);
+
+    # untaint pattern doesn't match, should die
+    undef $@;
+
+    eval {File::Find::find( {wanted => \&simple_wanted, follow => 1,
+                             untaint => 1, untaint_pattern =>
+                             qr|^(NO_MATCH)$|}, topdir('fa') );};
+
+    Check( $@ =~ m|is still tainted| );
+    chdir($cwd_untainted);
+
+    # untaint pattern doesn't match, should die when we chdir to cwd
+    print "# check untaint_skip (Follow)\n";
+    undef $@;
+
+    eval {File::Find::find( {wanted => \&simple_wanted, untaint => 1,
+                             untaint_skip => 1, untaint_pattern =>
+                             qr|^(NO_MATCH)$|}, topdir('fa') );};
+    if ($NonTaintedCwd) {
+	Skip("$^O does not taint cwd");
+    }
+    else {
+	Check( $@ =~ m|insecure cwd| );
+    }
+    chdir($cwd_untainted);
+}
diff --git a/t/op/groups.t b/t/op/groups.t
index faaf7dd..9c802a5 100644
--- a/t/op/groups.t
+++ b/t/op/groups.t
@@ -134,7 +134,7 @@ for (split(' ', $()) {
 print "# gr = @gr\n";
 
 my %did;
-if ($^O =~ /^(?:uwin|cygwin|interix|solaris)$/) {
+if ($^O =~ /^(?:uwin|cygwin|msys|interix|solaris)$/) {
 	# Or anybody else who can have spaces in group names.
 	$gr1 = join(' ', grep(!$did{$_}++, sort split(' ', join(' ', @gr))));
 } else {
diff --git a/t/op/magic.t b/t/op/magic.t
index b28a082..1792c81 100644
--- a/t/op/magic.t
+++ b/t/op/magic.t
@@ -48,6 +48,8 @@ $Is_MacOS    = $^O eq 'MacOS';
 $Is_MPE      = $^O eq 'mpeix';		
 $Is_miniperl = $ENV{PERL_CORE_MINITEST};
 $Is_BeOS     = $^O eq 'beos';
+$Is_Msys   = $^O eq 'msys';
+$PERL = ($Is_MSWin32 ? '.\perl' : './perl');
 
 $PERL = $ENV{PERL}
     || ($Is_NetWare           ? 'perl'   :
@@ -189,7 +191,7 @@ ok $@ =~ /^Modification of a read-only value attempted/;
     if ($^O eq 'qnx') {
 	chomp($wd = `/usr/bin/fullpath -t`);
     }
-    elsif($Is_Cygwin || $Config{'d_procselfexe'}) {
+    elsif($Is_Cygwin or $Is_Msys || $Config{'d_procselfexe'}) {
        # Cygwin turns the symlink into the real file
        chomp($wd = `pwd`);
        $wd =~ s#/t$##;
@@ -250,7 +252,7 @@ EOF
     ok close(SCRIPT), $!;
     ok chmod(0755, $script), $!;
     $_ = ($Is_MacOS || $Is_VMS) ? `$perl $script` : `$script`;
-    s/\.exe//i if $Is_Dos or $Is_Cygwin or $Is_os2;
+    s/\.exe//i if $Is_Dos or $Is_Cygwin or $Is_Msys or $Is_os2;
     s{./$script}{$script} if $Is_BeOS; # revert BeOS execvp() side-effect
     s{\bminiperl\b}{perl}; # so that test doesn't fail with miniperl
     s{is perl}{is $perl}; # for systems where $^X is only a basename
diff --git a/t/op/readdir.t b/t/op/readdir.t
index a56c5b2..5b3bd1e 100644
--- a/t/op/readdir.t
+++ b/t/op/readdir.t
@@ -5,6 +5,8 @@ BEGIN {
     @INC = '../lib';
 }
 
+use File::Spec::Functions;
+
 eval 'opendir(NOSUCH, "no/such/directory");';
 if ($@) { print "1..0\n"; exit; }
 
diff --git a/t/op/stat.t b/t/op/stat.t
index e395397..9c487cf 100644
--- a/t/op/stat.t
+++ b/t/op/stat.t
@@ -15,6 +15,7 @@ my $Perl = which_perl();
 
 $Is_Amiga   = $^O eq 'amigaos';
 $Is_Cygwin  = $^O eq 'cygwin';
+$Is_Msys    = $^O eq 'msys';
 $Is_Darwin  = $^O eq 'darwin';
 $Is_Dos     = $^O eq 'dos';
 $Is_MacOS   = $^O eq 'MacOS';
@@ -28,7 +29,7 @@ $Is_DGUX    = $^O eq 'dgux';
 $Is_MPRAS   = $^O =~ /svr4/ && -f '/etc/.relid';
 $Is_Rhapsody= $^O eq 'rhapsody';
 
-$Is_Dosish  = $Is_Dos || $Is_OS2 || $Is_MSWin32 || $Is_NetWare || $Is_Cygwin;
+$Is_Dosish  = $Is_Dos || $Is_OS2 || $Is_MSWin32 || $Is_NetWare || $Is_Cygwin || $Is_Msys;
 
 $Is_UFS     = $Is_Darwin && (() = `df -t ufs .`) == 2;
 
@@ -57,7 +58,7 @@ SKIP: {
 
 SKIP: {
   skip "mtime and ctime not reliable", 2
-    if $Is_MSWin32 or $Is_NetWare or $Is_Cygwin or $Is_Dos or $Is_MacOS;
+    if $Is_MSWin32 or $Is_NetWare or $Is_Cygwin or $Is_Msys or $Is_Dos or $Is_MacOS;
 
   ok( $mtime,           'mtime' );
   is( $mtime, $ctime,   'mtime == ctime' );
@@ -65,7 +66,7 @@ SKIP: {
 
 
 # Cygwin seems to have a 3 second granularity on its timestamps.
-my $funky_FAT_timestamps = $Is_Cygwin;
+my $funky_FAT_timestamps = $Is_Cygwin or $Is_Msys;
 sleep 3 if $funky_FAT_timestamps;
 
 print FOO "Now is the time for all good men to come to.\n";
@@ -160,7 +161,7 @@ SKIP: {
           if $> == 0;
 
         SKIP: {
-            skip "Can't test -r meaningfully?", 1 if $Is_Dos || $Is_Cygwin;
+            skip "Can't test -r meaningfully?", 1 if $Is_Dos || $Is_Cygwin || $Is_Msys;
             ok(!-r $tmpfile,    "   -r");
         }
 
@@ -174,7 +175,6 @@ SKIP: {
 }
 
 
-
 ok(chmod(0700,$tmpfile),    'chmod 0700');
 ok(-r $tmpfile,     '   -r');
 ok(-w $tmpfile,     '   -w');
-- 
1.5.3.5.2233.g50e2

