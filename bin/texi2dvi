#! /bin/sh
# texi2dvi --- produce DVI (or PDF) files from Texinfo (or (La)TeX) sources.
# $Id: texi2dvi,v 1.135 2008/09/18 18:46:01 karl Exp $
#
# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2001,
# 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License,
# or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# Original author: Noah Friedman.
#
# Please send bug reports, etc. to bug-texinfo@gnu.org.
# If possible, please send a copy of the output of the script called with
# the `--debug' option when making a bug report.

test -f /bin/ksh && test -z "$RUNNING_KSH" \
  && { UNAMES=`uname -s`; test "x$UNAMES" = xULTRIX; } 2>/dev/null \
  && { RUNNING_KSH=true; export RUNNING_KSH; exec /bin/ksh $0 ${1+"$@"}; }
unset RUNNING_KSH

# No failure shall remain unpunished.
set -e

if ! command -v tex >/dev/null 2>&1; then
 cat <<%EOM%
You don't have a working TeX binary installed, but the texi2dvi script
can't proceed without it. If you want to use this script, you have to
install some kind of TeX, for example the MikTeX package from
http://miktex.org/ (which is not part of the typical MSYS environment).
%EOM%
 exit 1
fi

# This string is expanded by rcs automatically when this file is checked out.
rcs_revision='$Revision: 1.135 $'
rcs_version=`set - $rcs_revision; echo $2`
program=`echo $0 | sed -e 's!.*/!!'`

build_mode=${TEXI2DVI_BUILD_MODE:-local}
build_dir=${TEXI2DVI_BUILD_DIRECTORY:-.}

# Initialize variables for option overriding and otherwise.
# Don't use `unset' since old bourne shells don't have this command.
# Instead, assign them an empty value.
action=compile
batch=false     # true for batch mode
catcode_special=true
debug=false
escape="\\"
expand=         # t for expansion via makeinfo
includes=
line_error=true # Pass --file-line-error to TeX.
no_line_error=false  # absolutely do not pass --file-line-error to TeX
oname=          # --output
out_lang=dvi
quiet=false     # by default let the tools' message be displayed
recode=false
set_language=
src_specials=
textra=         # Extra TeX commands to insert in the input file.
txiprereq=19990129 # minimum texinfo.tex version with macro expansion
verb=false      # true for verbose mode
translate_file= # name of charset translation file
recode_from=    # if not empty, recode from this encoding to @documentencoding

orig_pwd=`pwd`

# We have to initialize IFS to space tab newline since we save and
# restore IFS and apparently POSIX allows stupid/broken behavior with
# empty-but-set IFS.
# http://lists.gnu.org/archive/html/automake-patches/2006-05/msg00008.html
# We need space, tab and new line, in precisely that order.  And don't leave
# trailing blanks.
space=' '
tab='	'
newline='
'
IFS="$space$tab$newline"

# In case someone pedantic insists on using grep -E.
: ${EGREP=egrep}

# Systems which define $COMSPEC or $ComSpec use semicolons to separate
# directories in TEXINPUTS -- except for Cygwin et al., where COMSPEC
# might be inherited, but : is used.
if test -n "$COMSPEC$ComSpec" \
   && uname | $EGREP -iv 'cygwin|mingw|djgpp' >/dev/null; then
  path_sep=";"
else
  path_sep=":"
fi

# Pacify verbose cds.
CDPATH=${ZSH_VERSION+.}$path_sep

# If $TEX is set to a directory, don't use it.
test -n "$TEX" && test -d "$TEX" && unset TEX

# 
## --------------------- ##
## Auxiliary functions.  ##
## --------------------- ##

# In case `local' is not supported by the shell, provide a function
# that simulates it by simply performing the assignments.  This means
# that we must not expect `local' to work, i.e., we must not (i) rely
# on it during recursion, and (ii) have two local declarations of the
# same variable.  (ii) is easy to check statically, and our test suite
# does make sure there is never twice a static local declaration of a
# variable.  (i) cannot be checked easily, so just be careful.
#
# Note that since we might use a function simulating `local', we can
# no longer rely on the fact that no IFS-splitting is performed.  So,
# while
#
# foo=$bar
#
# is fine (no IFS-splitting), never write
#
# local foo=$bar
#
# but rather
#
# local foo="$bar"
(
  foo=bar
  test_local () {
    local foo=foo
  }
  test_local
  test $foo = bar
) || local () {
  case $1 in
    *=*) eval "$1";;
  esac
}


# cd_orig
# -------
# Return to the original directory.
cd_orig ()
{
  # In case $orig_pwd is on a different drive (for DOS).
  cd /

  # Return to the original directory so that
  # - the next file is processed in correct conditions
  # - the temporary file can be removed
  cd "$orig_pwd" || exit 1
}

# func_dirname FILE
# -----------------
# Return the directory part of FILE.
func_dirname ()
{
  dirname "$1" 2>/dev/null \
  || { echo "$1" | sed 's!/[^/]*$!!;s!^$!.!'; }
}


# absolute NAME -> ABS-NAME
# -------------------------
# Return an absolute path to NAME.
absolute ()
{
  case $1 in
   [\\/]* | ?:[\\/]*)
      # Absolute paths don't need to be expanded.
      echo "$1"
      ;;
   *) local slashes
      slashes=`echo "$1" | sed -n 's,.*[^/]\(/*\)$,\1,p'`
      local rel
      rel=$orig_pwd/`func_dirname "$1"`
      if test -d "$rel"; then
	(cd "$rel" 2>/dev/null &&
	 local n
	 n=`pwd`/`basename "$1"`"$slashes"
	 echo "$n")
      else
	error 1 "not a directory: $rel"
      fi
      ;;
  esac
}


# ensure_dir DIR1 DIR2...
# -----------------------
# Make sure the directories exist.
ensure_dir ()
{
  for dir
  do
    test -d "$dir" \
      || mkdir "$dir" \
      || error 1 "cannot create directory: $dir"
  done
}


# error EXIT_STATUS LINE1 LINE2...
# --------------------------------
# Report an error and exit with failure if EXIT_STATUS is non null.
error ()
{
  local s="$1"
  shift
  report "$@"
  if test "$s" != 0; then
    exit $s
  fi
}


# findprog PROG
# -------------
# Return true if PROG is somewhere in PATH, else false.
findprog ()
{
  local saveIFS="$IFS"
  IFS=$path_sep  # break path components at the path separator
  for dir in $PATH; do
    IFS=$saveIFS
    # The basic test for an executable is `test -f $f && test -x $f'.
    # (`test -x' is not enough, because it can also be true for directories.)
    # We have to try this both for $1 and $1.exe.
    #
    # Note: On Cygwin and DJGPP, `test -x' also looks for .exe.  On Cygwin,
    # also `test -f' has this enhancement, bot not on DJGPP.  (Both are
    # design decisions, so there is little chance to make them consistent.)
    # Thusly, it seems to be difficult to make use of these enhancements.
    #
    if  { test -f "$dir/$1"	&& test -x "$dir/$1"; } ||
	{ test -f "$dir/$1.exe"	&& test -x "$dir/$1.exe"; }; then
      return 0
    fi
  done
  return 1
}

# report LINE1 LINE2...
# ---------------------
# Report some information on stderr.
report ()
{
  for i in "$@"
  do
    echo >&2 "$0: $i"
  done
}


# run COMMAND-LINE
# ----------------
# Run the COMMAND-LINE verbosely, and catching errors as failures.
run ()
{
  verbose "Running $@"
  "$@" 2>&5 1>&2 ||
     error 1 "$1 failed"
}


# usage
# -----
# Display usage and exit successfully.
usage ()
{
  # We used to simply have `echo "$usage"', but coping with the
  # changing behavior of `echo' is much harder than simply using a
  # here-doc.
  #
  #             echo '\noto'   echo '\\noto'   echo -e '\\noto'
  # bash 3.1      \noto           \\noto          \noto
  # bash 3.2       %oto           \noto           -e \noto
  #
  # where % denotes the eol character.
  cat <<EOF
Usage: $program [OPTION]... FILE...

Run each Texinfo or (La)TeX FILE through TeX in turn until all
cross-references are resolved, building all indices.  The directory
containing each FILE is searched for included files.  The suffix of FILE
is used to determine its language ((La)TeX or Texinfo).  To process
(e)plain TeX files, set the environment variable LATEX=tex.

In order to make texi2dvi a drop-in replacement of TeX/LaTeX in AUC-TeX,
the FILE may also be composed of the following simple TeX commands.
  \`\\input{FILE}'     the actual file to compile
  \`\\nonstopmode'     same as --batch

Makeinfo is used to perform Texinfo macro expansion before running TeX
when needed.

General options:
  -b, --batch         no interaction
  -D, --debug         turn on shell debugging (set -x)
  -h, --help          display this help and exit successfully
  -o, --output=OFILE  leave output in OFILE (implies --clean);
			only one input FILE may be specified in this case
  -q, --quiet         no output unless errors (implies --batch)
  -s, --silent        same as --quiet
  -v, --version       display version information and exit successfully
  -V, --verbose       report on what is done

TeX tuning:
  -@                         use @input instead of \input for preloaded Texinfo
      --dvi                  output a DVI file [default]
      --dvipdf               output a PDF file via DVI (using dvipdf)
  -e, -E, --expand           force macro expansion using makeinfo
  -I DIR                     search DIR for Texinfo files
  -l, --language=LANG        specify LANG for FILE, either latex or texinfo
      --no-line-error        do not pass --file-line-error to TeX
  -p, --pdf                  use pdftex or pdflatex for processing
  -r, --recode               call recode before TeX to translate input
      --recode-from=ENC      recode from ENC to the @documentencoding
      --src-specials         pass --src-specials to TeX
  -t, --command=CMD          insert CMD in copy of input file
   or --texinfo=CMD          multiple values accumulate
      --translate-file=FILE  use given charset translation file for TeX

Build modes:
  --build=MODE         specify the treatment of auxiliary files [$build_mode]
      --tidy           same as --build=tidy
  -c, --clean          same as --build=clean
      --build-dir=DIR  specify where the tidy compilation is performed;
			 implies --tidy;
			 defaults to TEXI2DVI_BUILD_DIRECTORY [$build_dir]
  --mostly-clean       remove the auxiliary files and directories
			 but not the output

The MODE specifies where the TeX compilation takes place, and, as a
consequence, how auxiliary files are treated.  The build mode
can also be set using the environment variable TEXI2DVI_BUILD_MODE.

Valid MODEs are:
  \`local'      compile in the current directory, leaving all the auxiliary
	       files around.  This is the traditional TeX use.
  \`tidy'       compile in a local *.t2d directory, where the auxiliary files
	       are left.  Output files are copied back to the original file.
  \`clean'      same as \`tidy', but remove the auxiliary directory afterwards.
	       Every compilation therefore requires the full cycle.

Using the \`tidy' mode brings several advantages:
  -   the current directory is not cluttered with plethora of temporary files.
  -   clutter can be even reduced using --build-dir=dir: all the *.t2d
      directories are stored there.
  -   clutter can be reduced to zero using, e.g., --build-dir=/tmp/\$USER.t2d
      or --build-dir=\$HOME/.t2d.
  -   the output file is updated after every succesful TeX run, for
      sake of concurrent visualization of the output.  In a \`local' build
      the viewer stops during the whole TeX run.
  -   if the compilation fails, the previous state of the output file
      is preserved.
  -   PDF and DVI compilation are kept in separate subdirectories
      preventing any possibility of auxiliary file incompatibility.

On the other hand, because \`tidy' compilation takes place in another
directory, occasionally TeX won't be able to find some files (e.g., when
using \\graphicspath): in that case use -I to specify the additional
directories to consider.

The values of the BIBTEX, LATEX (or PDFLATEX), MAKEINDEX, MAKEINFO,
TEX (or PDFTEX), TEXINDEX, and THUMBPDF environment variables are used
to run those commands, if they are set.  Any CMD strings are added
after @setfilename for Texinfo input, in the first line for LaTeX input.

Email bug reports to <bug-texinfo@gnu.org>,
general questions and discussion to <help-texinfo@gnu.org>.
Texinfo home page: http://www.gnu.org/software/texinfo/
EOF
  exit 0
}


# verbose WORD1 WORD2
# -------------------
# Report some verbose information.
verbose ()
{
  if $verb; then
    echo >&2 "$0: $@"
  fi
}


# version
# -------
# Display version info and exit succesfully.
version ()
{
  cat <<EOF
texi2dvi (GNU Texinfo 4.13) $rcs_version

Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
EOF
  exit 0
}


## ---------------- ##
## Handling lists.  ##
## ---------------- ##


# list_append LIST-NAME ELEM
# --------------------------
# Set LIST-NAME to its former contents, with ELEM appended.
list_append ()
{
  local la_l="$1"
  shift
  eval set X \$$la_l "$@"
  shift
  eval $la_l=\""$@"\"
}


# list_concat_dirs LIST-NAME DIR-LIST
# -----------------------------------
# Append to LIST-NAME all the components (included empty) from
# the $path_sep separated list DIR-LIST.  Make the paths absolute.
list_concat_dirs ()
{
  local lcd_list="$1"
  # Empty path components are meaningful to tex.  We rewrite them as
  # `EMPTY' so they don't get lost when we split on $path_sep.
  # Hopefully no one will have an actual directory named EMPTY.
  local replace_EMPTY="-e 's/^$path_sep/EMPTY$path_sep/g' \
                       -e 's/$path_sep\$/${path_sep}EMPTY/g' \
                       -e 's/$path_sep$path_sep/${path_sep}EMPTY:/g'"
  save_IFS=$IFS
  IFS=$path_sep
  set x `echo "$2" | eval sed $replace_EMPTY`; shift
  IFS=$save_IFS
  local dir
  for dir
  do
    case $dir in
      EMPTY)
       list_append $lcd_list ""
       ;;
      *)
       if test -d $dir; then
          dir=`absolute "$dir"`
         list_append $lcd_list "$dir"
       fi
       ;;
    esac
  done
}


# list_prefix LIST-NAME SEP -> STRING
# -----------------------------------
# Return a string that is composed of the LIST-NAME with each item
# preceded by SEP.
list_prefix ()
{
  local lp_p="$2"
  eval set X \$$1
  shift
  local lp_res
  for i
  do
    lp_res="$lp_res \"$lp_p\" \"$i\""
  done
  echo "$lp_res"
}

# list_infix LIST-NAME SEP -> STRING
# ----------------------------------
# Same as list_prefix, but a separator.
list_infix ()
{
  eval set X \$$1
  shift
  local la_IFS="$IFS"
  IFS=$path_sep
  echo "$*"
  IFS=$la_IFS
}

# list_dir_to_abs LIST-NAME
# -------------------------
# Convert the list to using only absolute dir names.
# Currently unused, but should replace absolute_filenames some day.
list_dir_to_abs ()
{
  local ld_l="$1"
  eval set X \$$ld_l
  shift
  local ld_res
  for dir
  do
    dir=`absolute "$dir"`
    test -d "$dir" || continue
    ld_res="$ld_res \"$dir\""
  done
  set X $ld_res; shift
  eval $ld_l=\"$@\"
}


## ------------------------------ ##
## Language auxiliary functions.  ##
## ------------------------------ ##

# out_lang_tex
# ------------
# Return the tex output language (DVI or PDF) for $OUT_LANG.
out_lang_tex ()
{
  case $out_lang in
    dvi | ps | dvipdf ) echo dvi;;
    pdf ) echo $out_lang;;
    html | info | text ) echo $out_lang;;
    *)    error 1 "$0: invalid out_lang: $1";;
  esac
}


# out_lang_ext
# ------------
# Return the extension for $OUT_LANG.
out_lang_ext ()
{
  case $out_lang in
    dvipdf ) echo pdf;;
    dvi | html | info | pdf | ps | text ) echo $out_lang;;
    *)    error 1 "$0: invalid out_lang: $1";;
  esac
}


## ------------------------- ##
## TeX auxiliary functions.  ##
## ------------------------- ##

# Save TEXINPUTS so we can construct a new TEXINPUTS path for each file.
# Likewise for bibtex and makeindex.
tex_envvars="BIBINPUTS BSTINPUTS DVIPSHEADERS INDEXSTYLE MFINPUTS MPINPUTS \
TEXINPUTS TFMFONTS"
for var in $tex_envvars; do
  eval ${var}_orig=\$$var
  export $var
done


# absolute_filenames TEX-PATH -> TEX-PATH
# ---------------------------------------
# Convert relative paths to absolute paths, so we can run in another
# directory (e.g., in tidy build mode, or during the macro-support
# detection).  Prepend ".".
absolute_filenames ()
{
  # Empty path components are meaningful to tex.  We rewrite them as
  # `EMPTY' so they don't get lost when we split on $path_sep.
  # Hopefully no one will have an actual directory named EMPTY.
  local replace_empty="-e 's/^$path_sep/EMPTY$path_sep/g' \
                       -e 's/$path_sep\$/${path_sep}EMPTY/g' \
                       -e 's/$path_sep$path_sep/${path_sep}EMPTY:/g'"
  local res
  res=`echo "$1" | eval sed $replace_empty`
  save_IFS=$IFS
  IFS=$path_sep
  set x $res; shift
  res=.
  for dir
  do
    case $dir in
      EMPTY)
	res=$res$path_sep
	;;
      *)
	if test -d "$dir"; then
	  res=$res$path_sep`absolute "$dir"`
	else
	  # Even if $dir is not a directory, preserve it in the path.
	  # It might contain metacharacters that TeX will expand in
	  # turn, e.g., /some/path/{a,b,c}.  This will not get the
	  # implicit absolutification of the path, but we can't help that.
	  res=$res$path_sep$dir
	fi
	;;
    esac
  done
  echo "$res"
}


# output_base_name FILE
# ---------------------
# The name of FILE, possibly renamed to satisfy --output.
output_base_name ()
{
  case $oname in
    '') echo "$1";;
     *) local out_noext
	out_noext=`echo "$oname" | sed 's/\.[^.]*$//'`
	local file_ext
	file_ext=`echo "$1" | sed 's/^.*\.//'`
	echo "$out_noext.$file_ext"
      ;;
  esac
}


# move_to_dest FILE...
# --------------------
# Move FILE to the place where the user expects it.  Truly move it, that
# is, it must not remain in its build location unless that is also the
# output location.  (Otherwise it might appear as an extra file in make
# distcheck.)
#
# FILE can be the principal output (in which case -o directly applies), or
# an auxiliary file with the same base name.
move_to_dest ()
{
  local dest
  local destfile
  local destdir
  local destbase
  local sourcedir
  local sourcebase

  for file
  do
    case $tidy:$oname in
      true:)  dest=$orig_pwd;;
      false:) dest=;;
      *:*)    dest=`output_base_name "$file"`;;
    esac
    if test ! -f "$file"; then
      error 1 "no such file or directory: $file"
    fi
    if test -n "$dest"; then
      # We need to know whether $dest is a directory.
      if test -d "$dest"; then
        destdir=$dest
        destfile=$dest/$file
      else
        destdir="`dirname $dest`"
        destfile=$dest
      fi
      # We want to compare the source location and the output location,
      # and if they are different, do the move.  But if they are the
      # same, we must preserve the source.  Since we can't assume
      # stat(1) or test -ef is available, resort to comparing the
      # directory names, canonicalized with pwd.  We can't use cmp -s
      # since the output file might not actually change from run to run;
      # e.g., TeX DVI output is timestamped to only the nearest minute.
      destdir=`cd $destdir && pwd`
      destbase=`basename $destfile`
      #
      sourcedir=`dirname $file`
      sourcedir=`cd $sourcedir && pwd`
      sourcebase=`basename $file`
      #
      if test "$sourcedir/$sourcebase" != "$destdir/$destbase"; then
        verbose "Moving $file to $destfile"
        rm -f "$destfile"
        mv "$file" "$destfile"
      fi
    fi
  done
}


## --------------------- ##
## Managing xref files.  ##
## --------------------- ##

# aux_file_p FILE
# ---------------
# Return with success with FILE is an aux file.
aux_file_p ()
{
  test -f "$1" || return 1
  case $1 in
    *.aux) return 0;;
    *)     return 1;;
  esac
}

# bibaux_file_p FILE
# ------------------
# Return with success with FILE is an aux file containing citation
# requests.
bibaux_file_p ()
{
  test -s "$1" || return 1
  if (grep '^\\bibstyle[{]' "$1"   \
      && grep '^\\bibdata[{]' "$1" \
      ## The following line is suspicious: fails when there
      ## are citations in sub aux files.  We need to be
      ## smarter in this case.
      ## && grep '^\\citation[{]' "$f"
      ) >&6 2>&1;
  then
    return 0
  fi
  return 1
}

# index_file_p FILE
# -----------------
# Return with success with FILE is an index file.
# When index.sty is used, there is a space before the brace.
index_file_p ()
{
  test -f "$1" || return 1
  case `sed '1q' "$1"` in
    "\\entry{"*|"\\indexentry{"*|"\\indexentry {"*) return 0;;
    *) return 1;;
  esac
}

# xref_file_p FILE
# ----------------
# Return with success if FILE is an xref file (indexes, tables and lists).
xref_file_p ()
{
  test -f "$1" || return 1
  # If the file is not suitable to be an index or xref file, don't
  # process it.  It's suitable if the first character is a
  # backslash or right quote or at, as long as the first line isn't
  # \input texinfo.
  case `sed '1q' "$1"` in
    "\\input texinfo"*) return 1;;
    [\\''@]*)           return 0;;
	   *)           return 1;;
  esac
}


# generated_files_get FILENAME-NOEXT [PREDICATE-FILTER]
# -----------------------------------------------------
# Return the list of files generated by the TeX compilation of FILENAME-NOEXT.
generated_files_get ()
{
  local filter=true
  if test -n "$2"; then
    filter=$2
  fi

  # Gather the files created by TeX.
  (
    if test -f "$1.log"; then
      sed -n -e "s,^\\\\openout.* = \`\\(.*\\)'\\.,\\1,p" "$1.log"
    fi
    echo "$1.log"
  ) |
  # Depending on these files, infer outputs from other tools.
  while read file; do
    echo $file
    case $in_lang in
      texinfo)
	# texindex: texinfo.cp -> texinfo.cps
       if index_file_p $file; then
	 echo ${file}s
       fi
       ;;
      latex)
	if aux_file_p $file; then
          # bibtex: *.aux -> *.bbl and *.blg.
	  echo $file | sed 's/^\(.*\)\.aux$/\1.bbl/'
          echo $file | sed 's/^\(.*\)\.aux$/\1.blg/'
          # -recorder: .fls
          echo $file | sed 's/^\(.*\)\.aux$/\1.fls/'
       fi
       ;;
    esac
  done |
  # Filter existing files matching the criterion.
  #
  # With an input file name containing a space, this produces a
  # "command not found" message (and filtering is ineffective).
  # The situation with a newline is presumably even worse.
  while read file; do
    if $filter "$file"; then
      echo $file
    fi
  done |
  sort |
  # Some files are opened several times, e.g., listings.sty's *.vrb.
  uniq
}


# xref_files_save
# ---------------
# Save the xref files.
xref_files_save ()
{
  # Save copies of auxiliary files for later comparison.
  xref_files_orig=`generated_files_get "$in_noext" xref_file_p`
  if test -n "$xref_files_orig"; then
    verbose "Backing up xref files: $xref_files_orig"
    # The following line improves `cp $xref_files_orig "$work_bak"'
    # by preserving the directory parts.  Think of
    # cp chap1/main.aux chap2/main.aux $work_bak.
    #
    # Users may have, e.g., --keep-old-files.  Don't let this interfere.
    # (Don't use unset for the sake of ancient shells.)
    TAR_OPTIONS=; export TAR_OPTIONS
    tar cf - $xref_files_orig | (cd "$work_bak" && tar xf -)
  fi
}


# xref_files_changed
# ------------------
# Whether the xref files were changed since the previous run.
xref_files_changed ()
{
  # LaTeX (and the package changebar) report in the LOG file if it
  # should be rerun.  This is needed for files included from
  # subdirs, since texi2dvi does not try to compare xref files in
  # subdirs.  Performing xref files test is still good since LaTeX
  # does not report changes in xref files.
  if grep "Rerun to get" "$in_noext.log" >&6 2>&1; then
    return 0
  fi

  # If old and new lists don't at least have the same file list,
  # then one file or another has definitely changed.
  xref_files_new=`generated_files_get "$in_noext" xref_file_p`
  verbose "Original xref files = $xref_files_orig"
  verbose "New xref files      = $xref_files_new"
  if test "x$xref_files_orig" != "x$xref_files_new"; then
    return 0
  fi

  # Compare each file until we find a difference.
  for this_file in $xref_files_new; do
    verbose "Comparing xref file `echo $this_file | sed 's|\./||g'` ..."
    # cmp -s returns nonzero exit status if files differ.
    if cmp -s "$this_file" "$work_bak/$this_file"; then :; else
      verbose "xref file `echo $this_file | sed 's|\./||g'` differed ..."
      if $debug; then
	diff -u "$work_bak/$this_file" "$this_file"
      fi
      return 0
    fi
  done

  # No change.
  return 1
}



## ----------------------- ##
## Running the TeX suite.  ##
## ----------------------- ##



# run_tex ()
# ----------
# Run TeX as "$tex $in_input", taking care of errors and logs.
run_tex ()
{
  case $in_lang:`out_lang_tex` in
    latex:dvi)   tex=${LATEX:-latex};;
    latex:pdf)   tex=${PDFLATEX:-pdflatex};;
    texinfo:dvi)
	# MetaPost also uses the TEX environment variable.  If the user
	# has set TEX=latex for that reason, don't bomb out.
	case $TEX in
	  *latex) tex=tex;; # don't bother trying to find etex
	       *) tex=$TEX
	esac;;
    texinfo:pdf) tex=$PDFTEX;;

    *) error 1 "$0: $out_lang not supported for $in_lang";;
  esac

  # Beware of aux files in subdirectories that require the
  # subdirectory to exist.
  case $in_lang:$tidy in
    latex:true)
       sed -n 's|^[ ]*\\include{\(.*\)/.*}.*|\1|p' "$in_input" |
       sort -u |
       while read d
       do
	 ensure_dir "$work_build/$d"
       done
       ;;
  esac

  # Note that this will be used via an eval: quote properly.
  local cmd="$tex"

  # If possible, make TeX report error locations in GNU format.
  if test "${tex_help:+set}" != set; then
    # Go to a temporary directory to try --help, since old versions that
    # don't accept --help will generate a texput.log.
    tex_help_dir=$t2ddir/tex_help
    ensure_dir "$tex_help_dir"
    tex_help=`cd "$tex_help_dir" >&6 && $tex --help </dev/null 2>&1`
  fi
  if $no_line_error; then :; else
    # The mk program and perhaps others want to parse TeX's
    # original error messages.
    case $line_error:$tex_help in
      true:*file-line-error*) cmd="$cmd --file-line-error";;
    esac
  fi

  # Tell TeX about TCX file, if specified.
  test -n "$translate_file" && cmd="$cmd --translate-file=$translate_file"

  # Tell TeX to make source specials (for backtracking from output to
  # source, given a sufficiently smart editor), if specifed.
  test -n "$src_specials" && cmd="$cmd $src_specials"

  # Tell TeX to be batch if requested.
  if $batch; then
    # \batchmode does not show terminal output at all, so we don't
    # want that.  And even in batch mode, TeX insists on having input
    # from the user.  Close its stdin to make it impossible.
    cmd="$cmd </dev/null '${escape}nonstopmode'"
  fi

  # we'd like to handle arbitrary input file names, especially
  # foo~bar/a~b.tex, since Debian likes ~ characters.
  if $catcode_special; then
    # $normaltilde is just to reduce line length in this source file.
    # The idea is to define \normaltilde as a catcode other ~ character,
    # then make the active ~ be equivalent to that, instead of the plain
    # TeX tie.  Then when the active ~ appears in the filename, it will
    # be expanded to itself, as far as \input will see.  (This is the
    # same thing that texinfo.tex does in general, BTW.)
    normaltilde="${escape}catcode126=12 ${escape}def${escape}normaltilde{~}"
    cmd="$cmd '$normaltilde${escape}catcode126=13 ${escape}let~\normaltilde '"
  fi
  # Other special (non-active) characters could be supported by
  # resetting their catcodes to other on the command line and changing
  # texinfo.tex to initialize everything to plain catcodes.  Maybe someday.
  
  # append the \input command.
  cmd="$cmd '${escape}input'"

  # TeX's \input does not (easily or reliably) support whitespace
  # characters or other special characters in file names.  Our intensive
  # use of absolute file names makes this worse: the enclosing directory
  # names may include white spaces.  Improve the situation using a
  # symbolic link to the filename in the current directory, in tidy mode
  # only.  Do not alter in_input.
  #
  # The filename is almost always tokenized using plain TeX conventions
  # (the exception would be if the user made a texinfo.fmt file).  Not
  # all the plain TeX special characters cause trouble, but there's no
  # harm in making the link.
  #
  case $tidy:`func_dirname "$in_input"` in
    true:*["$space$tab$newline\"#\$%\\^_{}~"]*)
      _run_tex_file_name=`basename "$in_input"`
      if test ! -f "$_run_tex_file_name"; then
	# It might not be a file, clear it.
	run rm -f "$_run_tex_file_name"
	run ln -s "$in_input"
      fi
      cmd="$cmd '$_run_tex_file_name'"
      ;;

    *)
      cmd="$cmd '$in_input'"
      ;;
  esac

  verbose "$0: Running $cmd ..."
  if eval "$cmd" >&5; then
    case $out_lang in
      dvi | pdf ) move_to_dest "$in_noext.$out_lang";;
    esac
  else
    error 1 "$tex exited with bad status, quitting."
  fi
}

# run_bibtex ()
# -------------
# Run bibtex on current file.
# - If its input (AUX) exists.
# - If some citations are missing (LOG contains `Citation').
#   or the LOG complains of a missing .bbl
#
# Don't try to be too smart:
#
# 1. Running bibtex only if the bbl file exists and is older than
# the LaTeX file is wrong, since the document might include files
# that have changed.
#
# 3. Because there can be several AUX (if there are \include's),
# but a single LOG, looking for missing citations in LOG is
# easier, though we take the risk to match false messages.
run_bibtex ()
{
  case $in_lang in
    latex)   bibtex=${BIBTEX:-bibtex};;
    texinfo) return;;
  esac

  # "Citation undefined" is for LaTeX, "Undefined citation" for btxmac.tex.
  # The no .aux && \bibdata test is also for btxmac, in case it was the
  # first run of a bibtex-using document.  Otherwise, it's possible that
  # bibtex would never be run.
  if test -r "$in_noext.aux" \
     && test -r "$in_noext.log" \
     && (grep 'Warning:.*Citation.*undefined' "$in_noext.log" \
	  || grep '.*Undefined citation' "$in_noext.log" \
	  || grep 'No file .*\.bbl\.' "$in_noext.log") \
	  || (grep 'No \.aux file' "$in_noext.log" \
	      && grep '^\\bibdata' "$in_noext.aux") \
	>&6 2>&1; \
  then
    for f in `generated_files_get "$in_noext" bibaux_file_p`
    do
      run $bibtex "$f"
    done
  fi
}

# run_index ()
# ------------
# Run texindex (or makeindex) on current index files.  If they already
# exist, and after running TeX a first time the index files don't
# change, then there's no reason to run TeX again.  But we won't know
# that if the index files are out of date or nonexistent.
run_index ()
{
  case $in_lang in
    latex)   texindex=${MAKEINDEX:-makeindex};;
    texinfo) texindex=${TEXINDEX:-texindex};;
  esac
  index_files=`generated_files_get $in_noext index_file_p`
  if test -n "$texindex" && test -n "$index_files"; then
    run $texindex $index_files
  fi
}


# run_thumbpdf ()
# ---------------
run_thumbpdf ()
{
  if test `out_lang_tex` = pdf \
     && test -r "$in_noext.log" \
     && grep 'thumbpdf\.sty'  "$in_noext.log" >&6 2>&1; \
  then
    thumbpdf=${THUMBPDF:-thumbpdf}
    thumbcmd="$thumbpdf $in_dir/$in_noext"
    verbose "Running $thumbcmd ..."
    if $thumbcmd >&5; then
      run_tex
    else
      report "$thumbpdf exited with bad status." \
	     "Ignoring its output."
    fi
  fi
}


# run_dvipdf FILE.dvi
# -------------------
# Convert FILE.dvi to FILE.pdf.
run_dvipdf ()
{
  # Find which dvi->pdf program is available.
  if test -z "$dvipdf"; then
    for i in "$DVIPDF" dvipdfmx dvipdfm dvipdf dvi2pdf dvitopdf;
    do
      if findprog $i; then
	dvipdf=$i
      fi
    done
  fi
  # These tools have varying interfaces, some 'input output', others
  # 'input -o output'.  They all seem to accept 'input' only,
  # outputting using the expected file name.
  run $dvipdf "$1"
  if test ! -f `echo "$1" | sed -e 's/\.dvi$/.pdf/'`; then
    error 1 "$0: cannot find output file"
  fi
}

# run_tex_suite ()
# ----------------
# Run the TeX tools until a fix point is reached.
run_tex_suite ()
{
  # Move to the working directory.
  if $tidy; then
    verbose "cd $work_build"
    cd "$work_build" || exit 1
  fi

  # Count the number of cycles.
  local cycle=0

  while :; do
    cycle=`expr $cycle + 1`
    verbose "Cycle $cycle for $command_line_filename"

    xref_files_save

    # We run bibtex first, because I can see reasons for the indexes
    # to change after bibtex is run, but I see no reason for the
    # converse.
    run_bibtex
    run_index
    run_core_conversion

    xref_files_changed || break
  done

  # If we were using thumbpdf and producing PDF, then run thumbpdf
  # and TeX one last time.
  run_thumbpdf

  # Install the result if we didn't already (i.e., if the output is
  # dvipdf or ps).
  case $out_lang in
    dvipdf)
      run_dvipdf "$in_noext.`out_lang_tex`"
      move_to_dest "$in_noext.`out_lang_ext`"
      ;;
    ps)
      dvips -o "$in_noext.`out_lang_ext`" "$in_noext.`out_lang_tex`"
      move_to_dest "$in_noext.`out_lang_ext`"
      ;;
  esac

  cd_orig
}

## -------------------------------- ##
## TeX processing auxiliary tools.  ##
## -------------------------------- ##


# A sed script that preprocesses Texinfo sources in order to keep the
# iftex sections only.  We want to remove non TeX sections, and comment
# (with `@c texi2dvi') TeX sections so that makeinfo does not try to
# parse them.  Nevertheless, while commenting TeX sections, don't
# comment @macro/@end macro so that makeinfo does propagate them.
# Unfortunately makeinfo --iftex --no-ifinfo doesn't work well enough
# (yet), makeinfo can't parse the TeX commands, so work around with sed.
#
comment_iftex=\
'/^@tex/,/^@end tex/{
  s/^/@c texi2dvi/
}
/^@iftex/,/^@end iftex/{
  s/^/@c texi2dvi/
  /^@c texi2dvi@macro/,/^@c texi2dvi@end macro/{
    s/^@c texi2dvi//
  }
}
/^@ifnottex/,/^@end ifnottex/{
  s/^/@c (texi2dvi)/
}
/^@ifinfo/,/^@end ifinfo/{
  /^@node/p
  /^@menu/,/^@end menu/p
  t
  s/^/@c (texi2dvi)/
}
s/^@ifnotinfo/@c texi2dvi@ifnotinfo/
s/^@end ifnotinfo/@c texi2dvi@end ifnotinfo/'

# Uncommenting is simple: Remove any leading `@c texi2dvi'.
uncomment_iftex='s/^@c texi2dvi//'


# run_makeinfo ()
# ---------------
# Expand macro commands in the original source file using Makeinfo.
# Always use `end' footnote style, since the `separate' style
# generates different output (arguably this is a bug in -E).  Discard
# main info output, the user asked to run TeX, not makeinfo.
run_makeinfo ()
{
  test $in_lang = texinfo \
    || return 0

  # Unless required by the user, makeinfo expansion is wanted only
  # if texinfo.tex is too old.
  if test "$expand" = t; then
    makeinfo=${MAKEINFO:-makeinfo}
  else
    # Check if texinfo.tex performs macro expansion by looking for
    # its version.  The version is a date of the form YEAR-MO-DA.
    # We don't need to use [0-9] to match the digits since anyway
    # the comparison with $txiprereq, a number, will fail with non
    # digits.
    # Run in a temporary directory to avoid leaving files.
    version_test_dir=$t2ddir/version_test
    ensure_dir "$version_test_dir"
    (
       cd "$version_test_dir"
       echo '\input texinfo.tex @bye' >txiversion.tex
       # Be sure that if tex wants to fail, it is not interactive:
       # close stdin.
       $TEX txiversion.tex </dev/null >txiversion.out 2>txiversion.err
    )
    if test $? != 0; then
      cat "$version_test_dir/txiversion.out"
      cat "$version_test_dir/txiversion.err" >&2
      error 1 "texinfo.tex appears to be broken, quitting."
    fi
    eval `sed -n 's/^.*\[\(.*\)version \(....\)-\(..\)-\(..\).*$/txiformat=\1 txiversion="\2\3\4"/p' "$version_test_dir/txiversion.out"`
    verbose "texinfo.tex preloaded as \`$txiformat', version is \`$txiversion' ..."
    if test "$txiprereq" -le "$txiversion" >&6 2>&1; then
      makeinfo=
    else
      makeinfo=${MAKEINFO:-makeinfo}
    fi
    # As long as we had to run TeX, offer the user this convenience:
    if test "$txiformat" = Texinfo; then
	escape=@
    fi
  fi

  if test -n "$makeinfo"; then
    # in_src: the file with macros expanded.
    # Use the same basename to generate the same aux file names.
    work_src=$workdir/src
    ensure_dir "$work_src"
    in_src=$work_src/$in_base
    local miincludes
    miincludes=`list_prefix includes -I`
    verbose "Macro-expanding $command_line_filename to $in_src ..."
    # eval $makeinfo because it might be defined as something complex
    # (running missing) and then we end up with things like '"-I"',
    # and "-I" (including the quotes) is not an option name.  This
    # happens with gettext 0.14.5, at least.
    sed "$comment_iftex" "$command_line_filename" \
      | eval $makeinfo --footnote-style=end -I "$in_dir" $miincludes \
	-o /dev/null --macro-expand=- \
      | sed "$uncomment_iftex" >"$in_src"
    # Continue only if everything succeeded.
    if test $? -ne 0 \
       || test ! -r "$in_src"; then
      verbose "Expansion failed, ignored...";
    else
      in_input=$in_src
    fi
  fi
}

# insert_commands ()
# ------------------
# Used most commonly for @finalout, @smallbook, etc.
insert_commands ()
{
  local textra_cmd
  case $in_lang in
    latex)   textra_cmd=1i;;
    texinfo) textra_cmd='/^@setfilename/a';;
    *)       error 1 "internal error, unknown language: $in_lang";;
  esac

  if test -n "$textra"; then
    # _xtr.  The file with the user's extra commands.
    work_xtr=$workdir/xtr
    in_xtr=$work_xtr/$in_base
    ensure_dir "$work_xtr"
    verbose "Inserting extra commands: $textra"
    sed "$textra_cmd\\
$textra" "$in_input" >"$in_xtr"
    in_input=$in_xtr
  fi
}

# run_recode ()
# -------------
# If this is a Texinfo file with a specified input encoding, and
# recode is available, then recode to plain 7 bit Texinfo.
run_recode ()
{
  local from
  local to

  if test $in_lang = texinfo; then
    pgm='s/^ *@documentencoding  *\([^ ][^ ]*\) *$/\1/
	t found
	d
	:found
	q'
    encoding=`sed -e "$pgm" "$in_input"`
    if $recode && test -n "$encoding" && findprog recode; then
      if test -n "$recode_from"; then
	from=$recode_from
	to=$encoding
      else
	from=$encoding
	to=$texinfo
      fi
      verbose "Recoding from $from to $to."
      # _rcd.  The Texinfo file recoded in 7bit.
      work_rcd=$workdir/recode
      in_rcd=$work_rcd/$in_base
      ensure_dir "$work_rcd"
      if recode "$encoding..$to" <"$in_input" >"$in_rcd" \
	 && test -s "$in_rcd"; then
	in_input=$in_rcd
      else
	verbose "Recoding failed, using original input."
      fi
    fi
  fi
}

# compute_language FILENAME
# -------------------------
# Return the short string describing the language in which FILENAME
# is written: `texinfo' or `latex'.
compute_language ()
{
  # If the user explicitly specified the language, use that.
  # Otherwise, if the first line is \input texinfo, assume it's texinfo.
  # Otherwise, guess from the file extension.
  if test -n "$set_language"; then
    echo $set_language
  elif sed 1q "$1" | grep 'input texinfo' >&6; then
    echo texinfo
  else
    # Get the type of the file (latex or texinfo) from the given language
    # we just guessed, or from the file extension if not set yet.
    case $1 in
      *.ltx | *.tex | *.drv | *.dtx) echo latex;;
      *)                             echo texinfo;;
    esac
  fi
}


# run_hevea (MODE)
# ----------------
# Convert to HTML/INFO/TEXT.
#
# Don't pass `-noiso' to hevea: it's useless in HTML since anyway the
# charset is set to latin1, and troublesome in other modes since
# accented characters loose their accents.
#
# Don't pass `-o DEST' to hevea because in that case it leaves all its
# auxiliary files there too...  Too bad, because it means we will need
# to handle images some day.
run_hevea ()
{
  local hevea="${HEVEA:-hevea}"
  local run_hevea="$hevea"

  case $1 in
    html) ;;
    text|info) run_hevea="$run_hevea -$1";;
    *) error 1 "run_hevea: invalid argument: $1";;
  esac

  # Compiling to the tmp directory enables to preserve a previous
  # successful compilation.
  run_hevea="$run_hevea -fix -O -o '$out_base'"
  run_hevea="$run_hevea `list_prefix includes -I` -I '$orig_pwd' "
  run_hevea="$run_hevea '$in_input'"

  if $debug; then
    run_hevea="$run_hevea -v -v"
  fi

  verbose "running $run_hevea"
  if eval "$run_hevea" >&5; then
    # hevea leaves trailing white spaces, this is annoying.
    case $1 in text|info)
      perl -pi -e 's/[ \t]+$//g' "$out_base"*;;
    esac
    case $1 in
    html|text) move_to_dest "$out_base";;
    info) # There can be foo.info-1, foo.info-2 etc.
	       move_to_dest "$out_base"*;;
    esac
  else
    error 1 "$hevea exited with bad status, quitting."
  fi
}


# run_core_conversion ()
# ----------------------
# Run the TeX (or HeVeA).
run_core_conversion ()
{
  case $in_lang:`out_lang_tex` in
    *:dvi|*:pdf)
	run_tex;;
    latex:html|latex:text|latex:info)
	run_hevea $out_lang;;
    *)
	error 1 "invalid input/output combination: $in_lang/$out_lang";;
  esac
}


# compile ()
# ----------
# Run the full compilation chain, from pre-processing to installation
# of the output at its expected location.
compile ()
{
  # Source file might include additional sources.
  # We want `.:$orig_pwd' before anything else.  (We'll add `.:' later
  # after all other directories have been turned into absolute paths.)
  # `.' goes first to ensure that any old .aux, .cps,
  # etc. files in ${directory} don't get used in preference to fresher
  # files in `.'.  Include orig_pwd in case we are in clean build mode, where
  # we've cd'd to a temp directory.
  txincludes=`list_infix includes $path_sep`
  common="$orig_pwd$path_sep$in_dir$path_sep$txincludes$path_sep"
  for var in $tex_envvars; do
    eval val="\$common\$${var}_orig"
    # Convert relative paths to absolute paths, so we can run in another
    # directory (e.g., in clean build mode, or during the macro-support
    # detection). ".:" is added here.
    val=`absolute_filenames "$val"`
    eval $var="\"$val\""
    export $var
    eval verbose \"$var=\'\$${var}\'\"
  done

  # --expand
  run_makeinfo

  # --command, --texinfo
  insert_commands

  # --recode
  run_recode

  # Run until a fix point is reached.
  run_tex_suite
}


# remove FILES
# ------------
remove ()
{
  verbose "Removing" "$@"
  rm -rf "$@"
}


# mostly_clean
# ------------
# Remove auxiliary files and directories.  Changes the current directory.
mostly_clean ()
{
  cd_orig
  set X "$t2ddir"
  shift
  $tidy || {
    local log="$work_build/$in_noext.log"
    set X ${1+"$@"} "$log" `generated_files_get "$work_build/$in_noext"`
    shift
  }
  remove ${1+"$@"}
}


# cleanup ()
# ----------
# Remove what should be removed according to options.
# Called at the end of each compilation cycle, and at the end of
# the script.  Changes the current directory.
cleanup ()
{
  case $build_mode in
    local) cd_orig; remove "$t2ddir";;
    clean) mostly_clean;;
    tidy)  ;;
  esac
}



## ---------------------- ##
## Command line parsing.  ##
## ---------------------- ##

# Push a token among the arguments that will be used to notice when we
# ended options/arguments parsing.
# Use "set dummy ...; shift" rather than 'set - ..." because on
# Solaris set - turns off set -x (but keeps set -e).
# Use ${1+"$@"} rather than "$@" because Digital Unix and Ultrix 4.3
# still expand "$@" to a single argument (the empty string) rather
# than nothing at all.
arg_sep="$$--$$"
set dummy ${1+"$@"} "$arg_sep"; shift

# 
# Parse command line arguments.
while test x"$1" != x"$arg_sep"; do

  # Handle --option=value by splitting apart and putting back on argv.
  case "$1" in
    --*=*)
      opt=`echo "$1" | sed -e 's/=.*//'`
      val=`echo "$1" | sed -e 's/[^=]*=//'`
      shift
      set dummy "$opt" "$val" ${1+"$@"}; shift
      ;;
  esac

  # This recognizes --quark as --quiet.  So what.
  case "$1" in
    -@ ) escape=@;;
    # Silently and without documentation accept -b and --b[atch] as synonyms.
    -b | --batch) batch=true;;
	 --build)      shift; build_mode=$1;;
	 --build-dir)  shift; build_dir=$1; build_mode=tidy;;
    -c | --clean) build_mode=clean;;
    -D | --debug) debug=true;;
	 --dvi)   out_lang=dvi;;
	 --dvipdf)   out_lang=dvipdf;;
    -e | -E | --expand) expand=t;;
    -h | --help) usage;;
	 --html) out_lang=html;;
    -I)   shift; list_concat_dirs includes "$1";;
    --info) out_lang=info;;
    -l | --lang | --language) shift; set_language=$1;;
    --mostly-clean) action=mostly-clean;;
    --no-line-error) no_line_error=true;;
    -o | --out  | --output)
      shift
      # Make it absolute, just in case we also have --clean, or whatever.
      oname=`absolute "$1"`;;
    -p | --pdf) out_lang=pdf;;
	 --ps)  out_lang=ps;;
    -q | -s | --quiet | --silent) quiet=true; batch=true;;
    -r | --recode) recode=true;;
    --recode-from) shift; recode=true; recode_from="$1";;
    --src-specials) src_specials=--src-specials;;
    -t | --texinfo | --command ) shift; textra="$textra\\
"`echo "$1" | sed 's/\\\\/\\\\\\\\/g'`;;
    --text) out_lang=text;;
    --translate-file ) shift; translate_file="$1";;
    --tidy) build_mode=tidy;;
    -v | --vers*) version;;
    -V | --verb*) verb=true;;
    --) # What remains are not options.
      shift
      while test x"$1" != x"$arg_sep"; do
	set dummy ${1+"$@"} "$1"; shift
	shift
      done
      break;;
    -*)
      error 1 "Unknown or ambiguous option \`$1'." \
	      "Try \`--help' for more information."
      ;;
    *) set dummy ${1+"$@"} "$1"; shift;;
   esac
   shift
done
# Pop the token
shift

# $tidy:  compile in a t2d directory.
# $clean: remove all the aux files.
case $build_mode in
  local) clean=false; tidy=false;;
  tidy)  clean=false; tidy=true;;
  clean) clean=true;  tidy=true;;
      *) error 1 "invalid build mode: $build_mode";;
esac

# Interpret remaining command line args as filenames.
case $# in
 0)
  error 2 "Missing file arguments." "Try \`--help' for more information."
  ;;
 1) ;;
 *)
  if test -n "$oname"; then
    error 2 "Can't use option \`--output' with more than one argument."
  fi
  ;;
esac


# We can't do much without tex.
#
if findprog ${TEX:-tex}; then :; else cat <<EOM
You don't have a working TeX binary (${TEX:-tex}) installed anywhere in
your PATH, and texi2dvi cannot proceed without one.  If you want to use
this script, you'll need to install TeX (if you don't have it) or change
your PATH or TEX environment variable (if you do).  See the --help
output for more details.

For information about obtaining TeX, please see http://www.tug.org.  If
you happen to be using Debian, you can get it with this command:
  apt-get install tetex-bin
EOM
  exit 1
fi


# We want to use etex (or pdftex) if they are available, and the user
# didn't explicitly specify.  We don't check for elatex and pdfelatex
# because (as of 2003), the LaTeX team has asked that new distributions
# use etex by default anyway.
#
# End up with the TEX and PDFTEX variables set to what we are going to use.
if test -z "$TEX"; then
  if findprog etex; then TEX=etex; else TEX=tex; fi
fi
#
if test -z "$PDFTEX"; then
  if findprog pdfetex; then PDFTEX=pdfetex; else PDFTEX=pdftex; fi
fi


# File descriptor usage:
# 0 standard input
# 1 standard output (--verbose messages)
# 2 standard error
# 3 some systems may open it to /dev/tty
# 4 used on the Kubota Titan
# 5 tools output (turned off by --quiet)
# 6 tracing/debugging (set -x output, etc.)


# Main tools' output (TeX, etc.) that TeX users are used to seeing.
#
# If quiet, discard, else redirect to the message flow.
if $quiet; then
  exec 5>/dev/null
else
  exec 5>&1
fi


# Enable tracing, and auxiliary tools output.
#
# Should be used where you'd typically use /dev/null to throw output
# away.  But sometimes it is convenient to see that output (e.g., from
# a grep) to aid debugging.  Especially debugging at distance, via the
# user.
if $debug; then
  exec 6>&1
  set -x
else
  exec 6>/dev/null
fi

# 

# input_file_name_decode
# ----------------------
# Decode COMMAND_LINE_FILENAME, and compute:
# - COMMAND_LINE_FILENAME clean of TeX commands
# - IN_DIR
#   The directory to the input file, possibly absolute if needed.
# - IN_DIR_ABS
#   The absolute directory of the input file.
# - IN_BASE
#   The input file base name (no directory part).
# - IN_NOEXT
#   The input file name without extensions (nor directory part).
# - IN_INPUT
#   Defaults to COMMAND_LINE_FILENAME, but might change if the
#   input is preprocessed (recode etc.).  With directory, possibly absolute.
input_file_name_decode ()
{
  # See if we are run from within AUC-Tex, in which case we are
  # passed `\input{FOO.tex}' or even `\nonstopmode\input{FOO.tex}'.
  case $command_line_filename in
    *\\nonstopmode*)
      batch=true;;
  esac
  case $command_line_filename in
    *\\input{*}*)
      # Let AUC-TeX error parser deal with line numbers.
      line_error=false
      command_line_filename=`\
	expr X"$command_line_filename" : X'.*input{\([^}]*\)}'`
      ;;
  esac

  # If the COMMAND_LINE_FILENAME is not absolute (e.g., --debug.tex),
  # prepend `./' in order to avoid that the tools take it as an option.
  echo "$command_line_filename" | $EGREP '^(/|[A-z]:/)' >&6 \
  || command_line_filename="./$command_line_filename"

  # See if the file exists.  If it doesn't we're in trouble since, even
  # though the user may be able to reenter a valid filename at the tex
  # prompt (assuming they're attending the terminal), this script won't
  # be able to find the right xref files and so forth.
  test -r "$command_line_filename" ||
    error 1 "cannot read $command_line_filename, skipping."

  # Get the name of the current directory.
  in_dir=`func_dirname "$command_line_filename"`
  in_dir_abs=`absolute "$in_dir"`
  # In a clean build, we `cd', so get an absolute file name.
  if $tidy; then
    in_dir=$in_dir_abs
  fi

  # Strip directory part but leave extension.
  in_base=`basename "$command_line_filename"`
  # Strip extension.
  in_noext=`echo "$in_base" | sed 's/\.[^.]*$//'`

  # The normalized file name to compile.  Must always point to the
  # file to actually compile (in case of recoding, macro-expansion etc.).
  in_input=$in_dir/$in_base


  # Compute the output file name.
  if test x"$oname" != x; then
    out_name=$oname
  else
    out_name=$in_noext.`out_lang_ext`
  fi
  out_dir=`func_dirname "$out_name"`
  out_dir_abs=`absolute "$out_dir"`
  out_base=`basename "$out_name"`
  out_noext=`echo "$out_base" | sed 's/\.[^.]*$//'`
}


## -------------- ##
## TeXify files.  ##
## -------------- ##

for command_line_filename
do
  verbose "Processing $command_line_filename ..."

  input_file_name_decode

  # `texinfo' or `latex'?
  in_lang=`compute_language "$command_line_filename"`

  # An auxiliary directory used for all the auxiliary tasks involved
  # in compiling this document.
  case $build_dir in
      '' | . ) t2ddir=$out_noext.t2d ;;
      *) # Avoid collisions between multiple occurrences of the same
	 # file.  The sed expression is fragile if the cwd has
	 # active characters.
	 t2ddir=$build_dir/`echo "$out_dir_abs/$out_noext.t2d" |
	     sed "s,^$orig_pwd/,," |
	     sed 's,/,!,g'`
  esac
  # Remove it at exit if clean mode.
  trap "cleanup" 0 HUP INT TERM

  ensure_dir "$build_dir" "$t2ddir"

  # We will change directory, better work with an absolute path...
  t2ddir=`absolute "$t2ddir"`
  # Sometimes there are incompatibilities between auxiliary files for
  # DVI and PDF.  The contents can also change whether we work on PDF
  # and/or DVI.  So keep separate spaces for each.
  workdir=$t2ddir/`out_lang_tex`
  ensure_dir "$workdir"

  # _build.  In a tidy build, where the auxiliary files are output.
  if $tidy; then
    work_build=$workdir/build
  else
    work_build=.
  fi

  # _bak.  Copies of the previous auxiliary files (another round is
  # run if they differ from the new ones).
  work_bak=$workdir/bak

  # Make those directories.
  ensure_dir "$work_build" "$work_bak"

  case $action in
    compile)
      # Compile the document.
      compile
      cleanup
      ;;

    mostly-clean)
      mostly_clean
      ;;
  esac
done

verbose "done."
exit 0 # exit successfully, not however we ended the loop.
