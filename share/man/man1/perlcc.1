.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLCC 1"
.TH PERLCC 1 "2011-04-26" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
perlcc \- generate executables from Perl programs
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    $ perlcc hello              # Compiles into executable 'a.out'
\&    $ perlcc -o hello hello.pl  # Compiles into executable 'hello'
.Ve
.PP
.Vb 2
\&    $ perlcc -O file            # Compiles using the optimised C backend
\&    $ perlcc -B file            # Compiles using the bytecode backend
.Ve
.PP
.Vb 4
\&    $ perlcc -c file            # Creates a C file, 'file.c'
\&    $ perlcc -S -o hello file   # Creates a C file, 'file.c',
\&                                # then compiles it to executable 'hello'
\&    $ perlcc -c out.c file      # Creates a C file, 'out.c' from 'file'
.Ve
.PP
.Vb 2
\&    $ perlcc -e 'print q//'     # Compiles a one-liner into 'a.out'
\&    $ perlcc -c -e 'print q//'  # Creates a C file 'a.out.c'
.Ve
.PP
.Vb 2
\&    $ perlcc -I /foo hello      # extra headers (notice the space after -I)
\&    $ perlcc -L /foo hello      # extra libraries (notice the space after -L)
.Ve
.PP
.Vb 3
\&    $ perlcc -r hello           # compiles 'hello' into 'a.out', runs 'a.out'.
\&    $ perlcc -r hello a b c     # compiles 'hello' into 'a.out', runs 'a.out'.
\&                                # with arguments 'a b c'
.Ve
.PP
.Vb 2
\&    $ perlcc hello -log c       # compiles 'hello' into 'a.out' logs compile
\&                                # log into 'c'.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIperlcc\fR creates standalone executables from Perl programs, using the
code generators provided by the B module. At present, you may
either create executable Perl bytecode, using the \f(CW\*(C`\-B\*(C'\fR option, or 
generate and compile C files using the standard and 'optimised' C
backends.
.PP
The code generated in this way is not guaranteed to work. The whole
codegen suite (\f(CW\*(C`perlcc\*(C'\fR included) should be considered \fBvery\fR
experimental. Use for production purposes is strongly discouraged.
.SH "OPTIONS"
.IX Header "OPTIONS"
.IP "\-L\fIlibrary directories\fR" 4
.IX Item "-Llibrary directories"
Adds the given directories to the library search path when C code is
passed to your C compiler.
.IP "\-I\fIinclude directories\fR" 4
.IX Item "-Iinclude directories"
Adds the given directories to the include file search path when C code is
passed to your C compiler; when using the Perl bytecode option, adds the
given directories to Perl's include path.
.IP "\-o \fIoutput file name\fR" 4
.IX Item "-o output file name"
Specifies the file name for the final compiled executable.
.IP "\-c \fIC file name\fR" 4
.IX Item "-c C file name"
Create C code only; do not compile to a standalone binary.
.IP "\-e \fIperl code\fR" 4
.IX Item "-e perl code"
Compile a one\-liner, much the same as \f(CW\*(C`perl \-e '...'\*(C'\fR
.IP "\-S" 4
.IX Item "-S"
Do not delete generated C code after compilation.
.IP "\-B" 4
.IX Item "-B"
Use the Perl bytecode code generator.
.IP "\-O" 4
.IX Item "-O"
Use the 'optimised' C code generator. This is more experimental than
everything else put together, and the code created is not guaranteed to
compile in finite time and memory, or indeed, at all.
.IP "\-v" 4
.IX Item "-v"
Increase verbosity of output; can be repeated for more verbose output.
.IP "\-r" 4
.IX Item "-r"
Run the resulting compiled script after compiling it.
.IP "\-log" 4
.IX Item "-log"
Log the output of compiling to a file rather than to stdout.
