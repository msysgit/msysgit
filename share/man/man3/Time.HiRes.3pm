.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Time::HiRes 3pm"
.TH Time::HiRes 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Time::HiRes \- High resolution alarm, sleep, gettimeofday, interval timers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use Time::HiRes qw( usleep ualarm gettimeofday tv_interval nanosleep
\&                      clock_gettime clock_getres clock_nanosleep clock );
.Ve
.PP
.Vb 2
\&  usleep ($microseconds);
\&  nanosleep ($nanoseconds);
.Ve
.PP
.Vb 2
\&  ualarm ($microseconds);
\&  ualarm ($microseconds, $interval_microseconds);
.Ve
.PP
.Vb 2
\&  $t0 = [gettimeofday];
\&  ($seconds, $microseconds) = gettimeofday;
.Ve
.PP
.Vb 3
\&  $elapsed = tv_interval ( $t0, [$seconds, $microseconds]);
\&  $elapsed = tv_interval ( $t0, [gettimeofday]);
\&  $elapsed = tv_interval ( $t0 );
.Ve
.PP
.Vb 1
\&  use Time::HiRes qw ( time alarm sleep );
.Ve
.PP
.Vb 4
\&  $now_fractions = time;
\&  sleep ($floating_seconds);
\&  alarm ($floating_seconds);
\&  alarm ($floating_seconds, $floating_interval);
.Ve
.PP
.Vb 2
\&  use Time::HiRes qw( setitimer getitimer
\&                      ITIMER_REAL ITIMER_VIRTUAL ITIMER_PROF ITIMER_REALPROF );
.Ve
.PP
.Vb 2
\&  setitimer ($which, $floating_seconds, $floating_interval );
\&  getitimer ($which);
.Ve
.PP
.Vb 2
\&  $realtime   = clock_gettime(CLOCK_REALTIME);
\&  $resolution = clock_getres(CLOCK_REALTIME);
.Ve
.PP
.Vb 2
\&  clock_nanosleep(CLOCK_REALTIME, 1.5);
\&  clock_nanosleep(CLOCK_REALTIME, time() + 10, TIMER_ABSTIME);
.Ve
.PP
.Vb 1
\&  my $ticktock = clock();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Time::HiRes\*(C'\fR module implements a Perl interface to the
\&\f(CW\*(C`usleep\*(C'\fR, \f(CW\*(C`nanosleep\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR, \f(CW\*(C`gettimeofday\*(C'\fR, and
\&\f(CW\*(C`setitimer\*(C'\fR/\f(CW\*(C`getitimer\*(C'\fR system calls, in other words, high
resolution time and timers. See the \*(L"\s-1EXAMPLES\s0\*(R" section below and the
test scripts for usage; see your system documentation for the
description of the underlying \f(CW\*(C`nanosleep\*(C'\fR or \f(CW\*(C`usleep\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR,
\&\f(CW\*(C`gettimeofday\*(C'\fR, and \f(CW\*(C`setitimer\*(C'\fR/\f(CW\*(C`getitimer\*(C'\fR calls.
.PP
If your system lacks \f(CW\*(C`gettimeofday()\*(C'\fR or an emulation of it you don't
get \f(CW\*(C`gettimeofday()\*(C'\fR or the one-argument form of \f(CW\*(C`tv_interval()\*(C'\fR.
If your system lacks all of \f(CW\*(C`nanosleep()\*(C'\fR, \f(CW\*(C`usleep()\*(C'\fR,
\&\f(CW\*(C`select()\*(C'\fR, and \f(CW\*(C`poll\*(C'\fR, you don't get \f(CW\*(C`Time::HiRes::usleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::nanosleep()\*(C'\fR, or \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR.
If your system lacks both \f(CW\*(C`ualarm()\*(C'\fR and \f(CW\*(C`setitimer()\*(C'\fR you don't get
\&\f(CW\*(C`Time::HiRes::ualarm()\*(C'\fR or \f(CW\*(C`Time::HiRes::alarm()\*(C'\fR.
.PP
If you try to import an unimplemented function in the \f(CW\*(C`use\*(C'\fR statement
it will fail at compile time.
.PP
If your subsecond sleeping is implemented with \f(CW\*(C`nanosleep()\*(C'\fR instead
of \f(CW\*(C`usleep()\*(C'\fR, you can mix subsecond sleeping with signals since
\&\f(CW\*(C`nanosleep()\*(C'\fR does not use signals.  This, however, is not portable,
and you should first check for the truth value of
\&\f(CW&Time::HiRes::d_nanosleep\fR to see whether you have nanosleep, and
then carefully read your \f(CW\*(C`nanosleep()\*(C'\fR C \s-1API\s0 documentation for any
peculiarities.
.PP
If you are using \f(CW\*(C`nanosleep\*(C'\fR for something else than mixing sleeping
with signals, give some thought to whether Perl is the tool you should
be using for work requiring nanosecond accuracies.
.PP
The following functions can be imported from this module.
No functions are exported by default.
.IP "gettimeofday ()" 4
.IX Item "gettimeofday ()"
In array context returns a two-element array with the seconds and
microseconds since the epoch.  In scalar context returns floating
seconds like \f(CW\*(C`Time::HiRes::time()\*(C'\fR (see below).
.ie n .IP "usleep ( $useconds )" 4
.el .IP "usleep ( \f(CW$useconds\fR )" 4
.IX Item "usleep ( $useconds )"
Sleeps for the number of microseconds (millionths of a second)
specified.  Returns the number of microseconds actually slept.  Can
sleep for more than one second, unlike the \f(CW\*(C`usleep\*(C'\fR system call. Can
also sleep for zero seconds, which often works like a \fIthread yield\fR.
See also \f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR, and
\&\f(CW\*(C`Time::HiRes::clock_nanosleep()\*(C'\fR.
.Sp
Do not expect \fIusleep()\fR to be exact down to one microsecond.
.ie n .IP "nanosleep ( $nanoseconds )" 4
.el .IP "nanosleep ( \f(CW$nanoseconds\fR )" 4
.IX Item "nanosleep ( $nanoseconds )"
Sleeps for the number of nanoseconds (1e9ths of a second) specified.
Returns the number of nanoseconds actually slept (accurate only to
microseconds, the nearest thousand of them).  Can sleep for more than
one second.  Can also sleep for zero seconds, which often works like a
\&\fIthread yield\fR.  See also \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, and \f(CW\*(C`Time::HiRes::clock_nanosleep()\*(C'\fR.
.Sp
Do not expect \fInanosleep()\fR to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.
.ie n .IP "ualarm ( $useconds\fR [, \f(CW$interval_useconds ] )" 4
.el .IP "ualarm ( \f(CW$useconds\fR [, \f(CW$interval_useconds\fR ] )" 4
.IX Item "ualarm ( $useconds [, $interval_useconds ] )"
Issues a \f(CW\*(C`ualarm\*(C'\fR call; the \f(CW$interval_useconds\fR is optional and
will be zero if unspecified, resulting in \f(CW\*(C`alarm\*(C'\fR\-like behaviour.
.Sp
Note that the interaction between alarms and sleeps is unspecified.
.IP "tv_interval" 4
.IX Item "tv_interval"
tv_interval ( \f(CW$ref_to_gettimeofday\fR [, \f(CW$ref_to_later_gettimeofday\fR] )
.Sp
Returns the floating seconds between the two times, which should have
been returned by \f(CW\*(C`gettimeofday()\*(C'\fR. If the second argument is omitted,
then the current time is used.
.IP "time ()" 4
.IX Item "time ()"
Returns a floating seconds since the epoch. This function can be
imported, resulting in a nice drop-in replacement for the \f(CW\*(C`time\*(C'\fR
provided with core Perl; see the \*(L"\s-1EXAMPLES\s0\*(R" below.
.Sp
\&\fB\s-1NOTE\s0 1\fR: This higher resolution timer can return values either less
or more than the core \f(CW\*(C`time()\*(C'\fR, depending on whether your platform
rounds the higher resolution timer values up, down, or to the nearest second
to get the core \f(CW\*(C`time()\*(C'\fR, but naturally the difference should be never
more than half a second.  See also \*(L"clock_getres\*(R", if available
in your system.
.Sp
\&\fB\s-1NOTE\s0 2\fR: Since Sunday, September 9th, 2001 at 01:46:40 \s-1AM\s0 \s-1GMT\s0, when
the \f(CW\*(C`time()\*(C'\fR seconds since epoch rolled over to 1_000_000_000, the
default floating point format of Perl and the seconds since epoch have
conspired to produce an apparent bug: if you print the value of
\&\f(CW\*(C`Time::HiRes::time()\*(C'\fR you seem to be getting only five decimals, not
six as promised (microseconds).  Not to worry, the microseconds are
there (assuming your platform supports such granularity in the first
place).  What is going on is that the default floating point format of
Perl only outputs 15 digits.  In this case that means ten digits
before the decimal separator and five after.  To see the microseconds
you can use either \f(CW\*(C`printf\*(C'\fR/\f(CW\*(C`sprintf\*(C'\fR with \f(CW"%.6f"\fR, or the
\&\f(CW\*(C`gettimeofday()\*(C'\fR function in list context, which will give you the
seconds and microseconds as two separate values.
.ie n .IP "sleep ( $floating_seconds )" 4
.el .IP "sleep ( \f(CW$floating_seconds\fR )" 4
.IX Item "sleep ( $floating_seconds )"
Sleeps for the specified amount of seconds.  Returns the number of
seconds actually slept (a floating point value).  This function can
be imported, resulting in a nice drop-in replacement for the \f(CW\*(C`sleep\*(C'\fR
provided with perl, see the \*(L"\s-1EXAMPLES\s0\*(R" below.
.Sp
Note that the interaction between alarms and sleeps is unspecified.
.ie n .IP "alarm ( $floating_seconds\fR [, \f(CW$interval_floating_seconds ] )" 4
.el .IP "alarm ( \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds\fR ] )" 4
.IX Item "alarm ( $floating_seconds [, $interval_floating_seconds ] )"
The \f(CW\*(C`SIGALRM\*(C'\fR signal is sent after the specified number of seconds.
Implemented using \f(CW\*(C`ualarm()\*(C'\fR.  The \f(CW$interval_floating_seconds\fR argument
is optional and will be zero if unspecified, resulting in \f(CW\*(C`alarm()\*(C'\fR\-like
behaviour.  This function can be imported, resulting in a nice drop-in
replacement for the \f(CW\*(C`alarm\*(C'\fR provided with perl, see the \*(L"\s-1EXAMPLES\s0\*(R" below.
.Sp
\&\fB\s-1NOTE\s0 1\fR: With some combinations of operating systems and Perl
releases \f(CW\*(C`SIGALRM\*(C'\fR restarts \f(CW\*(C`select()\*(C'\fR, instead of interrupting it.
This means that an \f(CW\*(C`alarm()\*(C'\fR followed by a \f(CW\*(C`select()\*(C'\fR may together
take the sum of the times specified for the the \f(CW\*(C`alarm()\*(C'\fR and the
\&\f(CW\*(C`select()\*(C'\fR, not just the time of the \f(CW\*(C`alarm()\*(C'\fR.
.Sp
Note that the interaction between alarms and sleeps is unspecified.
.ie n .IP "setitimer ( $which\fR, \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds ] )" 4
.el .IP "setitimer ( \f(CW$which\fR, \f(CW$floating_seconds\fR [, \f(CW$interval_floating_seconds\fR ] )" 4
.IX Item "setitimer ( $which, $floating_seconds [, $interval_floating_seconds ] )"
Start up an interval timer: after a certain time, a signal arrives,
and more signals may keep arriving at certain intervals.  To disable
an \*(L"itimer\*(R", use \f(CW$floating_seconds\fR of zero.  If the
\&\f(CW$interval_floating_seconds\fR is set to zero (or unspecified), the
timer is disabled \fBafter\fR the next delivered signal.
.Sp
Use of interval timers may interfere with \f(CW\*(C`alarm()\*(C'\fR, \f(CW\*(C`sleep()\*(C'\fR,
and \f(CW\*(C`usleep()\*(C'\fR.  In standard-speak the \*(L"interaction is unspecified\*(R",
which means that \fIanything\fR may happen: it may work, it may not.
.Sp
In scalar context, the remaining time in the timer is returned.
.Sp
In list context, both the remaining time and the interval are returned.
.Sp
There are usually three or four interval timers available: the
\&\f(CW$which\fR can be \f(CW\*(C`ITIMER_REAL\*(C'\fR, \f(CW\*(C`ITIMER_VIRTUAL\*(C'\fR, \f(CW\*(C`ITIMER_PROF\*(C'\fR, or
\&\f(CW\*(C`ITIMER_REALPROF\*(C'\fR.  Note that which ones are available depends: true
\&\s-1UNIX\s0 platforms usually have the first three, but (for example) Win32
and Cygwin have only \f(CW\*(C`ITIMER_REAL\*(C'\fR, and only Solaris seems to have
\&\f(CW\*(C`ITIMER_REALPROF\*(C'\fR (which is used to profile multithreaded programs).
.Sp
\&\f(CW\*(C`ITIMER_REAL\*(C'\fR results in \f(CW\*(C`alarm()\*(C'\fR\-like behaviour.  Time is counted in
\&\fIreal time\fR; that is, wallclock time.  \f(CW\*(C`SIGALRM\*(C'\fR is delivered when
the timer expires.
.Sp
\&\f(CW\*(C`ITIMER_VIRTUAL\*(C'\fR counts time in (process) \fIvirtual time\fR; that is,
only when the process is running.  In multiprocessor/user/CPU systems
this may be more or less than real or wallclock time.  (This time is
also known as the \fIuser time\fR.)  \f(CW\*(C`SIGVTALRM\*(C'\fR is delivered when the
timer expires.
.Sp
\&\f(CW\*(C`ITIMER_PROF\*(C'\fR counts time when either the process virtual time or when
the operating system is running on behalf of the process (such as I/O).
(This time is also known as the \fIsystem time\fR.)  (The sum of user
time and system time is known as the \fI\s-1CPU\s0 time\fR.)  \f(CW\*(C`SIGPROF\*(C'\fR is
delivered when the timer expires.  \f(CW\*(C`SIGPROF\*(C'\fR can interrupt system calls.
.Sp
The semantics of interval timers for multithreaded programs are
system\-specific, and some systems may support additional interval
timers.  See your \f(CW\*(C`setitimer()\*(C'\fR documentation.
.ie n .IP "getitimer ( $which )" 4
.el .IP "getitimer ( \f(CW$which\fR )" 4
.IX Item "getitimer ( $which )"
Return the remaining time in the interval timer specified by \f(CW$which\fR.
.Sp
In scalar context, the remaining time is returned.
.Sp
In list context, both the remaining time and the interval are returned.
The interval is always what you put in using \f(CW\*(C`setitimer()\*(C'\fR.
.ie n .IP "clock_gettime ( $which )" 4
.el .IP "clock_gettime ( \f(CW$which\fR )" 4
.IX Item "clock_gettime ( $which )"
Return as seconds the current value of the \s-1POSIX\s0 high resolution timer
specified by \f(CW$which\fR.  All implementations that support \s-1POSIX\s0 high
resolution timers are supposed to support at least the \f(CW$which\fR value
of \f(CW\*(C`CLOCK_REALTIME\*(C'\fR, which is supposed to return results close to the
results of \f(CW\*(C`gettimeofday\*(C'\fR, or the number of seconds since 00:00:00:00
January 1, 1970 Greenwich Mean Time (\s-1GMT\s0).  Do not assume that
\&\s-1CLOCK_REALTIME\s0 is zero, it might be one, or something else.
Another potentially useful (but not available everywhere) value is
\&\f(CW\*(C`CLOCK_MONOTONIC\*(C'\fR, which guarantees a monotonically increasing time
value (unlike \fItime()\fR, which can be adjusted).  See your system
documentation for other possibly supported values.
.ie n .IP "clock_getres ( $which )" 4
.el .IP "clock_getres ( \f(CW$which\fR )" 4
.IX Item "clock_getres ( $which )"
Return as seconds the resolution of the \s-1POSIX\s0 high resolution timer
specified by \f(CW$which\fR.  All implementations that support \s-1POSIX\s0 high
resolution timers are supposed to support at least the \f(CW$which\fR value
of \f(CW\*(C`CLOCK_REALTIME\*(C'\fR, see \*(L"clock_gettime\*(R".
.ie n .IP "clock_nanosleep ( $which\fR, \f(CW$seconds\fR, \f(CW$flags = 0)" 4
.el .IP "clock_nanosleep ( \f(CW$which\fR, \f(CW$seconds\fR, \f(CW$flags\fR = 0)" 4
.IX Item "clock_nanosleep ( $which, $seconds, $flags = 0)"
Sleeps for the number of seconds (1e9ths of a second) specified.
Returns the number of seconds actually slept.  The \f(CW$which\fR is the
\&\*(L"clock id\*(R", as with \fIclock_gettime()\fR and \fIclock_getres()\fR.  The flags
default to zero but \f(CW\*(C`TIMER_ABSTIME\*(C'\fR can specified (must be exported
explicitly) which means that \f(CW$nanoseconds\fR is not a time interval
(as is the default) but instead an absolute time.  Can sleep for more
than one second.  Can also sleep for zero seconds, which often works
like a \fIthread yield\fR.  See also \f(CW\*(C`Time::HiRes::sleep()\*(C'\fR,
\&\f(CW\*(C`Time::HiRes::usleep()\*(C'\fR, and \f(CW\*(C`Time::HiRes::nanosleep()\*(C'\fR.
.Sp
Do not expect \fIclock_nanosleep()\fR to be exact down to one nanosecond.
Getting even accuracy of one thousand nanoseconds is good.
.IP "\fIclock()\fR" 4
.IX Item "clock()"
Return as seconds the \fIprocess time\fR (user + system time) spent by
the process since the first call to \fIclock()\fR (the definition is \fBnot\fR
\&\*(L"since the start of the process\*(R", though if you are lucky these times
may be quite close to each other, depending on the system).  What this
means is that you probably need to store the result of your first call
to \fIclock()\fR, and subtract that value from the following results of \fIclock()\fR.
.Sp
The time returned also includes the process times of the terminated
child processes for which \fIwait()\fR has been executed.  This value is
somewhat like the second value returned by the \fItimes()\fR of core Perl,
but not necessarily identical.  Note that due to backward
compatibility limitations the returned value may wrap around at about
2147 seconds or at about 36 minutes.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\&  use Time::HiRes qw(usleep ualarm gettimeofday tv_interval);
.Ve
.PP
.Vb 2
\&  $microseconds = 750_000;
\&  usleep($microseconds);
.Ve
.PP
.Vb 2
\&  # signal alarm in 2.5s & every .1s thereafter
\&  ualarm(2_500_000, 100_000);
.Ve
.PP
.Vb 2
\&  # get seconds and microseconds since the epoch
\&  ($s, $usec) = gettimeofday();
.Ve
.PP
.Vb 7
\&  # measure elapsed time 
\&  # (could also do by subtracting 2 gettimeofday return values)
\&  $t0 = [gettimeofday];
\&  # do bunch of stuff here
\&  $t1 = [gettimeofday];
\&  # do more stuff here
\&  $t0_t1 = tv_interval $t0, $t1;
.Ve
.PP
.Vb 2
\&  $elapsed = tv_interval ($t0, [gettimeofday]);
\&  $elapsed = tv_interval ($t0); # equivalent code
.Ve
.PP
.Vb 8
\&  #
\&  # replacements for time, alarm and sleep that know about
\&  # floating seconds
\&  #
\&  use Time::HiRes;
\&  $now_fractions = Time::HiRes::time;
\&  Time::HiRes::sleep (2.5);
\&  Time::HiRes::alarm (10.6666666);
.Ve
.PP
.Vb 4
\&  use Time::HiRes qw ( time alarm sleep );
\&  $now_fractions = time;
\&  sleep (2.5);
\&  alarm (10.6666666);
.Ve
.PP
.Vb 2
\&  # Arm an interval timer to go off first at 10 seconds and
\&  # after that every 2.5 seconds, in process virtual time
.Ve
.PP
.Vb 1
\&  use Time::HiRes qw ( setitimer ITIMER_VIRTUAL time );
.Ve
.PP
.Vb 2
\&  $SIG{VTALRM} = sub { print time, "\en" };
\&  setitimer(ITIMER_VIRTUAL, 10, 2.5);
.Ve
.PP
.Vb 5
\&  use Time::HiRes qw( clock_gettime clock_getres CLOCK_REALTIME );
\&  # Read the POSIX high resolution timer.
\&  my $high = clock_getres(CLOCK_REALTIME);
\&  # But how accurate we can be, really?
\&  my $reso = clock_getres(CLOCK_REALTIME);
.Ve
.PP
.Vb 3
\&  use Time::HiRes qw( clock_nanosleep TIMER_ABSTIME );
\&  clock_nanosleep(CLOCK_REALTIME, 1e6);
\&  clock_nanosleep(CLOCK_REALTIME, 2e9, TIMER_ABSTIME);
.Ve
.PP
.Vb 5
\&  use Time::HiRes qw( clock );
\&  my $clock0 = clock();
\&  ... # Do something.
\&  my $clock1 = clock();
\&  my $clockd = $clock1 - $clock0;
.Ve
.SH "C API"
.IX Header "C API"
In addition to the perl \s-1API\s0 described above, a C \s-1API\s0 is available for
extension writers.  The following C functions are available in the
modglobal hash:
.PP
.Vb 4
\&  name             C prototype
\&  ---------------  ----------------------
\&  Time::NVtime     double (*)()
\&  Time::U2time     void (*)(pTHX_ UV ret[2])
.Ve
.PP
Both functions return equivalent information (like \f(CW\*(C`gettimeofday\*(C'\fR)
but with different representations.  The names \f(CW\*(C`NVtime\*(C'\fR and \f(CW\*(C`U2time\*(C'\fR
were selected mainly because they are operating system independent.
(\f(CW\*(C`gettimeofday\*(C'\fR is Unix\-centric, though some platforms like Win32 and
\&\s-1VMS\s0 have emulations for it.)
.PP
Here is an example of using \f(CW\*(C`NVtime\*(C'\fR from C:
.PP
.Vb 6
\&  double (*myNVtime)(); /* Returns -1 on failure. */
\&  SV **svp = hv_fetch(PL_modglobal, "Time::NVtime", 12, 0);
\&  if (!svp)         croak("Time::HiRes is required");
\&  if (!SvIOK(*svp)) croak("Time::NVtime isn't a function pointer");
\&  myNVtime = INT2PTR(double(*)(), SvIV(*svp));
\&  printf("The current time is: %f\en", (*myNVtime)());
.Ve
.SH "DIAGNOSTICS"
.IX Header "DIAGNOSTICS"
.Sh "negative time not invented yet"
.IX Subsection "negative time not invented yet"
You tried to use a negative time argument.
.Sh "internal error: useconds < 0 (unsigned ... signed ...)"
.IX Subsection "internal error: useconds < 0 (unsigned ... signed ...)"
Something went horribly wrong\*(-- the number of microseconds that cannot
become negative just became negative.  Maybe your compiler is broken?
.SH "CAVEATS"
.IX Header "CAVEATS"
Notice that the core \f(CW\*(C`time()\*(C'\fR maybe rounding rather than truncating.
What this means is that the core \f(CW\*(C`time()\*(C'\fR may be reporting the time
as one second later than \f(CW\*(C`gettimeofday()\*(C'\fR and \f(CW\*(C`Time::HiRes::time()\*(C'\fR.
.PP
Adjusting the system clock (either manually or by services like ntp)
may cause problems, especially for long running programs that assume
a monotonously increasing time (note that all platforms do not adjust
time as gracefully as \s-1UNIX\s0 ntp does).  For example in Win32 (and derived
platforms like Cygwin and MinGW) the \fITime::HiRes::time()\fR may temporarily
drift off from the system clock (and the original \fItime()\fR)  by up to 0.5
seconds. Time::HiRes will notice this eventually and recalibrate.
Note that since Time::HiRes 1.77 the clock_gettime(\s-1CLOCK_MONOTONIC\s0)
might help in this (in case your system supports \s-1CLOCK_MONOTONIC\s0).
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Perl modules BSD::Resource, Time::TAI64.
.PP
Your system documentation for \f(CW\*(C`clock_gettime\*(C'\fR, \f(CW\*(C`clock_settime\*(C'\fR,
\&\f(CW\*(C`gettimeofday\*(C'\fR, \f(CW\*(C`getitimer\*(C'\fR, \f(CW\*(C`setitimer\*(C'\fR, \f(CW\*(C`ualarm\*(C'\fR.
.SH "AUTHORS"
.IX Header "AUTHORS"
D. Wegscheid <wegscd@whirlpool.com>
R. Schertler <roderick@argon.org>
J. Hietaniemi <jhi@iki.fi>
G. Aas <gisle@aas.no>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 1996\-2002 Douglas E. Wegscheid.  All rights reserved.
.PP
Copyright (c) 2002, 2003, 2004, 2005 Jarkko Hietaniemi.  All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
