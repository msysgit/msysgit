.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sort 3pm"
.TH sort 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
sort \- perl pragma to control sort() behaviour
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    use sort 'stable';          # guarantee stability
\&    use sort '_quicksort';      # use a quicksort algorithm
\&    use sort '_mergesort';      # use a mergesort algorithm
\&    use sort 'defaults';        # revert to default behavior
\&    no  sort 'stable';          # stability not important
.Ve
.PP
.Vb 1
\&    use sort '_qsort';          # alias for quicksort
.Ve
.PP
.Vb 1
\&    my $current = sort::current();      # identify prevailing algorithm
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
With the \f(CW\*(C`sort\*(C'\fR pragma you can control the behaviour of the builtin
\&\f(CW\*(C`sort()\*(C'\fR function.
.PP
In Perl versions 5.6 and earlier the quicksort algorithm was used to
implement \f(CW\*(C`sort()\*(C'\fR, but in Perl 5.8 a mergesort algorithm was also made
available, mainly to guarantee worst case O(N log N) behaviour:
the worst case of quicksort is O(N**2).  In Perl 5.8 and later,
quicksort defends against quadratic behaviour by shuffling large
arrays before sorting.
.PP
A stable sort means that for records that compare equal, the original
input ordering is preserved.  Mergesort is stable, quicksort is not.
Stability will matter only if elements that compare equal can be
distinguished in some other way.  That means that simple numerical
and lexical sorts do not profit from stability, since equal elements
are indistinguishable.  However, with a comparison such as
.PP
.Vb 1
\&   { substr($a, 0, 3) cmp substr($b, 0, 3) }
.Ve
.PP
stability might matter because elements that compare equal on the
first 3 characters may be distinguished based on subsequent characters.
In Perl 5.8 and later, quicksort can be stabilized, but doing so will
add overhead, so it should only be done if it matters.
.PP
The best algorithm depends on many things.  On average, mergesort
does fewer comparisons than quicksort, so it may be better when
complicated comparison routines are used.  Mergesort also takes
advantage of pre-existing order, so it would be favored for using
\&\f(CW\*(C`sort()\*(C'\fR to merge several sorted arrays.  On the other hand, quicksort
is often faster for small arrays, and on arrays of a few distinct
values, repeated many times.  You can force the
choice of algorithm with this pragma, but this feels heavy\-handed,
so the subpragmas beginning with a \f(CW\*(C`_\*(C'\fR may not persist beyond Perl 5.8.
The default algorithm is mergesort, which will be stable even if
you do not explicitly demand it.
But the stability of the default sort is a side-effect that could
change in later versions.  If stability is important, be sure to
say so with a
.PP
.Vb 1
\&  use sort 'stable';
.Ve
.PP
The \f(CW\*(C`no sort\*(C'\fR pragma doesn't
\&\fIforbid\fR what follows, it just leaves the choice open.  Thus, after
.PP
.Vb 1
\&  no sort qw(_mergesort stable);
.Ve
.PP
a mergesort, which happens to be stable, will be employed anyway.
Note that
.PP
.Vb 2
\&  no sort "_quicksort";
\&  no sort "_mergesort";
.Ve
.PP
have exactly the same effect, leaving the choice of sort algorithm open.
.SH "CAVEATS"
.IX Header "CAVEATS"
This pragma is not lexically scoped: its effect is global to the program
it appears in.  That means the following will probably not do what you
expect, because \fIboth\fR pragmas take effect at compile time, before
\&\fIeither\fR \f(CW\*(C`sort()\*(C'\fR happens.
.PP
.Vb 11
\&  { use sort "_quicksort";
\&    print sort::current . "\en";
\&    @a = sort @b;
\&  }
\&  { use sort "stable";
\&    print sort::current . "\en";
\&    @c = sort @d;
\&  }
\&  # prints:
\&  # quicksort stable
\&  # quicksort stable
.Ve
.PP
You can achieve the effect you probably wanted by using \f(CW\*(C`eval()\*(C'\fR
to defer the pragmas until run time.  Use the quoted argument
form of \f(CW\*(C`eval()\*(C'\fR, \fInot\fR the \s-1BLOCK\s0 form, as in
.PP
.Vb 1
\&  eval { use sort "_quicksort" }; # WRONG
.Ve
.PP
or the effect will still be at compile time.
Reset to default options before selecting other subpragmas
(in case somebody carelessly left them on) and after sorting,
as a courtesy to others.
.PP
.Vb 14
\&  { eval 'use sort qw(defaults _quicksort)'; # force quicksort
\&    eval 'no sort "stable"';      # stability not wanted
\&    print sort::current . "\en";
\&    @a = sort @b;
\&    eval 'use sort "defaults"';   # clean up, for others
\&  }
\&  { eval 'use sort qw(defaults stable)';     # force stability
\&    print sort::current . "\en";
\&    @c = sort @d;
\&    eval 'use sort "defaults"';   # clean up, for others
\&  }
\&  # prints:
\&  # quicksort
\&  # stable
.Ve
.PP
Scoping for this pragma may change in future versions.
