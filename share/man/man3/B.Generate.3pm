.\" Automatically generated by Pod::Man 2.12 (Pod::Simple 3.05)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "B::Generate 3"
.TH B::Generate 3 "2011-04-26" "perl v5.8.8" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
B::Generate \- Create your own op trees.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&    use B::Generate;
\&    # Do nothing, slowly.
\&      CHECK {
\&        my $null = new B::OP("null",0);
\&        my $enter = new B::OP("enter",0);
\&        my $cop = new B::COP(0, "hiya", 0);
\&        my $leave = new B::LISTOP("leave", 0, $enter, $null);
\&        $leave\->children(3);
\&        $enter\->sibling($cop);
\&        $enter\->next($cop);
\&        $cop\->sibling($null);
\&        $null\->next($leave);
\&        $cop\->next($leave);
\&
\&        # Tell Perl where to find our tree.
\&        B::main_root($leave);
\&        B::main_start($enter);
\&      }
.Ve
.SH "WARNING"
.IX Header "WARNING"
This module will create segmentation faults if you don't know how to
use it properly. Further warning: sometimes \fBI\fR don't know how to use
it properly.
.PP
There \fBare\fR lots of other methods and utility functions, but they are
not documented here. This is deliberate, rather than just through
laziness. You are expected to have read the Perl and \s-1XS\s0 sources to this
module before attempting to do anything with it.
.PP
Patches welcome.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Malcolm Beattie's \f(CW\*(C`B\*(C'\fR module allows you to examine the Perl op tree at
runtime, in Perl space; it's the basis of the Perl compiler. But what it
doesn't let you do is manipulate that op tree: it won't let you create
new ops, or modify old ones. Now you can.
.PP
Well, if you're intimately familiar with Perl's internals, you can.
.PP
\&\f(CW\*(C`B::Generate\*(C'\fR turns \f(CW\*(C`B\*(C'\fR's accessor methods into get-set methods.
Hence, instead of merely saying
.PP
.Vb 1
\&    $op2 = $op\->next;
.Ve
.PP
you can now say
.PP
.Vb 1
\&    $op\->next($op2);
.Ve
.PP
to set the next op in the chain. It also adds constructor methods to
create new ops. This is where it gets really hairy.
.PP
.Vb 6
\&    new B::OP     ( type, flags )
\&    new B::UNOP   ( type, flags, first )
\&    new B::BINOP  ( type, flags, first, last )
\&    new B::LOGOP  ( type, flags, first, other )
\&    new B::LISTOP ( type, flags, first, last )
\&    new B::COP    ( flags, name, first )
.Ve
.PP
In all of the above constructors, \f(CW\*(C`type\*(C'\fR is either a numeric value
representing the op type (\f(CW62\fR is the addition operator, for instance)
or the name of the op. (\f(CW"add"\fR)
.PP
(Incidentally, if you know about custom ops and have registed them
properly with the interpreter, you can create custom ops by name: 
\&\f(CW\*(C`new B::OP("mycustomop",0)\*(C'\fR, or whatever.)
.PP
\&\f(CW\*(C`first\*(C'\fR, \f(CW\*(C`last\*(C'\fR and \f(CW\*(C`other\*(C'\fR are ops to be attached to the current op;
these should be \f(CW\*(C`B::OP\*(C'\fR objects. If you haven't created the ops yet,
don't worry; give a false value, and fill them in later:
.PP
.Vb 3
\&    $x = new B::UNOP("negate", 0, undef);
\&    # ... create some more ops ...
\&    $x\->first($y);
.Ve
.PP
In addition, one may create a new \f(CW\*(C`nextstate\*(C'\fR operator with
.PP
.Vb 1
\&    newstate B::op ( flags, label, op)
.Ve
.PP
in the same manner as \f(CW\*(C`B::COP::new\*(C'\fR \- this will also, however, add the
\&\f(CW\*(C`lineseq\*(C'\fR op.
.PP
Finally, you can set the main root and the starting op by passing ops
to the \f(CW\*(C`B::main_root\*(C'\fR and \f(CW\*(C`B::main_start\*(C'\fR functions.
.PP
This module can obviously be used for all sorts of fun purposes. The
best one will be in conjuction with source filters; have your source
filter parse an input file in a foreign language, create an op tree for
it and get Perl to execute it. Then email me and tell me how you did it.
And why.
.Sh "\s-1OTHER\s0 \s-1METHODS\s0"
.IX Subsection "OTHER METHODS"
.ie n .IP "$b_sv\->sv" 3
.el .IP "\f(CW$b_sv\fR\->sv" 3
.IX Item "$b_sv->sv"
Returns a real \s-1SV\s0 instead of a \f(CW\*(C`B::SV\*(C'\fR. For instance:
.Sp
.Vb 4
\&    $b_sv = $svop\->sv;
\&    if ($b_sv\->sv == 3) {
\&        print "SVOP's SV has an IV of 3\en"
\&    }
.Ve
.Sp
You can't use this to set the \s-1SV\s0. That would be scary.
.ie n .IP "$op\->dump" 3
.el .IP "\f(CW$op\fR\->dump" 3
.IX Item "$op->dump"
Runs \f(CW\*(C`Perl_op_dump\*(C'\fR on an op; this is roughly equivalent to
\&\f(CW\*(C`B::Debug\*(C'\fR, but not quite.
.ie n .IP "$b_sv\->dump" 3
.el .IP "\f(CW$b_sv\fR\->dump" 3
.IX Item "$b_sv->dump"
Runs \f(CW\*(C`Perl_sv_dump\*(C'\fR on an \s-1SV\s0; this is exactly equivalent to
\&\f(CW\*(C`Devel::Peek::dump($b_sv\->sv)\*(C'\fR
.ie n .IP "$b_op\->linklist" 3
.el .IP "\f(CW$b_op\fR\->linklist" 3
.IX Item "$b_op->linklist"
Sets the \f(CW\*(C`op_next\*(C'\fR pointers in the tree in correct execution order, 
overwriting the old \f(CW\*(C`next\*(C'\fR pointers. You \fBneed\fR to do this once you've
created an op tree for execution, unless you've carefully threaded it
together yourself.
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None.
.SH "AUTHOR"
.IX Header "AUTHOR"
Simon Cozens, \f(CW\*(C`simon@cpan.org\*(C'\fR
(Who else?)
.SH "MAINTAINERS"
.IX Header "MAINTAINERS"
This is just a list of people who have submitted patches to the
module. To find someone to actually maintain this, please try
contacting perl5\-porters.
.PP
Josh ben Jore, Michael Schwern, Jim Cromie, Scott Walters.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
B, \fIperlguts\fR, \fIop.c\fR
