.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Math::BigRat 3pm"
.TH Math::BigRat 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Math::BigRat \- Arbitrary big rational numbers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        use Math::BigRat;
.Ve
.PP
.Vb 1
\&        my $x = Math::BigRat->new('3/7'); $x += '5/9';
.Ve
.PP
.Vb 2
\&        print $x->bstr(),"\en";
\&        print $x ** 2,"\en";
.Ve
.PP
.Vb 2
\&        my $y = Math::BigRat->new('inf');
\&        print "$y ", ($y->is_inf ? 'is' : 'is not') , " infinity\en";
.Ve
.PP
.Vb 1
\&        my $z = Math::BigRat->new(144); $z->bsqrt();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Math::BigRat complements Math::BigInt and Math::BigFloat by providing support
for arbitrary big rational numbers.
.Sh "\s-1MATH\s0 \s-1LIBRARY\s0"
.IX Subsection "MATH LIBRARY"
Math with the numbers is done (by default) by a module called
Math::BigInt::Calc. This is equivalent to saying:
.PP
.Vb 1
\&        use Math::BigRat lib => 'Calc';
.Ve
.PP
You can change this by using:
.PP
.Vb 1
\&        use Math::BigRat lib => 'BitVect';
.Ve
.PP
The following would first try to find Math::BigInt::Foo, then
Math::BigInt::Bar, and when this also fails, revert to Math::BigInt::Calc:
.PP
.Vb 1
\&        use Math::BigRat lib => 'Foo,Math::BigInt::Bar';
.Ve
.PP
Calc.pm uses as internal format an array of elements of some decimal base
(usually 1e7, but this might be different for some systems) with the least
significant digit first, while BitVect.pm uses a bit vector of base 2, most
significant bit first. Other modules might use even different means of
representing the numbers. See the respective module documentation for further
details.
.PP
Currently the following replacement libraries exist, search for them at \s-1CPAN:\s0
.PP
.Vb 4
\&        Math::BigInt::BitVect
\&        Math::BigInt::GMP
\&        Math::BigInt::Pari
\&        Math::BigInt::FastCalc
.Ve
.SH "METHODS"
.IX Header "METHODS"
Any methods not listed here are dervied from Math::BigFloat (or
Math::BigInt), so make sure you check these two modules for further
information.
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&        $x = Math::BigRat->new('1/3');
.Ve
.PP
Create a new Math::BigRat object. Input can come in various forms:
.PP
.Vb 9
\&        $x = Math::BigRat->new(123);                            # scalars
\&        $x = Math::BigRat->new('inf');                          # infinity
\&        $x = Math::BigRat->new('123.3');                        # float
\&        $x = Math::BigRat->new('1/3');                          # simple string
\&        $x = Math::BigRat->new('1 / 3');                        # spaced
\&        $x = Math::BigRat->new('1 / 0.1');                      # w/ floats
\&        $x = Math::BigRat->new(Math::BigInt->new(3));           # BigInt
\&        $x = Math::BigRat->new(Math::BigFloat->new('3.1'));     # BigFloat
\&        $x = Math::BigRat->new(Math::BigInt::Lite->new('2'));   # BigLite
.Ve
.PP
.Vb 5
\&        # You can also give D and N as different objects:
\&        $x = Math::BigRat->new(
\&                Math::BigInt->new(-123),
\&                Math::BigInt->new(7),
\&                );                      # => -123/7
.Ve
.Sh "\fInumerator()\fP"
.IX Subsection "numerator()"
.Vb 1
\&        $n = $x->numerator();
.Ve
.PP
Returns a copy of the numerator (the part above the line) as signed BigInt.
.Sh "\fIdenominator()\fP"
.IX Subsection "denominator()"
.Vb 1
\&        $d = $x->denominator();
.Ve
.PP
Returns a copy of the denominator (the part under the line) as positive BigInt.
.Sh "\fIparts()\fP"
.IX Subsection "parts()"
.Vb 1
\&        ($n,$d) = $x->parts();
.Ve
.PP
Return a list consisting of (signed) numerator and (unsigned) denominator as
BigInts.
.Sh "\fIas_int()\fP"
.IX Subsection "as_int()"
.Vb 2
\&        $x = Math::BigRat->new('13/7');
\&        print $x->as_int(),"\en";                # '1'
.Ve
.PP
Returns a copy of the object as BigInt, truncated to an integer.
.PP
\&\f(CW\*(C`as_number()\*(C'\fR is an alias for \f(CW\*(C`as_int()\*(C'\fR.
.Sh "\fIas_hex()\fP"
.IX Subsection "as_hex()"
.Vb 2
\&        $x = Math::BigRat->new('13');
\&        print $x->as_hex(),"\en";                # '0xd'
.Ve
.PP
Returns the BigRat as hexadecimal string. Works only for integers. 
.Sh "\fIas_bin()\fP"
.IX Subsection "as_bin()"
.Vb 2
\&        $x = Math::BigRat->new('13');
\&        print $x->as_bin(),"\en";                # '0x1101'
.Ve
.PP
Returns the BigRat as binary string. Works only for integers. 
.Sh "\fIbfac()\fP"
.IX Subsection "bfac()"
.Vb 1
\&        $x->bfac();
.Ve
.PP
Calculates the factorial of \f(CW$x\fR. For instance:
.PP
.Vb 2
\&        print Math::BigRat->new('3/1')->bfac(),"\en";    # 1*2*3
\&        print Math::BigRat->new('5/1')->bfac(),"\en";    # 1*2*3*4*5
.Ve
.PP
Works currently only for integers.
.Sh "\fIblog()\fP"
.IX Subsection "blog()"
Is not yet implemented.
.Sh "\fIbround()\fP/\fIround()\fP/\fIbfround()\fP"
.IX Subsection "bround()/round()/bfround()"
Are not yet implemented.
.Sh "\fIbmod()\fP"
.IX Subsection "bmod()"
.Vb 4
\&        use Math::BigRat;
\&        my $x = Math::BigRat->new('7/4');
\&        my $y = Math::BigRat->new('4/3');
\&        print $x->bmod($y);
.Ve
.PP
Set \f(CW$x\fR to the remainder of the division of \f(CW$x\fR by \f(CW$y\fR.
.Sh "\fIis_one()\fP"
.IX Subsection "is_one()"
.Vb 1
\&        print "$x is 1\en" if $x->is_one();
.Ve
.PP
Return true if \f(CW$x\fR is exactly one, otherwise false.
.Sh "\fIis_zero()\fP"
.IX Subsection "is_zero()"
.Vb 1
\&        print "$x is 0\en" if $x->is_zero();
.Ve
.PP
Return true if \f(CW$x\fR is exactly zero, otherwise false.
.Sh "\fIis_pos()\fP"
.IX Subsection "is_pos()"
.Vb 1
\&        print "$x is >= 0\en" if $x->is_positive();
.Ve
.PP
Return true if \f(CW$x\fR is positive (greater than or equal to zero), otherwise
false. Please note that '+inf' is also positive, while 'NaN' and '\-inf' aren't.
.PP
\&\f(CW\*(C`is_positive()\*(C'\fR is an alias for \f(CW\*(C`is_pos()\*(C'\fR.
.Sh "\fIis_neg()\fP"
.IX Subsection "is_neg()"
.Vb 1
\&        print "$x is < 0\en" if $x->is_negative();
.Ve
.PP
Return true if \f(CW$x\fR is negative (smaller than zero), otherwise false. Please
note that '\-inf' is also negative, while 'NaN' and '+inf' aren't.
.PP
\&\f(CW\*(C`is_negative()\*(C'\fR is an alias for \f(CW\*(C`is_neg()\*(C'\fR.
.Sh "\fIis_int()\fP"
.IX Subsection "is_int()"
.Vb 1
\&        print "$x is an integer\en" if $x->is_int();
.Ve
.PP
Return true if \f(CW$x\fR has a denominator of 1 (e.g. no fraction parts), otherwise
false. Please note that '\-inf', 'inf' and 'NaN' aren't integer.
.Sh "\fIis_odd()\fP"
.IX Subsection "is_odd()"
.Vb 1
\&        print "$x is odd\en" if $x->is_odd();
.Ve
.PP
Return true if \f(CW$x\fR is odd, otherwise false.
.Sh "\fIis_even()\fP"
.IX Subsection "is_even()"
.Vb 1
\&        print "$x is even\en" if $x->is_even();
.Ve
.PP
Return true if \f(CW$x\fR is even, otherwise false.
.Sh "\fIbceil()\fP"
.IX Subsection "bceil()"
.Vb 1
\&        $x->bceil();
.Ve
.PP
Set \f(CW$x\fR to the next bigger integer value (e.g. truncate the number to integer
and then increment it by one).
.Sh "\fIbfloor()\fP"
.IX Subsection "bfloor()"
.Vb 1
\&        $x->bfloor();
.Ve
.PP
Truncate \f(CW$x\fR to an integer value.
.Sh "\fIbsqrt()\fP"
.IX Subsection "bsqrt()"
.Vb 1
\&        $x->bsqrt();
.Ve
.PP
Calculate the square root of \f(CW$x\fR.
.Sh "config"
.IX Subsection "config"
.Vb 1
\&        use Data::Dumper;
.Ve
.PP
.Vb 2
\&        print Dumper ( Math::BigRat->config() );
\&        print Math::BigRat->config()->{lib},"\en";
.Ve
.PP
Returns a hash containing the configuration, e.g. the version number, lib
loaded etc. The following hash keys are currently filled in with the
appropriate information.
.PP
.Vb 27
\&        key             RO/RW   Description
\&                                Example
\&        ============================================================
\&        lib             RO      Name of the Math library
\&                                Math::BigInt::Calc
\&        lib_version     RO      Version of 'lib'
\&                                0.30
\&        class           RO      The class of config you just called
\&                                Math::BigRat
\&        version         RO      version number of the class you used
\&                                0.10
\&        upgrade         RW      To which class numbers are upgraded
\&                                undef
\&        downgrade       RW      To which class numbers are downgraded
\&                                undef
\&        precision       RW      Global precision
\&                                undef
\&        accuracy        RW      Global accuracy
\&                                undef
\&        round_mode      RW      Global round mode
\&                                even
\&        div_scale       RW      Fallback acccuracy for div
\&                                40
\&        trap_nan        RW      Trap creation of NaN (undef = no)
\&                                undef
\&        trap_inf        RW      Trap creation of +inf/-inf (undef = no)
\&                                undef
.Ve
.PP
By passing a reference to a hash you may set the configuration values. This
works only for values that a marked with a \f(CW\*(C`RW\*(C'\fR above, anything else is
read\-only.
.SH "BUGS"
.IX Header "BUGS"
Some things are not yet implemented, or only implemented half\-way:
.IP "inf handling (partial)" 2
.IX Item "inf handling (partial)"
.PD 0
.IP "NaN handling (partial)" 2
.IX Item "NaN handling (partial)"
.IP "rounding (not implemented except for bceil/bfloor)" 2
.IX Item "rounding (not implemented except for bceil/bfloor)"
.ie n .IP "$x ** $y\fR where \f(CW$y is not an integer" 2
.el .IP "$x ** \f(CW$y\fR where \f(CW$y\fR is not an integer" 2
.IX Item "$x ** $y where $y is not an integer"
.IP "\fIbmod()\fR, \fIblog()\fR, \fIbmodinv()\fR and \fIbmodpow()\fR (partial)" 2
.IX Item "bmod(), blog(), bmodinv() and bmodpow() (partial)"
.PD
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you may redistribute it and/or modify it under
the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Math::BigFloat and Math::Big as well as Math::BigInt::BitVect,
Math::BigInt::Pari and  Math::BigInt::GMP.
.PP
See <http://search.cpan.org/search?dist=bignum> for a way to use
Math::BigRat.
.PP
The package at <http://search.cpan.org/search?dist=Math%3A%3ABigRat>
may contain more documentation and examples as well as testcases.
.SH "AUTHORS"
.IX Header "AUTHORS"
(C) by Tels <http://bloodgate.com/> 2001 \- 2005.
