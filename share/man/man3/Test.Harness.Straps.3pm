.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Test::Harness::Straps 3pm"
.TH Test::Harness::Straps 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Test::Harness::Straps \- detailed analysis of test results
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Test::Harness::Straps;
.Ve
.PP
.Vb 1
\&  my $strap = Test::Harness::Straps->new;
.Ve
.PP
.Vb 4
\&  # Various ways to interpret a test
\&  my %results = $strap->analyze($name, \e@test_output);
\&  my %results = $strap->analyze_fh($name, $test_filehandle);
\&  my %results = $strap->analyze_file($test_file);
.Ve
.PP
.Vb 2
\&  # UNIMPLEMENTED
\&  my %total = $strap->total_results;
.Ve
.PP
.Vb 3
\&  # Altering the behavior of the strap  UNIMPLEMENTED
\&  my $verbose_output = $strap->dump_verbose();
\&  $strap->dump_verbose_fh($output_filehandle);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\s-1THIS\s0 \s-1IS\s0 \s-1ALPHA\s0 \s-1SOFTWARE\s0\fR in that the interface is subject to change
in incompatible ways.  It is otherwise stable.
.PP
Test::Harness is limited to printing out its results.  This makes
analysis of the test results difficult for anything but a human.  To
make it easier for programs to work with test results, we provide
Test::Harness::Straps.  Instead of printing the results, straps
provide them as raw data.  You can also configure how the tests are to
be run.
.PP
The interface is currently incomplete.  \fIPlease\fR contact the author
if you'd like a feature added or something change or just have
comments.
.SH "CONSTRUCTION"
.IX Header "CONSTRUCTION"
.Sh "\fInew()\fP"
.IX Subsection "new()"
.Vb 1
\&  my $strap = Test::Harness::Straps->new;
.Ve
.PP
Initialize a new strap.
.Sh "$strap\->_init"
.IX Subsection "$strap->_init"
.Vb 1
\&  $strap->_init;
.Ve
.PP
Initialize the internal state of a strap to make it ready for parsing.
.SH "ANALYSIS"
.IX Header "ANALYSIS"
.ie n .Sh "$strap\->analyze( $name, \e@output_lines )"
.el .Sh "$strap\->analyze( \f(CW$name\fP, \e@output_lines )"
.IX Subsection "$strap->analyze( $name, @output_lines )"
.Vb 1
\&    my %results = $strap->analyze($name, \e@test_output);
.Ve
.PP
Analyzes the output of a single test, assigning it the given \f(CW$name\fR
for use in the total report.  Returns the \f(CW%results\fR of the test.
See Results.
.PP
\&\f(CW@test_output\fR should be the raw output from the test, including
newlines.
.ie n .Sh "$strap\->analyze_fh( $name\fP, \f(CW$test_filehandle )"
.el .Sh "$strap\->analyze_fh( \f(CW$name\fP, \f(CW$test_filehandle\fP )"
.IX Subsection "$strap->analyze_fh( $name, $test_filehandle )"
.Vb 1
\&    my %results = $strap->analyze_fh($name, $test_filehandle);
.Ve
.PP
Like \f(CW\*(C`analyze\*(C'\fR, but it reads from the given filehandle.
.ie n .Sh "$strap\->analyze_file( $test_file )"
.el .Sh "$strap\->analyze_file( \f(CW$test_file\fP )"
.IX Subsection "$strap->analyze_file( $test_file )"
.Vb 1
\&    my %results = $strap->analyze_file($test_file);
.Ve
.PP
Like \f(CW\*(C`analyze\*(C'\fR, but it runs the given \f(CW$test_file\fR and parses its
results.  It will also use that name for the total report.
.ie n .Sh "$strap\->_command_line( $file )"
.el .Sh "$strap\->_command_line( \f(CW$file\fP )"
.IX Subsection "$strap->_command_line( $file )"
Returns the full command line that will be run to test \fI$file\fR.
.Sh "$strap\->\fI_command()\fP"
.IX Subsection "$strap->_command()"
Returns the command that runs the test.  Combine this with \f(CW\*(C`_switches()\*(C'\fR
to build a command line.
.PP
Typically this is \f(CW$^X\fR, but you can set \f(CW$ENV{HARNESS_PERL}\fR
to use a different Perl than what you're running the harness under.
This might be to run a threaded Perl, for example.
.PP
You can also overload this method if you've built your own strap subclass,
such as a \s-1PHP\s0 interpreter for a PHP-based strap.
.ie n .Sh "$strap\->_switches( $file )"
.el .Sh "$strap\->_switches( \f(CW$file\fP )"
.IX Subsection "$strap->_switches( $file )"
Formats and returns the switches necessary to run the test.
.ie n .Sh "$strap\->_cleaned_switches( @switches_from_user )"
.el .Sh "$strap\->_cleaned_switches( \f(CW@switches_from_user\fP )"
.IX Subsection "$strap->_cleaned_switches( @switches_from_user )"
Returns only defined, non\-blank, trimmed switches from the parms passed.
.Sh "$strap\->_INC2PERL5LIB"
.IX Subsection "$strap->_INC2PERL5LIB"
.Vb 1
\&  local $ENV{PERL5LIB} = $self->_INC2PERL5LIB;
.Ve
.PP
Takes the current value of \f(CW@INC\fR and turns it into something suitable
for putting onto \f(CW\*(C`PERL5LIB\*(C'\fR.
.Sh "$strap\->\fI_filtered_INC()\fP"
.IX Subsection "$strap->_filtered_INC()"
.Vb 1
\&  my @filtered_inc = $self->_filtered_INC;
.Ve
.PP
Shortens \f(CW@INC\fR by removing redundant and unnecessary entries.
Necessary for OSes with limited command line lengths, like \s-1VMS\s0.
.Sh "$strap\->\fI_restore_PERL5LIB()\fP"
.IX Subsection "$strap->_restore_PERL5LIB()"
.Vb 1
\&  $self->_restore_PERL5LIB;
.Ve
.PP
This restores the original value of the \f(CW\*(C`PERL5LIB\*(C'\fR environment variable.
Necessary on \s-1VMS\s0, otherwise a no\-op.
.SH "Parsing"
.IX Header "Parsing"
Methods for identifying what sort of line you're looking at.
.ie n .Sh """_is_diagnostic"""
.el .Sh "\f(CW_is_diagnostic\fP"
.IX Subsection "_is_diagnostic"
.Vb 1
\&    my $is_diagnostic = $strap->_is_diagnostic($line, \e$comment);
.Ve
.PP
Checks if the given line is a comment.  If so, it will place it into
\&\f(CW$comment\fR (sans #).
.ie n .Sh """_is_header"""
.el .Sh "\f(CW_is_header\fP"
.IX Subsection "_is_header"
.Vb 1
\&  my $is_header = $strap->_is_header($line);
.Ve
.PP
Checks if the given line is a header (1..M) line.  If so, it places how
many tests there will be in \f(CW\*(C`$strap\->{max}\*(C'\fR, a list of which tests
are todo in \f(CW\*(C`$strap\->{todo}\*(C'\fR and if the whole test was skipped
\&\f(CW\*(C`$strap\->{skip_all}\*(C'\fR contains the reason.
.ie n .Sh """_is_bail_out"""
.el .Sh "\f(CW_is_bail_out\fP"
.IX Subsection "_is_bail_out"
.Vb 1
\&  my $is_bail_out = $strap->_is_bail_out($line, \e$reason);
.Ve
.PP
Checks if the line is a \*(L"Bail out!\*(R".  Places the reason for bailing
(if any) in \f(CW$reason\fR.
.ie n .Sh """_reset_file_state"""
.el .Sh "\f(CW_reset_file_state\fP"
.IX Subsection "_reset_file_state"
.Vb 1
\&  $strap->_reset_file_state;
.Ve
.PP
Resets things like \f(CW\*(C`$strap\->{max}\*(C'\fR , \f(CW\*(C`$strap\->{skip_all}\*(C'\fR,
etc. so it's ready to parse the next file.
.SH "Results"
.IX Header "Results"
The \f(CW%results\fR returned from \f(CW\*(C`analyze()\*(C'\fR contain the following
information:
.PP
.Vb 2
\&  passing           true if the whole test is considered a pass 
\&                    (or skipped), false if its a failure
.Ve
.PP
.Vb 2
\&  exit              the exit code of the test run, if from a file
\&  wait              the wait code of the test run, if from a file
.Ve
.PP
.Vb 4
\&  max               total tests which should have been run
\&  seen              total tests actually seen
\&  skip_all          if the whole test was skipped, this will 
\&                      contain the reason.
.Ve
.PP
.Vb 2
\&  ok                number of tests which passed 
\&                      (including todo and skips)
.Ve
.PP
.Vb 3
\&  todo              number of todo tests seen
\&  bonus             number of todo tests which 
\&                      unexpectedly passed
.Ve
.PP
.Vb 1
\&  skip              number of tests skipped
.Ve
.PP
So a successful test should have max == seen == ok.
.PP
There is one final item, the details.
.PP
.Vb 2
\&  details           an array ref reporting the result of 
\&                    each test looks like this:
.Ve
.PP
.Vb 8
\&    $results{details}[$test_num - 1] = 
\&            { ok          => is the test considered ok?
\&              actual_ok   => did it literally say 'ok'?
\&              name        => name of the test (if any)
\&              diagnostics => test diagnostics (if any)
\&              type        => 'skip' or 'todo' (if any)
\&              reason      => reason for the above (if any)
\&            };
.Ve
.PP
Element 0 of the details is test #1.  I tried it with element 1 being
#1 and 0 being empty, this is less awkward.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See \fIexamples/mini_harness.plx\fR for an example of use.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern \f(CW\*(C`<schwern@pobox.com>\*(C'\fR, currently maintained by
Andy Lester \f(CW\*(C`<andy@petdance.com>\*(C'\fR.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Test::Harness
