.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Locale::Script 3pm"
.TH Locale::Script 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Locale::Script \- ISO codes for script identification (ISO 15924)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use Locale::Script;
\&    use Locale::Constants;
.Ve
.PP
.Vb 6
\&    $script  = code2script('ph');                       # 'Phoenician'
\&    $code    = script2code('Tibetan');                  # 'bo'
\&    $code3   = script2code('Tibetan',
\&                           LOCALE_CODE_ALPHA_3);        # 'bod'
\&    $codeN   = script2code('Tibetan',
\&                           LOCALE_CODE_ALPHA_NUMERIC);  # 330
.Ve
.PP
.Vb 2
\&    @codes   = all_script_codes();
\&    @scripts = all_script_names();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`Locale::Script\*(C'\fR module provides access to the \s-1ISO\s0
codes for identifying scripts, as defined in \s-1ISO\s0 15924.
For example, Egyptian hieroglyphs are denoted by the two-letter
code 'eg', the three-letter code 'egy', and the numeric code 050.
.PP
You can either access the codes via the conversion routines
(described below), or with the two functions which return lists
of all script codes or all script names.
.PP
There are three different code sets you can use for identifying
scripts:
.IP "\fBalpha\-2\fR" 4
.IX Item "alpha-2"
Two letter codes, such as 'bo' for Tibetan.
This code set is identified with the symbol \f(CW\*(C`LOCALE_CODE_ALPHA_2\*(C'\fR.
.IP "\fBalpha\-3\fR" 4
.IX Item "alpha-3"
Three letter codes, such as 'ell' for Greek.
This code set is identified with the symbol \f(CW\*(C`LOCALE_CODE_ALPHA_3\*(C'\fR.
.IP "\fBnumeric\fR" 4
.IX Item "numeric"
Numeric codes, such as 410 for Hiragana.
This code set is identified with the symbol \f(CW\*(C`LOCALE_CODE_NUMERIC\*(C'\fR.
.PP
All of the routines take an optional additional argument
which specifies the code set to use.
If not specified, it defaults to the two-letter codes.
This is partly for backwards compatibility (previous versions
of Locale modules only supported the alpha\-2 codes), and
partly because they are the most widely used codes.
.PP
The alpha\-2 and alpha\-3 codes are not case\-dependent,
so you can use '\s-1BO\s0', 'Bo', 'bO' or 'bo' for Tibetan.
When a code is returned by one of the functions in
this module, it will always be lower\-case.
.Sh "\s-1SPECIAL\s0 \s-1CODES\s0"
.IX Subsection "SPECIAL CODES"
The standard defines various special codes.
.IP "\(bu" 4
The standard reserves codes in the ranges \fBqa\fR \- \fBqt\fR,
\&\fBqaa\fR \- \fBqat\fR, and \fB900\fR \- \fB919\fR, for private use.
.IP "\(bu" 4
\&\fBzx\fR, \fBzxx\fR, and \fB997\fR, are the codes for unwritten languages.
.IP "\(bu" 4
\&\fBzy\fR, \fBzyy\fR, and \fB998\fR, are the codes for an undetermined script.
.IP "\(bu" 4
\&\fBzz\fR, \fBzzz\fR, and \fB999\fR, are the codes for an uncoded script.
.PP
The private codes are not recognised by Locale::Script,
but the others are.
.SH "CONVERSION ROUTINES"
.IX Header "CONVERSION ROUTINES"
There are three conversion routines: \f(CW\*(C`code2script()\*(C'\fR, \f(CW\*(C`script2code()\*(C'\fR,
and \f(CW\*(C`script_code2code()\*(C'\fR.
.IP "code2script( \s-1CODE\s0, [ \s-1CODESET\s0 ] )" 4
.IX Item "code2script( CODE, [ CODESET ] )"
This function takes a script code and returns a string
which contains the name of the script identified.
If the code is not a valid script code, as defined by \s-1ISO\s0 15924,
then \f(CW\*(C`undef\*(C'\fR will be returned:
.Sp
.Vb 1
\&    $script = code2script('cy');   # Cyrillic
.Ve
.IP "script2code( \s-1STRING\s0, [ \s-1CODESET\s0 ] )" 4
.IX Item "script2code( STRING, [ CODESET ] )"
This function takes a script name and returns the corresponding
script code, if such exists.
If the argument could not be identified as a script name,
then \f(CW\*(C`undef\*(C'\fR will be returned:
.Sp
.Vb 2
\&    $code = script2code('Gothic', LOCALE_CODE_ALPHA_3);
\&    # $code will now be 'gth'
.Ve
.Sp
The case of the script name is not important.
See the section \*(L"\s-1KNOWN\s0 \s-1BUGS\s0 \s-1AND\s0 \s-1LIMITATIONS\s0\*(R" below.
.IP "script_code2code( \s-1CODE\s0, \s-1CODESET\s0, \s-1CODESET\s0 )" 4
.IX Item "script_code2code( CODE, CODESET, CODESET )"
This function takes a script code from one code set,
and returns the corresponding code from another code set.
.Sp
.Vb 3
\&    $alpha2 = script_code2code('jwi',
\&                 LOCALE_CODE_ALPHA_3 => LOCALE_CODE_ALPHA_2);
\&    # $alpha2 will now be 'jw' (Javanese)
.Ve
.Sp
If the code passed is not a valid script code in
the first code set, or if there isn't a code for the
corresponding script in the second code set,
then \f(CW\*(C`undef\*(C'\fR will be returned.
.SH "QUERY ROUTINES"
.IX Header "QUERY ROUTINES"
There are two function which can be used to obtain a list of all codes,
or all script names:
.ie n .IP """all_script_codes ( [ CODESET ] )""" 4
.el .IP "\f(CWall_script_codes ( [ CODESET ] )\fR" 4
.IX Item "all_script_codes ( [ CODESET ] )"
Returns a list of all two-letter script codes.
The codes are guaranteed to be all lower\-case,
and not in any particular order.
.ie n .IP """all_script_names ( [ CODESET ] )""" 4
.el .IP "\f(CWall_script_names ( [ CODESET ] )\fR" 4
.IX Item "all_script_names ( [ CODESET ] )"
Returns a list of all script names for which there is a corresponding
script code in the specified code set.
The names are capitalised, and not returned in any particular order.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The following example illustrates use of the \f(CW\*(C`code2script()\*(C'\fR function.
The user is prompted for a script code, and then told the corresponding
script name:
.PP
.Vb 1
\&    $| = 1;   # turn off buffering
.Ve
.PP
.Vb 11
\&    print "Enter script code: ";
\&    chop($code = <STDIN>);
\&    $script = code2script($code, LOCALE_CODE_ALPHA_2);
\&    if (defined $script)
\&    {
\&        print "$code = $script\en";
\&    }
\&    else
\&    {
\&        print "'$code' is not a valid script code!\en";
\&    }
.Ve
.SH "KNOWN BUGS AND LIMITATIONS"
.IX Header "KNOWN BUGS AND LIMITATIONS"
.IP "\(bu" 4
When using \f(CW\*(C`script2code()\*(C'\fR, the script name must currently appear
exactly as it does in the source of the module. For example,
.Sp
.Vb 1
\&    script2code('Egyptian hieroglyphs')
.Ve
.Sp
will return \fBeg\fR, as expected. But the following will all return \f(CW\*(C`undef\*(C'\fR:
.Sp
.Vb 2
\&    script2code('hieroglyphs')
\&    script2code('Egyptian Hieroglypics')
.Ve
.Sp
If there's need for it, a future version could have variants
for script names.
.IP "\(bu" 4
In the current implementation, all data is read in when the
module is loaded, and then held in memory.
A lazy implementation would be more memory friendly.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Locale::Language" 4
.IX Item "Locale::Language"
\&\s-1ISO\s0 two letter codes for identification of language (\s-1ISO\s0 639).
.IP "Locale::Currency" 4
.IX Item "Locale::Currency"
\&\s-1ISO\s0 three letter codes for identification of currencies
and funds (\s-1ISO\s0 4217).
.IP "Locale::Country" 4
.IX Item "Locale::Country"
\&\s-1ISO\s0 three letter codes for identification of countries (\s-1ISO\s0 3166)
.IP "\s-1ISO\s0 15924" 4
.IX Item "ISO 15924"
The \s-1ISO\s0 standard which defines these codes.
.IP "http://www.evertype.com/standards/iso15924/" 4
.IX Item "http://www.evertype.com/standards/iso15924/"
Home page for \s-1ISO\s0 15924.
.SH "AUTHOR"
.IX Header "AUTHOR"
Neil Bowers <neil@bowers.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2002\-2004 Neil Bowers.
.PP
This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.
