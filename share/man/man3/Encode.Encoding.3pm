.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Encoding 3pm"
.TH Encode::Encoding 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Encode::Encoding \- Encode Implementation Base Class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  package Encode::MyEncoding;
\&  use base qw(Encode::Encoding);
.Ve
.PP
.Vb 1
\&  __PACKAGE__->Define(qw(myCanonical myAlias));
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
As mentioned in Encode, encodings are (in the current
implementation at least) defined as objects. The mapping of encoding
name to object is via the \f(CW%Encode::Encoding\fR hash.  Though you can
directly manipulate this hash, it is strongly encouraged to use this
base class module and add \fIencode()\fR and \fIdecode()\fR methods.
.Sh "Methods you should implement"
.IX Subsection "Methods you should implement"
You are strongly encouraged to implement methods below, at least
either \fIencode()\fR or \fIdecode()\fR.
.IP "\->encode($string [,$check])" 4
.IX Item "->encode($string [,$check])"
\&\s-1MUST\s0 return the octet sequence representing \fI$string\fR. 
.RS 4
.IP "*" 2
If \fI$check\fR is true, it \s-1SHOULD\s0 modify \fI$string\fR in place to remove
the converted part (i.e.  the whole string unless there is an error).
If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST\s0.
.IP "*" 2
If an error occurs, it \s-1SHOULD\s0 return the octet sequence for the
fragment of string that has been converted and modify \f(CW$string\fR in-place
to remove the converted part leaving it starting with the problem
fragment.  If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST\s0.
.IP "*" 2
If \fI$check\fR is is false then \f(CW\*(C`encode\*(C'\fR \s-1MUST\s0  make a \*(L"best effort\*(R" to
convert the string \- for example, by using a replacement character.
.RE
.RS 4
.RE
.IP "\->decode($octets [,$check])" 4
.IX Item "->decode($octets [,$check])"
\&\s-1MUST\s0 return the string that \fI$octets\fR represents. 
.RS 4
.IP "*" 2
If \fI$check\fR is true, it \s-1SHOULD\s0 modify \fI$octets\fR in place to remove
the converted part (i.e.  the whole sequence unless there is an
error).  If \fIperlio_ok()\fR is true, \s-1SHOULD\s0 becomes \s-1MUST\s0.
.IP "*" 2
If an error occurs, it \s-1SHOULD\s0 return the fragment of string that has
been converted and modify \f(CW$octets\fR in-place to remove the converted
part leaving it starting with the problem fragment.  If \fIperlio_ok()\fR is
true, \s-1SHOULD\s0 becomes \s-1MUST\s0.
.IP "*" 2
If \fI$check\fR is false then \f(CW\*(C`decode\*(C'\fR should make a \*(L"best effort\*(R" to
convert the string \- for example by using Unicode's \*(L"\ex{\s-1FFFD\s0}\*(R" as a
replacement character.
.RE
.RS 4
.RE
.PP
If you want your encoding to work with encoding pragma, you should
also implement the method below.
.ie n .IP "\->cat_decode($destination, $octets\fR, \f(CW$offset\fR, \f(CW$terminator [,$check])" 4
.el .IP "\->cat_decode($destination, \f(CW$octets\fR, \f(CW$offset\fR, \f(CW$terminator\fR [,$check])" 4
.IX Item "->cat_decode($destination, $octets, $offset, $terminator [,$check])"
\&\s-1MUST\s0 decode \fI$octets\fR with \fI$offset\fR and concatenate it to \fI$destination\fR.
Decoding will terminate when \f(CW$terminator\fR (a string) appears in output.
\&\fI$offset\fR will be modified to the last \f(CW$octets\fR position at end of decode.
Returns true if \f(CW$terminator\fR appears output, else returns false.
.Sh "Other methods defined in Encode::Encodings"
.IX Subsection "Other methods defined in Encode::Encodings"
You do not have to override methods shown below unless you have to.
.IP "\->name" 4
.IX Item "->name"
Predefined As:
.Sp
.Vb 1
\&  sub name  { return shift->{'Name'} }
.Ve
.Sp
\&\s-1MUST\s0 return the string representing the canonical name of the encoding.
.IP "\->renew" 4
.IX Item "->renew"
Predefined As:
.Sp
.Vb 6
\&  sub renew {
\&    my $self = shift;
\&    my $clone = bless { %$self } => ref($self);
\&    $clone->{renewed}++;
\&    return $clone;
\&  }
.Ve
.Sp
This method reconstructs the encoding object if necessary.  If you need
to store the state during encoding, this is where you clone your object.
.Sp
PerlIO \s-1ALWAYS\s0 calls this method to make sure it has its own private
encoding object.
.IP "\->renewed" 4
.IX Item "->renewed"
Predefined As:
.Sp
.Vb 1
\&  sub renewed { $_[0]->{renewed} || 0 }
.Ve
.Sp
Tells whether the object is renewed (and how many times).  Some
modules emit \f(CW\*(C`Use of uninitialized value in null operation\*(C'\fR warning
unless the value is numeric so return 0 for false.
.IP "\->\fIperlio_ok()\fR" 4
.IX Item "->perlio_ok()"
Predefined As:
.Sp
.Vb 4
\&  sub perlio_ok { 
\&      eval{ require PerlIO::encoding };
\&      return $@ ? 0 : 1;
\&  }
.Ve
.Sp
If your encoding does not support PerlIO for some reasons, just;
.Sp
.Vb 1
\& sub perlio_ok { 0 }
.Ve
.IP "\->\fIneeds_lines()\fR" 4
.IX Item "->needs_lines()"
Predefined As:
.Sp
.Vb 1
\&  sub needs_lines { 0 };
.Ve
.Sp
If your encoding can work with PerlIO but needs line buffering, you
\&\s-1MUST\s0 define this method so it returns true.  7bit \s-1ISO\-2022\s0 encodings
are one example that needs this.  When this method is missing, false
is assumed.
.Sh "Example: Encode::ROT13"
.IX Subsection "Example: Encode::ROT13"
.Vb 3
\&  package Encode::ROT13;
\&  use strict;
\&  use base qw(Encode::Encoding);
.Ve
.PP
.Vb 1
\&  __PACKAGE__->Define('rot13');
.Ve
.PP
.Vb 6
\&  sub encode($$;$){
\&      my ($obj, $str, $chk) = @_;
\&      $str =~ tr/A-Za-z/N-ZA-Mn-za-m/;
\&      $_[1] = '' if $chk; # this is what in-place edit means
\&      return $str;
\&  }
.Ve
.PP
.Vb 2
\&  # Jr pna or ynml yvxr guvf;
\&  *decode = \e&encode;
.Ve
.PP
.Vb 1
\&  1;
.Ve
.SH "Why the heck Encode API is different?"
.IX Header "Why the heck Encode API is different?"
It should be noted that the \fI$check\fR behaviour is different from the
outer public \s-1API\s0. The logic is that the \*(L"unchecked\*(R" case is useful
when the encoding is part of a stream which may be reporting errors
(e.g. \s-1STDERR\s0).  In such cases, it is desirable to get everything
through somehow without causing additional errors which obscure the
original one. Also, the encoding is best placed to know what the
correct replacement character is, so if that is the desired behaviour
then letting low level code do it is the most efficient.
.PP
By contrast, if \fI$check\fR is true, the scheme above allows the
encoding to do as much as it can and tell the layer above how much
that was. What is lacking at present is a mechanism to report what
went wrong. The most likely interface will be an additional method
call to the object, or perhaps (to avoid forcing per-stream objects
on otherwise stateless encodings) an additional parameter.
.PP
It is also highly desirable that encoding classes inherit from
\&\f(CW\*(C`Encode::Encoding\*(C'\fR as a base class. This allows that class to define
additional behaviour for all encoding objects.
.PP
.Vb 2
\&  package Encode::MyEncoding;
\&  use base qw(Encode::Encoding);
.Ve
.PP
.Vb 1
\&  __PACKAGE__->Define(qw(myCanonical myAlias));
.Ve
.PP
to create an object with \f(CW\*(C`bless {Name => ...}, $class\*(C'\fR, and call
define_encoding.  They inherit their \f(CW\*(C`name\*(C'\fR method from
\&\f(CW\*(C`Encode::Encoding\*(C'\fR.
.Sh "Compiled Encodings"
.IX Subsection "Compiled Encodings"
For the sake of speed and efficiency, most of the encodings are now
supported via a \fIcompiled form\fR: \s-1XS\s0 modules generated from \s-1UCM\s0
files.   Encode provides the enc2xs tool to achieve that.  Please see
enc2xs for more details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlmod, enc2xs
