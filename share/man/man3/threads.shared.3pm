.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "threads::shared 3pm"
.TH threads::shared 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
threads::shared \- Perl extension for sharing data structures between threads
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&  use threads;
\&  use threads::shared;
.Ve
.PP
.Vb 5
\&  my $var : shared;
\&  $var = $scalar_value;
\&  $var = $shared_ref_value;
\&  $var = &share($simple_unshared_ref_value);
\&  $var = &share(new Foo);
.Ve
.PP
.Vb 6
\&  my($scalar, @array, %hash);
\&  share($scalar);
\&  share(@array);
\&  share(%hash);
\&  my $bar = &share([]);
\&  $hash{bar} = &share({});
.Ve
.PP
.Vb 1
\&  { lock(%hash); ...  }
.Ve
.PP
.Vb 4
\&  cond_wait($scalar);
\&  cond_timedwait($scalar, time() + 30);
\&  cond_broadcast(@array);
\&  cond_signal(%hash);
.Ve
.PP
.Vb 4
\&  my $lockvar : shared;
\&  # condition var != lock var
\&  cond_wait($var, $lockvar);
\&  cond_timedwait($var, time()+30, $lockvar);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
By default, variables are private to each thread, and each newly created
thread gets a private copy of each existing variable.  This module allows
you to share variables across different threads (and pseudoforks on Win32).
It is used together with the threads module.
.SH "EXPORT"
.IX Header "EXPORT"
\&\f(CW\*(C`share\*(C'\fR, \f(CW\*(C`cond_wait\*(C'\fR, \f(CW\*(C`cond_timedwait\*(C'\fR, \f(CW\*(C`cond_signal\*(C'\fR, \f(CW\*(C`cond_broadcast\*(C'\fR
.PP
Note that if this module is imported when \f(CW\*(C`threads\*(C'\fR has not yet been
loaded, then these functions all become no\-ops. This makes it possible
to write modules that will work in both threaded and non-threaded
environments.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.IP "share \s-1VARIABLE\s0" 4
.IX Item "share VARIABLE"
\&\f(CW\*(C`share\*(C'\fR takes a value and marks it as shared. You can share a scalar,
array, hash, scalar ref, array ref or hash ref.  \f(CW\*(C`share\*(C'\fR will return
the shared rvalue but always as a reference.
.Sp
\&\f(CW\*(C`share\*(C'\fR will traverse up references exactly \fIone\fR level.
\&\f(CW\*(C`share(\e$a)\*(C'\fR is equivalent to \f(CW\*(C`share($a)\*(C'\fR, while \f(CW\*(C`share(\e\e$a)\*(C'\fR is not.
This means that you must create nested shared data structures by first
creating individual shared leaf notes, then adding them to a shared hash
or array.
.Sp
A variable can also be marked as shared at compile time by using the
\&\f(CW\*(C`shared\*(C'\fR attribute: \f(CW\*(C`my $var : shared\*(C'\fR.
.Sp
If you want to share a newly created reference unfortunately you
need to use \f(CW\*(C`&share([])\*(C'\fR and \f(CW\*(C`&share({})\*(C'\fR syntax due to problems
with Perl's prototyping.
.Sp
The only values that can be assigned to a shared scalar are other scalar
values, or shared refs, eg
.Sp
.Vb 6
\&    my $var : shared;
\&    $var = 1;              # ok
\&    $var = &share([]);     # ok
\&    $var = [];             # error
\&    $var = A->new;         # error
\&    $var = &share(A->new); # ok as long as the A object is not nested
.Ve
.Sp
Note that it is often not wise to share an object unless the class itself
has been written to support sharing; for example, an object's destructor
may get called multiple times, one for each thread's scope exit.
.IP "lock \s-1VARIABLE\s0" 4
.IX Item "lock VARIABLE"
\&\f(CW\*(C`lock\*(C'\fR places a lock on a variable until the lock goes out of scope.
If the variable is locked by another thread, the \f(CW\*(C`lock\*(C'\fR call will
block until it's available. \f(CW\*(C`lock\*(C'\fR is recursive, so multiple calls
to \f(CW\*(C`lock\*(C'\fR are safe \*(-- the variable will remain locked until the
outermost lock on the variable goes out of scope.
.Sp
If a container object, such as a hash or array, is locked, all the
elements of that container are not locked. For example, if a thread
does a \f(CW\*(C`lock @a\*(C'\fR, any other thread doing a \f(CW\*(C`lock($a[12])\*(C'\fR won't block.
.Sp
\&\f(CW\*(C`lock\*(C'\fR will traverse up references exactly \fIone\fR level.
\&\f(CW\*(C`lock(\e$a)\*(C'\fR is equivalent to \f(CW\*(C`lock($a)\*(C'\fR, while \f(CW\*(C`lock(\e\e$a)\*(C'\fR is not.
.Sp
Note that you cannot explicitly unlock a variable; you can only wait
for the lock to go out of scope. If you need more fine-grained
control, see Thread::Semaphore.
.IP "cond_wait \s-1VARIABLE\s0" 4
.IX Item "cond_wait VARIABLE"
.PD 0
.IP "cond_wait \s-1CONDVAR\s0, \s-1LOCKVAR\s0" 4
.IX Item "cond_wait CONDVAR, LOCKVAR"
.PD
The \f(CW\*(C`cond_wait\*(C'\fR function takes a \fBlocked\fR variable as a parameter,
unlocks the variable, and blocks until another thread does a
\&\f(CW\*(C`cond_signal\*(C'\fR or \f(CW\*(C`cond_broadcast\*(C'\fR for that same locked variable.
The variable that \f(CW\*(C`cond_wait\*(C'\fR blocked on is relocked after the
\&\f(CW\*(C`cond_wait\*(C'\fR is satisfied.  If there are multiple threads
\&\f(CW\*(C`cond_wait\*(C'\fRing on the same variable, all but one will reblock waiting
to reacquire the lock on the variable. (So if you're only using
\&\f(CW\*(C`cond_wait\*(C'\fR for synchronisation, give up the lock as soon as
possible). The two actions of unlocking the variable and entering the
blocked wait state are atomic, the two actions of exiting from the
blocked wait state and relocking the variable are not.
.Sp
In its second form, \f(CW\*(C`cond_wait\*(C'\fR takes a shared, \fBunlocked\fR variable
followed by a shared, \fBlocked\fR variable.  The second variable is
unlocked and thread execution suspended until another thread signals
the first variable.
.Sp
It is important to note that the variable can be notified even if
no thread \f(CW\*(C`cond_signal\*(C'\fR or \f(CW\*(C`cond_broadcast\*(C'\fR on the variable.
It is therefore important to check the value of the variable and
go back to waiting if the requirement is not fulfilled.  For example,
to pause until a shared counter drops to zero:
.Sp
.Vb 1
\&    { lock($counter); cond_wait($count) until $counter == 0; }
.Ve
.IP "cond_timedwait \s-1VARIABLE\s0, \s-1ABS_TIMEOUT\s0" 4
.IX Item "cond_timedwait VARIABLE, ABS_TIMEOUT"
.PD 0
.IP "cond_timedwait \s-1CONDVAR\s0, \s-1ABS_TIMEOUT\s0, \s-1LOCKVAR\s0" 4
.IX Item "cond_timedwait CONDVAR, ABS_TIMEOUT, LOCKVAR"
.PD
In its two-argument form, \f(CW\*(C`cond_timedwait\*(C'\fR takes a \fBlocked\fR variable
and an absolute timeout as parameters, unlocks the variable, and blocks
until the timeout is reached or another thread signals the variable.  A
false value is returned if the timeout is reached, and a true value
otherwise.  In either case, the variable is re-locked upon return.
.Sp
Like \f(CW\*(C`cond_wait\*(C'\fR, this function may take a shared, \fBlocked\fR variable
as an additional parameter; in this case the first parameter is an
\&\fBunlocked\fR condition variable protected by a distinct lock variable.
.Sp
Again like \f(CW\*(C`cond_wait\*(C'\fR, waking up and reacquiring the lock are not
atomic, and you should always check your desired condition after this
function returns.  Since the timeout is an absolute value, however, it
does not have to be recalculated with each pass:
.Sp
.Vb 6
\&    lock($var);
\&    my $abs = time() + 15;
\&    until ($ok = desired_condition($var)) {
\&      last if !cond_timedwait($var, $abs);
\&    }
\&    # we got it if $ok, otherwise we timed out!
.Ve
.IP "cond_signal \s-1VARIABLE\s0" 4
.IX Item "cond_signal VARIABLE"
The \f(CW\*(C`cond_signal\*(C'\fR function takes a \fBlocked\fR variable as a parameter
and unblocks one thread that's \f(CW\*(C`cond_wait\*(C'\fRing on that variable. If
more than one thread is blocked in a \f(CW\*(C`cond_wait\*(C'\fR on that variable,
only one (and which one is indeterminate) will be unblocked.
.Sp
If there are no threads blocked in a \f(CW\*(C`cond_wait\*(C'\fR on the variable,
the signal is discarded. By always locking before signaling, you can
(with care), avoid signaling before another thread has entered \fIcond_wait()\fR.
.Sp
\&\f(CW\*(C`cond_signal\*(C'\fR will normally generate a warning if you attempt to use it
on an unlocked variable. On the rare occasions where doing this may be
sensible, you can skip the warning with
.Sp
.Vb 1
\&    { no warnings 'threads'; cond_signal($foo) }
.Ve
.IP "cond_broadcast \s-1VARIABLE\s0" 4
.IX Item "cond_broadcast VARIABLE"
The \f(CW\*(C`cond_broadcast\*(C'\fR function works similarly to \f(CW\*(C`cond_signal\*(C'\fR.
\&\f(CW\*(C`cond_broadcast\*(C'\fR, though, will unblock \fBall\fR the threads that are
blocked in a \f(CW\*(C`cond_wait\*(C'\fR on the locked variable, rather than only one.
.SH "NOTES"
.IX Header "NOTES"
threads::shared is designed to disable itself silently if threads are
not available. If you want access to threads, you must \f(CW\*(C`use threads\*(C'\fR
before you \f(CW\*(C`use threads::shared\*(C'\fR.  threads will emit a warning if you
use it after threads::shared.
.SH "BUGS"
.IX Header "BUGS"
\&\f(CW\*(C`bless\*(C'\fR is not supported on shared references. In the current version,
\&\f(CW\*(C`bless\*(C'\fR will only bless the thread local reference and the blessing
will not propagate to the other threads. This is expected to be
implemented in a future version of Perl.
.PP
Does not support splice on arrays!
.PP
Taking references to the elements of shared arrays and hashes does not
autovivify the elements, and neither does slicing a shared array/hash
over non-existent indices/keys autovivify the elements.
.PP
\&\fIshare()\fR allows you to \f(CW\*(C`share $hashref\->{key}\*(C'\fR without giving any error
message.  But the \f(CW\*(C`$hashref\->{key}\*(C'\fR is \fBnot\fR shared, causing the error
\&\*(L"locking can only be used on shared values\*(R" to occur when you attempt to
\&\f(CW\*(C`lock $hasref\->{key}\*(C'\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Arthur Bergman <arthur at contiller.se>
.PP
threads::shared is released under the same license as Perl
.PP
Documentation borrowed from the old Thread.pm
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads, perlthrtut, <http://www.perl.com/pub/a/2002/06/11/threads.html>
