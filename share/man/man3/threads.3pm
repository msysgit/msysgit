.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "threads 3pm"
.TH threads 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
threads \- Perl extension allowing use of interpreter based threads from perl
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use threads;
.Ve
.PP
.Vb 3
\&    sub start_thread {
\&        print "Thread started\en";
\&    }
.Ve
.PP
.Vb 3
\&    my $thread  = threads->create("start_thread","argument");
\&    my $thread2 = $thread->create(sub { print "I am a thread"},"argument");
\&    my $thread3 = async { foreach (@files) { ... } };
.Ve
.PP
.Vb 2
\&    $thread->join();
\&    $thread->detach();
.Ve
.PP
.Vb 2
\&    $thread = threads->self();
\&    $thread = threads->object( $tid );
.Ve
.PP
.Vb 3
\&    $thread->tid();
\&    threads->tid();
\&    threads->self->tid();
.Ve
.PP
.Vb 1
\&    threads->yield();
.Ve
.PP
.Vb 1
\&    threads->list();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl 5.6 introduced something called interpreter threads.  Interpreter
threads are different from \*(L"5005threads\*(R" (the thread model of Perl
5.005) by creating a new perl interpreter per thread and not sharing
any data or state between threads by default.
.PP
Prior to perl 5.8 this has only been available to people embedding
perl and for emulating \fIfork()\fR on windows.
.PP
The threads \s-1API\s0 is loosely based on the old Thread.pm \s-1API\s0. It is very
important to note that variables are not shared between threads, all
variables are per default thread local.  To use shared variables one
must use threads::shared.
.PP
It is also important to note that you must enable threads by doing
\&\f(CW\*(C`use threads\*(C'\fR as early as possible in the script itself and that it
is not possible to enable threading inside an \f(CW\*(C`eval ""\*(C'\fR, \f(CW\*(C`do\*(C'\fR,
\&\f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`use\*(C'\fR.  In particular, if you are intending to share
variables with threads::shared, you must \f(CW\*(C`use threads\*(C'\fR before you
\&\f(CW\*(C`use threads::shared\*(C'\fR and \f(CW\*(C`threads\*(C'\fR will emit a warning if you do
it the other way around.
.IP "$thread = threads\->create(function, \s-1LIST\s0)" 4
.IX Item "$thread = threads->create(function, LIST)"
This will create a new thread with the entry point function and give
it \s-1LIST\s0 as parameters.  It will return the corresponding threads
object, or \f(CW\*(C`undef\*(C'\fR if thread creation failed. The \fInew()\fR method is an
alias for \fIcreate()\fR.
.IP "$thread\->join" 4
.IX Item "$thread->join"
This will wait for the corresponding thread to join. When the thread
finishes, \fIjoin()\fR will return the return values of the entry point
function. If the thread has been detached, an error will be thrown.
.Sp
The context (void, scalar or list) of the thread creation is also the
context for \fIjoin()\fR.  This means that if you intend to return an array
from a thread, you must use \f(CW\*(C`my ($thread) = threads\-\*(C'\fRnew(...)>, and
that if you intend to return a scalar, you must use \f(CW\*(C`my $thread = ...\*(C'\fR.
.Sp
If the program exits without all other threads having been either
joined or detached, then a warning will be issued. (A program exits
either because one of its threads explicitly calls \fIexit()\fR, or in the
case of the main thread, reaches the end of the main program file.)
.IP "$thread\->detach" 4
.IX Item "$thread->detach"
Will make the thread unjoinable, and cause any eventual return value
to be discarded.
.IP "threads\->self" 4
.IX Item "threads->self"
This will return the thread object for the current thread.
.IP "$thread\->tid" 4
.IX Item "$thread->tid"
This will return the id of the thread.  Thread IDs are integers, with
the main thread in a program being 0.  Currently Perl assigns a unique
tid to every thread ever created in your program, assigning the first
thread to be created a tid of 1, and increasing the tid by 1 for each
new thread that's created.
.Sp
\&\s-1NB\s0 the class method \f(CW\*(C`threads\->tid()\*(C'\fR is a quick way to get the
current thread id if you don't have your thread object handy.
.IP "threads\->object( tid )" 4
.IX Item "threads->object( tid )"
This will return the thread object for the thread associated with the
specified tid.  Returns undef if there is no thread associated with the tid
or no tid is specified or the specified tid is undef.
.IP "threads\->\fIyield()\fR;" 4
.IX Item "threads->yield();"
This is a suggestion to the \s-1OS\s0 to let this thread yield \s-1CPU\s0 time to other
threads.  What actually happens is highly dependent upon the underlying
thread implementation.
.Sp
You may do \f(CW\*(C`use threads qw(yield)\*(C'\fR then use just a bare \f(CW\*(C`yield\*(C'\fR in your
code.
.IP "threads\->\fIlist()\fR;" 4
.IX Item "threads->list();"
This will return a list of all non joined, non detached threads.
.IP "async \s-1BLOCK\s0;" 4
.IX Item "async BLOCK;"
\&\f(CW\*(C`async\*(C'\fR creates a thread to execute the block immediately following
it.  This block is treated as an anonymous sub, and so must have a
semi-colon after the closing brace. Like \f(CW\*(C`threads\->new\*(C'\fR, \f(CW\*(C`async\*(C'\fR
returns a thread object.
.SH "WARNINGS"
.IX Header "WARNINGS"
.ie n .IP "A thread exited while %d other threads were still running" 4
.el .IP "A thread exited while \f(CW%d\fR other threads were still running" 4
.IX Item "A thread exited while %d other threads were still running"
A thread (not necessarily the main thread) exited while there were
still other threads running.  Usually it's a good idea to first collect
the return values of the created threads by joining them, and only then
exit from the main thread.
.SH "TODO"
.IX Header "TODO"
The current implementation of threads has been an attempt to get
a correct threading system working that could be built on, 
and optimized, in newer versions of perl.
.PP
Currently the overhead of creating a thread is rather large,
also the cost of returning values can be large. These are areas
were there most likely will be work done to optimize what data
that needs to be cloned.
.SH "BUGS"
.IX Header "BUGS"
.IP "Parent-Child threads." 4
.IX Item "Parent-Child threads."
On some platforms it might not be possible to destroy \*(L"parent\*(R"
threads while there are still existing child \*(L"threads\*(R".
.Sp
This will possibly be fixed in later versions of perl.
.IP "tid is I32" 4
.IX Item "tid is I32"
The thread id is a 32 bit integer, it can potentially overflow.
This might be fixed in a later version of perl.
.IP "Returning objects" 4
.IX Item "Returning objects"
When you return an object the entire stash that the object is blessed
as well.  This will lead to a large memory usage.  The ideal situation
would be to detect the original stash if it existed.
.IP "Creating threads inside \s-1BEGIN\s0 blocks" 4
.IX Item "Creating threads inside BEGIN blocks"
Creating threads inside \s-1BEGIN\s0 blocks (or during the compilation phase
in general) does not work.  (In Windows, trying to use \fIfork()\fR inside
\&\s-1BEGIN\s0 blocks is an equally losing proposition, since it has been
implemented in very much the same way as threads.)
.IP "\s-1PERL_OLD_SIGNALS\s0 are not threadsafe, will not be." 4
.IX Item "PERL_OLD_SIGNALS are not threadsafe, will not be."
If your Perl has been built with \s-1PERL_OLD_SIGNALS\s0 (one has
to explicitly add that symbol to ccflags, see \f(CW\*(C`perl \-V\*(C'\fR),
signal handling is not threadsafe.
.SH "AUTHOR and COPYRIGHT"
.IX Header "AUTHOR and COPYRIGHT"
Arthur Bergman <sky at nanisky.com>
.PP
threads is released under the same license as Perl.
.PP
Thanks to
.PP
Richard Soderberg <perl at crystalflame.net>
Helping me out tons, trying to find reasons for races and other weird bugs!
.PP
Simon Cozens <simon at brecon.co.uk>
Being there to answer zillions of annoying questions
.PP
Rocco Caputo <troc at netrus.net>
.PP
Vipul Ved Prakash <mail at vipul.net>
Helping with debugging.
.PP
please join perl\-ithreads@perl.org for more information
.SH "SEE ALSO"
.IX Header "SEE ALSO"
threads::shared, perlthrtut, 
<http://www.perl.com/pub/a/2002/06/11/threads.html>,
perlcall, perlembed, perlguts
