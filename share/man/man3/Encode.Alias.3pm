.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Encode::Alias 3pm"
.TH Encode::Alias 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Encode::Alias \- alias definitions to encodings
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  use Encode;
\&  use Encode::Alias;
\&  define_alias( newName => ENCODING);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Allows newName to be used as an alias for \s-1ENCODING\s0. \s-1ENCODING\s0 may be
either the name of an encoding or an encoding object (as described 
in Encode).
.PP
Currently \fInewName\fR can be specified in the following ways:
.IP "As a simple string." 4
.IX Item "As a simple string."
.PD 0
.IP "As a qr// compiled regular expression, e.g.:" 4
.IX Item "As a qr// compiled regular expression, e.g.:"
.PD
.Vb 1
\&  define_alias( qr/^iso8859-(\ed+)$/i => '"iso-8859-$1"' );
.Ve
.Sp
In this case, if \fI\s-1ENCODING\s0\fR is not a reference, it is \f(CW\*(C`eval\*(C'\fR\-ed
in order to allow \f(CW$1\fR etc. to be substituted.  The example is one
way to alias names as used in X11 fonts to the \s-1MIME\s0 names for the
iso\-8859\-* family.  Note the double quotes inside the single quotes.
.Sp
(or, you don't have to do this yourself because this example is predefined)
.Sp
If you are using a regex here, you have to use the quotes as shown or
it won't work.  Also note that regex handling is tricky even for the
experienced.  Use this feature with caution.
.IP "As a code reference, e.g.:" 4
.IX Item "As a code reference, e.g.:"
.Vb 1
\&  define_alias( sub {shift =~ /^iso8859-(\ed+)$/i ? "iso-8859-$1" : undef } );
.Ve
.Sp
The same effect as the example above in a different way.  The coderef
takes the alias name as an argument and returns a canonical name on
success or undef if not.  Note the second argument is not required.
Use this with even more caution than the regex version.
.PP
\fIChanges in code reference aliasing\fR
.IX Subsection "Changes in code reference aliasing"
.PP
As of Encode 1.87, the older form
.PP
.Vb 1
\&  define_alias( sub { return  /^iso8859-(\ed+)$/i ? "iso-8859-$1" : undef } );
.Ve
.PP
no longer works. 
.PP
Encode up to 1.86 internally used \*(L"local \f(CW$_\fR\*(R" to implement ths older
form.  But consider the code below;
.PP
.Vb 6
\&  use Encode;
\&  $_ = "eeeee" ;
\&  while (/(e)/g) {
\&    my $utf = decode('aliased-encoding-name', $1);
\&    print "position:",pos,"\en";
\&  }
.Ve
.PP
Prior to Encode 1.86 this fails because of \*(L"local \f(CW$_\fR\*(R".
.Sh "Alias overloading"
.IX Subsection "Alias overloading"
You can override predefined aliases by simply applying \fIdefine_alias()\fR.
The new alias is always evaluated first, and when necessary,
\&\fIdefine_alias()\fR flushes the internal cache to make the new definition
available.
.PP
.Vb 2
\&  # redirect SHIFT_JIS to MS/IBM Code Page 932, which is a
\&  # superset of SHIFT_JIS
.Ve
.PP
.Vb 2
\&  define_alias( qr/shift.*jis$/i  => '"cp932"' );
\&  define_alias( qr/sjis$/i        => '"cp932"' );
.Ve
.PP
If you want to zap all predefined aliases, you can use
.PP
.Vb 1
\&  Encode::Alias->undef_aliases;
.Ve
.PP
to do so.  And
.PP
.Vb 1
\&  Encode::Alias->init_aliases;
.Ve
.PP
gets the factory settings back.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Encode, Encode::Supported
