.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "utf8 3pm"
.TH utf8 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
utf8 \- Perl pragma to enable/disable UTF\-8 (or UTF\-EBCDIC) in source code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    use utf8;
\&    no utf8;
.Ve
.PP
.Vb 3
\&    # Convert a Perl scalar to/from UTF-8.
\&    $num_octets = utf8::upgrade($string);
\&    $success    = utf8::downgrade($string[, FAIL_OK]);
.Ve
.PP
.Vb 3
\&    # Change the native bytes of a Perl scalar to/from UTF-8 bytes.
\&    utf8::encode($string);
\&    utf8::decode($string);
.Ve
.PP
.Vb 2
\&    $flag = utf8::is_utf8(STRING); # since Perl 5.8.1
\&    $flag = utf8::valid(STRING);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`use utf8\*(C'\fR pragma tells the Perl parser to allow \s-1UTF\-8\s0 in the
program text in the current lexical scope (allow UTF-EBCDIC on \s-1EBCDIC\s0 based
platforms).  The \f(CW\*(C`no utf8\*(C'\fR pragma tells Perl to switch back to treating
the source text as literal bytes in the current lexical scope.
.PP
This pragma is primarily a compatibility device.  Perl versions
earlier than 5.6 allowed arbitrary bytes in source code, whereas
in future we would like to standardize on the \s-1UTF\-8\s0 encoding for
source text.
.PP
\&\fBDo not use this pragma for anything else than telling Perl that your
script is written in \s-1UTF\-8\s0.\fR The utility functions described below are
useful for their own purposes, but they are not really part of the
\&\*(L"pragmatic\*(R" effect.
.PP
Until \s-1UTF\-8\s0 becomes the default format for source text, either this
pragma or the encoding pragma should be used to recognize \s-1UTF\-8\s0
in the source.  When \s-1UTF\-8\s0 becomes the standard source format, this
pragma will effectively become a no\-op.  For convenience in what
follows the term \fIUTF-X\fR is used to refer to \s-1UTF\-8\s0 on \s-1ASCII\s0 and \s-1ISO\s0
Latin based platforms and UTF-EBCDIC on \s-1EBCDIC\s0 based platforms.
.PP
See also the effects of the \f(CW\*(C`\-C\*(C'\fR switch and its cousin, the
\&\f(CW$ENV{PERL_UNICODE}\fR, in perlrun.
.PP
Enabling the \f(CW\*(C`utf8\*(C'\fR pragma has the following effect:
.IP "\(bu" 4
Bytes in the source text that have their high-bit set will be treated
as being part of a literal \s-1UTF\-8\s0 character.  This includes most
literals such as identifier names, string constants, and constant
regular expression patterns.
.Sp
On \s-1EBCDIC\s0 platforms characters in the Latin 1 character set are
treated as being part of a literal UTF-EBCDIC character.
.PP
Note that if you have bytes with the eighth bit on in your script
(for example embedded Latin\-1 in your string literals), \f(CW\*(C`use utf8\*(C'\fR
will be unhappy since the bytes are most probably not well-formed
\&\s-1UTF\-8\s0.  If you want to have such bytes and use utf8, you can disable
utf8 until the end the block (or file, if at top level) by \f(CW\*(C`no utf8;\*(C'\fR.
.PP
If you want to automatically upgrade your 8\-bit legacy bytes to \s-1UTF\-8\s0,
use the encoding pragma instead of this pragma.  For example, if
you want to implicitly upgrade your \s-1ISO\s0 8859\-1 (Latin\-1) bytes to \s-1UTF\-8\s0
as used in e.g. \f(CW\*(C`chr()\*(C'\fR and \f(CW\*(C`\ex{...}\*(C'\fR, try this:
.PP
.Vb 3
\&    use encoding "latin-1";
\&    my $c = chr(0xc4);
\&    my $x = "\ex{c5}";
.Ve
.PP
In case you are wondering: yes, \f(CW\*(C`use encoding 'utf8';\*(C'\fR works much
the same as \f(CW\*(C`use utf8;\*(C'\fR.
.Sh "Utility functions"
.IX Subsection "Utility functions"
The following functions are defined in the \f(CW\*(C`utf8::\*(C'\fR package by the
Perl core.  You do not need to say \f(CW\*(C`use utf8\*(C'\fR to use these and in fact
you should not say that  unless you really want to have \s-1UTF\-8\s0 source code.
.ie n .IP "* $num_octets = utf8::upgrade($string)" 4
.el .IP "* \f(CW$num_octets\fR = utf8::upgrade($string)" 4
.IX Item "$num_octets = utf8::upgrade($string)"
Converts in-place the octet sequence in the native encoding
(Latin\-1 or \s-1EBCDIC\s0) to the equivalent character sequence in \fIUTF-X\fR.
\&\fI$string\fR already encoded as characters does no harm.
Returns the number of octets necessary to represent the string as \fIUTF-X\fR.
Can be used to make sure that the \s-1UTF\-8\s0 flag is on,
so that \f(CW\*(C`\ew\*(C'\fR or \f(CW\*(C`lc()\*(C'\fR work as Unicode on strings
containing characters in the range 0x80\-0xFF (on \s-1ASCII\s0 and
derivatives).
.Sp
\&\fBNote that this function does not handle arbitrary encodings.\fR
Therefore \fIEncode.pm\fR is recommended for the general purposes.
.Sp
Affected by the encoding pragma.
.ie n .IP "* $success = utf8::downgrade($string[, \s-1FAIL_OK\s0])" 4
.el .IP "* \f(CW$success\fR = utf8::downgrade($string[, \s-1FAIL_OK\s0])" 4
.IX Item "$success = utf8::downgrade($string[, FAIL_OK])"
Converts in-place the character sequence in \fIUTF-X\fR
to the equivalent octet sequence in the native encoding (Latin\-1 or \s-1EBCDIC\s0).
\&\fI$string\fR already encoded as octets does no harm.
Returns true on success. On failure dies or, if the value of
\&\f(CW\*(C`FAIL_OK\*(C'\fR is true, returns false.
Can be used to make sure that the \s-1UTF\-8\s0 flag is off,
e.g. when you want to make sure that the \fIsubstr()\fR or \fIlength()\fR function
works with the usually faster byte algorithm.
.Sp
\&\fBNote that this function does not handle arbitrary encodings.\fR
Therefore \fIEncode.pm\fR is recommended for the general purposes.
.Sp
\&\fBNot\fR affected by the encoding pragma.
.Sp
\&\fB\s-1NOTE:\s0\fR this function is experimental and may change
or be removed without notice.
.IP "* utf8::encode($string)" 4
.IX Item "utf8::encode($string)"
Converts in-place the character sequence to the corresponding octet sequence
in \fIUTF-X\fR.  The \s-1UTF\-8\s0 flag is turned off.  Returns nothing.
.Sp
\&\fBNote that this function does not handle arbitrary encodings.\fR
Therefore \fIEncode.pm\fR is recommended for the general purposes.
.IP "* utf8::decode($string)" 4
.IX Item "utf8::decode($string)"
Attempts to convert in-place the octet sequence in \fIUTF-X\fR
to the corresponding character sequence.  The \s-1UTF\-8\s0 flag is turned on
only if the source string contains multiple-byte \fIUTF-X\fR characters.
If \fI$string\fR is invalid as \fIUTF-X\fR, returns false; otherwise returns true.
.Sp
\&\fBNote that this function does not handle arbitrary encodings.\fR
Therefore \fIEncode.pm\fR is recommended for the general purposes.
.Sp
\&\fB\s-1NOTE:\s0\fR this function is experimental and may change
or be removed without notice.
.ie n .IP "* $flag = utf8::is_utf8(\s-1STRING\s0)" 4
.el .IP "* \f(CW$flag\fR = utf8::is_utf8(\s-1STRING\s0)" 4
.IX Item "$flag = utf8::is_utf8(STRING)"
(Since Perl 5.8.1)  Test whether \s-1STRING\s0 is in \s-1UTF\-8\s0.  Functionally
the same as \fIEncode::is_utf8()\fR.
.ie n .IP "* $flag = utf8::valid(\s-1STRING\s0)" 4
.el .IP "* \f(CW$flag\fR = utf8::valid(\s-1STRING\s0)" 4
.IX Item "$flag = utf8::valid(STRING)"
[\s-1INTERNAL\s0] Test whether \s-1STRING\s0 is in a consistent state regarding
\&\s-1UTF\-8\s0.  Will return true is well-formed \s-1UTF\-8\s0 and has the \s-1UTF\-8\s0 flag
on \fBor\fR if string is held as bytes (both these states are 'consistent').
Main reason for this routine is to allow Perl's testsuite to check
that operations have left strings in a consistent state.  You most
probably want to use \fIutf8::is_utf8()\fR instead.
.PP
\&\f(CW\*(C`utf8::encode\*(C'\fR is like \f(CW\*(C`utf8::upgrade\*(C'\fR, but the \s-1UTF8\s0 flag is
cleared.  See perlunicode for more on the \s-1UTF8\s0 flag and the C \s-1API\s0
functions \f(CW\*(C`sv_utf8_upgrade\*(C'\fR, \f(CW\*(C`sv_utf8_downgrade\*(C'\fR, \f(CW\*(C`sv_utf8_encode\*(C'\fR,
and \f(CW\*(C`sv_utf8_decode\*(C'\fR, which are wrapped by the Perl functions
\&\f(CW\*(C`utf8::upgrade\*(C'\fR, \f(CW\*(C`utf8::downgrade\*(C'\fR, \f(CW\*(C`utf8::encode\*(C'\fR and
\&\f(CW\*(C`utf8::decode\*(C'\fR.  Note that in the Perl 5.8.0 and 5.8.1 implementation
the functions utf8::is_utf8, utf8::valid, utf8::encode, utf8::decode,
utf8::upgrade, and utf8::downgrade are always available, without a
\&\f(CW\*(C`require utf8\*(C'\fR statement\*(-- this may change in future releases.
.SH "BUGS"
.IX Header "BUGS"
One can have Unicode in identifier names, but not in package/class or
subroutine names.  While some limited functionality towards this does
exist as of Perl 5.8.0, that is more accidental than designed; use of
Unicode for the said purposes is unsupported.
.PP
One reason of this unfinishedness is its (currently) inherent
unportability: since both package names and subroutine names may need
to be mapped to file and directory names, the Unicode capability of
the filesystem becomes important\*(-- and there unfortunately aren't
portable answers.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perluniintro, encoding, perlrun, bytes, perlunicode
