.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Hash::Util 3pm"
.TH Hash::Util 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Hash::Util \- A selection of general\-utility hash subroutines
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  use Hash::Util qw(lock_keys   unlock_keys
\&                    lock_value  unlock_value
\&                    lock_hash   unlock_hash
\&                    hash_seed);
.Ve
.PP
.Vb 4
\&  %hash = (foo => 42, bar => 23);
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keyset);
\&  unlock_keys(%hash);
.Ve
.PP
.Vb 2
\&  lock_value  (%hash, 'foo');
\&  unlock_value(%hash, 'foo');
.Ve
.PP
.Vb 2
\&  lock_hash  (%hash);
\&  unlock_hash(%hash);
.Ve
.PP
.Vb 1
\&  my $hashes_are_randomised = hash_seed() != 0;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Hash::Util\*(C'\fR contains special functions for manipulating hashes that
don't really warrant a keyword.
.PP
By default \f(CW\*(C`Hash::Util\*(C'\fR does not export anything.
.Sh "Restricted hashes"
.IX Subsection "Restricted hashes"
5.8.0 introduces the ability to restrict a hash to a certain set of
keys.  No keys outside of this set can be added.  It also introduces
the ability to lock an individual key so it cannot be deleted and the
value cannot be changed.
.PP
This is intended to largely replace the deprecated pseudo\-hashes.
.IP "lock_keys" 4
.IX Item "lock_keys"
.PD 0
.IP "unlock_keys" 4
.IX Item "unlock_keys"
.PD
.Vb 2
\&  lock_keys(%hash);
\&  lock_keys(%hash, @keys);
.Ve
.Sp
Restricts the given \f(CW%hash\fR's set of keys to \f(CW@keys\fR.  If \f(CW@keys\fR is not
given it restricts it to its current keyset.  No more keys can be
added. \fIdelete()\fR and \fIexists()\fR will still work, but will not alter
the set of allowed keys. \fBNote\fR: the current implementation prevents
the hash from being \fIbless()\fRed while it is in a locked state. Any attempt
to do so will raise an exception. Of course you can still \fIbless()\fR
the hash before you call \fIlock_keys()\fR so this shouldn't be a problem.
.Sp
.Vb 1
\&  unlock_keys(%hash);
.Ve
.Sp
Removes the restriction on the \f(CW%hash\fR's keyset.
.IP "lock_value" 4
.IX Item "lock_value"
.PD 0
.IP "unlock_value" 4
.IX Item "unlock_value"
.PD
.Vb 2
\&  lock_value  (%hash, $key);
\&  unlock_value(%hash, $key);
.Ve
.Sp
Locks and unlocks an individual key of a hash.  The value of a locked
key cannot be changed.
.Sp
%hash must have already been locked for this to have useful effect.
.IP "\fBlock_hash\fR" 4
.IX Item "lock_hash"
.PD 0
.IP "\fBunlock_hash\fR" 4
.IX Item "unlock_hash"
.PD
.Vb 1
\&    lock_hash(%hash);
.Ve
.Sp
\&\fIlock_hash()\fR locks an entire hash, making all keys and values readonly.
No value can be changed, no keys can be added or deleted.
.Sp
.Vb 1
\&    unlock_hash(%hash);
.Ve
.Sp
\&\fIunlock_hash()\fR does the opposite of \fIlock_hash()\fR.  All keys and values
are made read/write.  All values can be changed and keys can be added
and deleted.
.IP "\fBhash_seed\fR" 4
.IX Item "hash_seed"
.Vb 1
\&    my $hash_seed = hash_seed();
.Ve
.Sp
\&\fIhash_seed()\fR returns the seed number used to randomise hash ordering.
Zero means the \*(L"traditional\*(R" random hash ordering, non-zero means the
new even more random hash ordering introduced in Perl 5.8.1.
.Sp
\&\fBNote that the hash seed is sensitive information\fR: by knowing it one
can craft a denial-of-service attack against Perl code, even remotely,
see \*(L"Algorithmic Complexity Attacks\*(R" in perlsec for more information.
\&\fBDo not disclose the hash seed\fR to people who don't need to know it.
See also \*(L"\s-1PERL_HASH_SEED_DEBUG\s0\*(R" in perlrun.
.SH "CAVEATS"
.IX Header "CAVEATS"
Note that the trapping of the restricted operations is not atomic:
for example
.PP
.Vb 1
\&    eval { %hash = (illegal_key => 1) }
.Ve
.PP
leaves the \f(CW%hash\fR empty rather than with its original contents.
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael G Schwern <schwern@pobox.com> on top of code by Nick
Ing-Simmons and Jeffrey Friedl.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Scalar::Util, List::Util, Hash::Util,
and \*(L"Algorithmic Complexity Attacks\*(R" in perlsec.
