.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Exporter 3pm"
.TH Exporter 3pm "2001-09-21" "perl v5.8.8" "Perl Programmers Reference Guide"
.SH "NAME"
Exporter \- Implements default import method for modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
In module YourModule.pm:
.PP
.Vb 4
\&  package YourModule;
\&  require Exporter;
\&  @ISA = qw(Exporter);
\&  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
.Ve
.PP
or
.PP
.Vb 3
\&  package YourModule;
\&  use Exporter 'import'; # gives you Exporter's import() method directly
\&  @EXPORT_OK = qw(munge frobnicate);  # symbols to export on request
.Ve
.PP
In other files which wish to use YourModule:
.PP
.Vb 2
\&  use ModuleName qw(frobnicate);      # import listed symbols
\&  frobnicate ($left, $right)          # calls YourModule::frobnicate
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The Exporter module implements an \f(CW\*(C`import\*(C'\fR method which allows a module
to export functions and variables to its users' namespaces. Many modules
use Exporter rather than implementing their own \f(CW\*(C`import\*(C'\fR method because
Exporter provides a highly flexible interface, with an implementation optimised
for the common case.
.PP
Perl automatically calls the \f(CW\*(C`import\*(C'\fR method when processing a
\&\f(CW\*(C`use\*(C'\fR statement for a module. Modules and \f(CW\*(C`use\*(C'\fR are documented
in perlfunc and perlmod. Understanding the concept of
modules and how the \f(CW\*(C`use\*(C'\fR statement operates is important to
understanding the Exporter.
.Sh "How to Export"
.IX Subsection "How to Export"
The arrays \f(CW@EXPORT\fR and \f(CW@EXPORT_OK\fR in a module hold lists of
symbols that are going to be exported into the users name space by
default, or which they can request to be exported, respectively.  The
symbols can represent functions, scalars, arrays, hashes, or typeglobs.
The symbols must be given by full name with the exception that the
ampersand in front of a function is optional, e.g.
.PP
.Vb 2
\&    @EXPORT    = qw(afunc $scalar @array);   # afunc is a function
\&    @EXPORT_OK = qw(&bfunc %hash *typeglob); # explicit prefix on &bfunc
.Ve
.PP
If you are only exporting function names it is recommended to omit the
ampersand, as the implementation is faster this way.
.Sh "Selecting What To Export"
.IX Subsection "Selecting What To Export"
Do \fBnot\fR export method names!
.PP
Do \fBnot\fR export anything else by default without a good reason!
.PP
Exports pollute the namespace of the module user.  If you must export
try to use \f(CW@EXPORT_OK\fR in preference to \f(CW@EXPORT\fR and avoid short or
common symbol names to reduce the risk of name clashes.
.PP
Generally anything not exported is still accessible from outside the
module using the ModuleName::item_name (or \f(CW$blessed_ref\fR\->method)
syntax.  By convention you can use a leading underscore on names to
informally indicate that they are 'internal' and not for public use.
.PP
(It is actually possible to get private functions by saying:
.PP
.Vb 3
\&  my $subref = sub { ... };
\&  $subref->(@args);            # Call it as a function
\&  $obj->$subref(@args);        # Use it as a method
.Ve
.PP
However if you use them for methods it is up to you to figure out
how to make inheritance work.)
.PP
As a general rule, if the module is trying to be object oriented
then export nothing. If it's just a collection of functions then
\&\f(CW@EXPORT_OK\fR anything but use \f(CW@EXPORT\fR with caution. For function and
method names use barewords in preference to names prefixed with
ampersands for the export lists.
.PP
Other module design guidelines can be found in perlmod.
.Sh "How to Import"
.IX Subsection "How to Import"
In other files which wish to use your module there are three basic ways for
them to load your module and import its symbols:
.ie n .IP """use ModuleName;""" 4
.el .IP "\f(CWuse ModuleName;\fR" 4
.IX Item "use ModuleName;"
This imports all the symbols from ModuleName's \f(CW@EXPORT\fR into the namespace
of the \f(CW\*(C`use\*(C'\fR statement.
.ie n .IP """use ModuleName ();""" 4
.el .IP "\f(CWuse ModuleName ();\fR" 4
.IX Item "use ModuleName ();"
This causes perl to load your module but does not import any symbols.
.ie n .IP """use ModuleName qw(...);""" 4
.el .IP "\f(CWuse ModuleName qw(...);\fR" 4
.IX Item "use ModuleName qw(...);"
This imports only the symbols listed by the caller into their namespace.
All listed symbols must be in your \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR, else an error
occurs. The advanced export features of Exporter are accessed like this,
but with list entries that are syntactically distinct from symbol names.
.PP
Unless you want to use its advanced features, this is probably all you
need to know to use Exporter.
.SH "Advanced features"
.IX Header "Advanced features"
.Sh "Specialised Import Lists"
.IX Subsection "Specialised Import Lists"
If any of the entries in an import list begins with !, : or / then
the list is treated as a series of specifications which either add to
or delete from the list of names to import. They are processed left to
right. Specifications are in the form:
.PP
.Vb 4
\&    [!]name         This name only
\&    [!]:DEFAULT     All names in @EXPORT
\&    [!]:tag         All names in $EXPORT_TAGS{tag} anonymous list
\&    [!]/pattern/    All names in @EXPORT and @EXPORT_OK which match
.Ve
.PP
A leading ! indicates that matching names should be deleted from the
list of names to import.  If the first specification is a deletion it
is treated as though preceded by :DEFAULT. If you just want to import
extra names in addition to the default set you will still need to
include :DEFAULT explicitly.
.PP
e.g., Module.pm defines:
.PP
.Vb 3
\&    @EXPORT      = qw(A1 A2 A3 A4 A5);
\&    @EXPORT_OK   = qw(B1 B2 B3 B4 B5);
\&    %EXPORT_TAGS = (T1 => [qw(A1 A2 B1 B2)], T2 => [qw(A1 A2 B3 B4)]);
.Ve
.PP
.Vb 2
\&    Note that you cannot use tags in @EXPORT or @EXPORT_OK.
\&    Names in EXPORT_TAGS must also appear in @EXPORT or @EXPORT_OK.
.Ve
.PP
An application using Module can say something like:
.PP
.Vb 1
\&    use Module qw(:DEFAULT :T2 !B3 A3);
.Ve
.PP
Other examples include:
.PP
.Vb 2
\&    use Socket qw(!/^[AP]F_/ !SOMAXCONN !SOL_SOCKET);
\&    use POSIX  qw(:errno_h :termios_h !TCSADRAIN !/^EXIT/);
.Ve
.PP
Remember that most patterns (using //) will need to be anchored
with a leading ^, e.g., \f(CW\*(C`/^EXIT/\*(C'\fR rather than \f(CW\*(C`/EXIT/\*(C'\fR.
.PP
You can say \f(CW\*(C`BEGIN { $Exporter::Verbose=1 }\*(C'\fR to see how the
specifications are being processed and what is actually being imported
into modules.
.Sh "Exporting without using Exporter's import method"
.IX Subsection "Exporting without using Exporter's import method"
Exporter has a special method, 'export_to_level' which is used in situations
where you can't directly call Exporter's import method. The export_to_level
method looks like:
.PP
.Vb 1
\&    MyPackage->export_to_level($where_to_export, $package, @what_to_export);
.Ve
.PP
where \f(CW$where_to_export\fR is an integer telling how far up the calling stack
to export your symbols, and \f(CW@what_to_export\fR is an array telling what
symbols *to* export (usually this is \f(CW@_\fR).  The \f(CW$package\fR argument is
currently unused.
.PP
For example, suppose that you have a module, A, which already has an
import function:
.PP
.Vb 1
\&    package A;
.Ve
.PP
.Vb 2
\&    @ISA = qw(Exporter);
\&    @EXPORT_OK = qw ($b);
.Ve
.PP
.Vb 4
\&    sub import
\&    {
\&        $A::b = 1;     # not a very useful import method
\&    }
.Ve
.PP
and you want to Export symbol \f(CW$A::b\fR back to the module that called 
package A. Since Exporter relies on the import method to work, via 
inheritance, as it stands \fIExporter::import()\fR will never get called. 
Instead, say the following:
.PP
.Vb 3
\&    package A;
\&    @ISA = qw(Exporter);
\&    @EXPORT_OK = qw ($b);
.Ve
.PP
.Vb 5
\&    sub import
\&    {
\&        $A::b = 1;
\&        A->export_to_level(1, @_);
\&    }
.Ve
.PP
This will export the symbols one level 'above' the current package \- ie: to 
the program or module that used package A. 
.PP
Note: Be careful not to modify \f(CW@_\fR at all before you call export_to_level
\&\- or people using your package will get very unexplained results!
.Sh "Exporting without inheriting from Exporter"
.IX Subsection "Exporting without inheriting from Exporter"
By including Exporter in your \f(CW@ISA\fR you inherit an Exporter's \fIimport()\fR method
but you also inherit several other helper methods which you probably don't
want. To avoid this you can do
.PP
.Vb 2
\&  package YourModule;
\&  use Exporter qw( import );
.Ve
.PP
which will export Exporter's own \fIimport()\fR method into YourModule.
Everything will work as before but you won't need to include Exporter in
\&\f(CW@YourModule::ISA\fR.
.Sh "Module Version Checking"
.IX Subsection "Module Version Checking"
The Exporter module will convert an attempt to import a number from a
module into a call to \f(CW$module_name\fR\->require_version($value). This can
be used to validate that the version of the module being used is
greater than or equal to the required version.
.PP
The Exporter module supplies a default require_version method which
checks the value of \f(CW$VERSION\fR in the exporting module.
.PP
Since the default require_version method treats the \f(CW$VERSION\fR number as
a simple numeric value it will regard version 1.10 as lower than
1.9. For this reason it is strongly recommended that you use numbers
with at least two decimal places, e.g., 1.09.
.Sh "Managing Unknown Symbols"
.IX Subsection "Managing Unknown Symbols"
In some situations you may want to prevent certain symbols from being
exported. Typically this applies to extensions which have functions
or constants that may not exist on some systems.
.PP
The names of any symbols that cannot be exported should be listed
in the \f(CW@EXPORT_FAIL\fR array.
.PP
If a module attempts to import any of these symbols the Exporter
will give the module an opportunity to handle the situation before
generating an error. The Exporter will call an export_fail method
with a list of the failed symbols:
.PP
.Vb 1
\&  @failed_symbols = $module_name->export_fail(@failed_symbols);
.Ve
.PP
If the export_fail method returns an empty list then no error is
recorded and all the requested symbols are exported. If the returned
list is not empty then an error is generated for each symbol and the
export fails. The Exporter provides a default export_fail method which
simply returns the list unchanged.
.PP
Uses for the export_fail method include giving better error messages
for some symbols and performing lazy architectural checks (put more
symbols into \f(CW@EXPORT_FAIL\fR by default and then take them out if someone
actually tries to use them and an expensive check shows that they are
usable on that platform).
.Sh "Tag Handling Utility Functions"
.IX Subsection "Tag Handling Utility Functions"
Since the symbols listed within \f(CW%EXPORT_TAGS\fR must also appear in either
\&\f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR, two utility functions are provided which allow
you to easily add tagged sets of symbols to \f(CW@EXPORT\fR or \f(CW@EXPORT_OK:\fR
.PP
.Vb 1
\&  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
.Ve
.PP
.Vb 2
\&  Exporter::export_tags('foo');     # add aa, bb and cc to @EXPORT
\&  Exporter::export_ok_tags('bar');  # add aa, cc and dd to @EXPORT_OK
.Ve
.PP
Any names which are not tags are added to \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR
unchanged but will trigger a warning (with \f(CW\*(C`\-w\*(C'\fR) to avoid misspelt tags
names being silently added to \f(CW@EXPORT\fR or \f(CW@EXPORT_OK\fR. Future versions
may make this a fatal error.
.Sh "Generating combined tags"
.IX Subsection "Generating combined tags"
If several symbol categories exist in \f(CW%EXPORT_TAGS\fR, it's usually
useful to create the utility \*(L":all\*(R" to simplify \*(L"use\*(R" statements.
.PP
The simplest way to do this is:
.PP
.Vb 1
\&  %EXPORT_TAGS = (foo => [qw(aa bb cc)], bar => [qw(aa cc dd)]);
.Ve
.PP
.Vb 4
\&  # add all the other ":class" tags to the ":all" class,
\&  # deleting duplicates
\&  {
\&    my %seen;
.Ve
.PP
.Vb 3
\&    push @{$EXPORT_TAGS{all}},
\&      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}} foreach keys %EXPORT_TAGS;
\&  }
.Ve
.PP
\&\s-1CGI\s0.pm creates an \*(L":all\*(R" tag which contains some (but not really
all) of its categories.  That could be done with one small
change:
.PP
.Vb 4
\&  # add some of the other ":class" tags to the ":all" class,
\&  # deleting duplicates
\&  {
\&    my %seen;
.Ve
.PP
.Vb 4
\&    push @{$EXPORT_TAGS{all}},
\&      grep {!$seen{$_}++} @{$EXPORT_TAGS{$_}}
\&        foreach qw/html2 html3 netscape form cgi internal/;
\&  }
.Ve
.PP
Note that the tag names in \f(CW%EXPORT_TAGS\fR don't have the leading ':'.
.ie n .Sh """AUTOLOAD""ed Constants"
.el .Sh "\f(CWAUTOLOAD\fPed Constants"
.IX Subsection "AUTOLOADed Constants"
Many modules make use of \f(CW\*(C`AUTOLOAD\*(C'\fRing for constant subroutines to
avoid having to compile and waste memory on rarely used values (see
perlsub for details on constant subroutines).  Calls to such
constant subroutines are not optimized away at compile time because
they can't be checked at compile time for constancy.
.PP
Even if a prototype is available at compile time, the body of the
subroutine is not (it hasn't been \f(CW\*(C`AUTOLOAD\*(C'\fRed yet). perl needs to
examine both the \f(CW\*(C`()\*(C'\fR prototype and the body of a subroutine at
compile time to detect that it can safely replace calls to that
subroutine with the constant value.
.PP
A workaround for this is to call the constants once in a \f(CW\*(C`BEGIN\*(C'\fR block:
.PP
.Vb 1
\&   package My ;
.Ve
.PP
.Vb 1
\&   use Socket ;
.Ve
.PP
.Vb 3
\&   foo( SO_LINGER );     ## SO_LINGER NOT optimized away; called at runtime
\&   BEGIN { SO_LINGER }
\&   foo( SO_LINGER );     ## SO_LINGER optimized away at compile time.
.Ve
.PP
This forces the \f(CW\*(C`AUTOLOAD\*(C'\fR for \f(CW\*(C`SO_LINGER\*(C'\fR to take place before
\&\s-1SO_LINGER\s0 is encountered later in \f(CW\*(C`My\*(C'\fR package.
.PP
If you are writing a package that \f(CW\*(C`AUTOLOAD\*(C'\fRs, consider forcing
an \f(CW\*(C`AUTOLOAD\*(C'\fR for any constants explicitly imported by other packages
or which are usually used when your package is \f(CW\*(C`use\*(C'\fRd.
