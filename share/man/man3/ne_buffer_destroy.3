.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "NE_BUFFER_DESTROY" 3 "20 January 2006" "neon 0.25.5" "neon API reference"
.SH NAME
ne_buffer_destroy, ne_buffer_finish \- destroy a buffer object
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ne_string\&.h>
.sp
.HP 24
void\ \fBne_buffer_destroy\fR\ (ne_buffer\ *\fIbuf\fR);
.HP 24
char\ *\fBne_buffer_finish\fR\ (ne_buffer\ *\fIbuf\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
\fBne_buffer_destroy\fR frees all memory associated with the buffer\&. \fBne_buffer_finish\fR frees the buffer structure, but not the actual string stored in the buffer, which is returned and must be \fBfree\fR()d by the caller\&.

.PP
Any use of the buffer object after calling either of these functions gives undefined behaviour\&.

.SH "RETURN VALUE"

.PP
\fBne_buffer_finish\fR returns the \fBmalloc\fR\-allocated string stored in the buffer\&.

.SH "EXAMPLES"

.PP
An example use of \fBne_buffer_finish\fR; the \fBduplicate\fR function returns a string made up of \fIn\fR copies of \fIstr\fR:

.nf
static char *duplicate(int n, const char *str)
{
  ne_buffer *buf = ne_buffer_create();
  while (n\-\-) {
    ne_buffer_zappend(buf, str);
  }
  return ne_buffer_finish(buf);
}
.fi

.SH "SEE ALSO"

.PP
\fBne_buffer\fR(3), \fBne_buffer_create\fR(3), \fBne_buffer_zappend\fR(3)

.SH AUTHOR
Joe Orton <neon@webdav\&.org>.
