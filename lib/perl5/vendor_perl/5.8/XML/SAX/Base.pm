package XML::SAX::Base;

# version 0.10 - Kip Hampton <khampton@totalcinema.com>
# version 0.13 - Robin Berjon <robin@knowscape.com>
# version 0.15 - Kip Hampton <khampton@totalcinema.com>
# version 0.17 - Kip Hampton <khampton@totalcinema.com>
# version 0.19 - Kip Hampton <khampton@totalcinema.com>
# version 0.21 - Kip Hampton <khampton@totalcinema.com>
# version 0.22 - Robin Berjon <robin@knowscape.com>
# version 0.23 - Matt Sergeant <matt@sergeant.org>
# version 0.24 - Robin Berjon <robin@knowscape.com>
# version 0.25 - Kip Hampton <khampton@totalcinema.com>
# version 1.00 - Kip Hampton <khampton@totalcinema.com>
# version 1.01 - Kip Hampton <khampton@totalcinema.com>
# version 1.02 - Robin Berjon <robin@knowscape.com>
# version 1.03 - Matt Sergeant <matt@sergeant.org>
# version 1.04 - Kip Hampton <khampton@totalcinema.com>

#-----------------------------------------------------#
# STOP!!!!!
#
# This file is generated by the 'Makefile.PL' file
# that ships with the XML::SAX distribution.
# If you need to make changes, patch that file NOT
# this one.
#-----------------------------------------------------#

use strict;
use vars qw($VERSION);
use XML::SAX::Exception qw();

$VERSION = '1.04';

sub end_prefix_mapping {
    my $self = shift;
    if (defined $self->{Methods}->{'end_prefix_mapping'}) {
        $self->{Methods}->{'end_prefix_mapping'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('end_prefix_mapping') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'end_prefix_mapping'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_prefix_mapping') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_prefix_mapping'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->end_prefix_mapping(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'end_prefix_mapping'} = sub { $handler->end_prefix_mapping(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_prefix_mapping(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_prefix_mapping'} = sub { $handler->end_prefix_mapping(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_prefix_mapping'} = sub { };
        }
    }

}

sub internal_entity_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'internal_entity_decl'}) {
        $self->{Methods}->{'internal_entity_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DeclHandler'} and $method = $callbacks->{'DeclHandler'}->can('internal_entity_decl') ) {
            my $handler = $callbacks->{'DeclHandler'};
            $self->{Methods}->{'internal_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('internal_entity_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'internal_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DeclHandler'} 
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DeclHandler'}->internal_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DeclHandler'};
                $self->{Methods}->{'internal_entity_decl'} = sub { $handler->internal_entity_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->internal_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'internal_entity_decl'} = sub { $handler->internal_entity_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'internal_entity_decl'} = sub { };
        }
    }

}

sub characters {
    my $self = shift;
    if (defined $self->{Methods}->{'characters'}) {
        $self->{Methods}->{'characters'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('characters') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'characters'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('characters') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'characters'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('characters') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'characters'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->characters(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'characters'} = sub { $handler->characters(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->characters(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'characters'} = sub { $handler->characters(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->characters(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'characters'} = sub { $handler->characters(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'characters'} = sub { };
        }
    }

}

sub start_element {
    my $self = shift;
    if (defined $self->{Methods}->{'start_element'}) {
        $self->{Methods}->{'start_element'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('start_element') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'start_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('start_element') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'start_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_element') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->start_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'start_element'} = sub { $handler->start_element(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->start_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'start_element'} = sub { $handler->start_element(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_element'} = sub { $handler->start_element(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_element'} = sub { };
        }
    }

}

sub external_entity_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'external_entity_decl'}) {
        $self->{Methods}->{'external_entity_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DeclHandler'} and $method = $callbacks->{'DeclHandler'}->can('external_entity_decl') ) {
            my $handler = $callbacks->{'DeclHandler'};
            $self->{Methods}->{'external_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('external_entity_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'external_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DeclHandler'} 
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DeclHandler'}->external_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DeclHandler'};
                $self->{Methods}->{'external_entity_decl'} = sub { $handler->external_entity_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->external_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'external_entity_decl'} = sub { $handler->external_entity_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'external_entity_decl'} = sub { };
        }
    }

}

sub xml_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'xml_decl'}) {
        $self->{Methods}->{'xml_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('xml_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'xml_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('xml_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'xml_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->xml_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'xml_decl'} = sub { $handler->xml_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->xml_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'xml_decl'} = sub { $handler->xml_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'xml_decl'} = sub { };
        }
    }

}

sub entity_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'entity_decl'}) {
        $self->{Methods}->{'entity_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('entity_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('entity_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'entity_decl'} = sub { $handler->entity_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'entity_decl'} = sub { $handler->entity_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'entity_decl'} = sub { };
        }
    }

}

sub end_dtd {
    my $self = shift;
    if (defined $self->{Methods}->{'end_dtd'}) {
        $self->{Methods}->{'end_dtd'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('end_dtd') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'end_dtd'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_dtd') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_dtd'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->end_dtd(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'end_dtd'} = sub { $handler->end_dtd(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_dtd(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_dtd'} = sub { $handler->end_dtd(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_dtd'} = sub { };
        }
    }

}

sub unparsed_entity_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'unparsed_entity_decl'}) {
        $self->{Methods}->{'unparsed_entity_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('unparsed_entity_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'unparsed_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('unparsed_entity_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'unparsed_entity_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->unparsed_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'unparsed_entity_decl'} = sub { $handler->unparsed_entity_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->unparsed_entity_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'unparsed_entity_decl'} = sub { $handler->unparsed_entity_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'unparsed_entity_decl'} = sub { };
        }
    }

}

sub processing_instruction {
    my $self = shift;
    if (defined $self->{Methods}->{'processing_instruction'}) {
        $self->{Methods}->{'processing_instruction'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('processing_instruction') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'processing_instruction'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('processing_instruction') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'processing_instruction'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('processing_instruction') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'processing_instruction'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->processing_instruction(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'processing_instruction'} = sub { $handler->processing_instruction(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->processing_instruction(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'processing_instruction'} = sub { $handler->processing_instruction(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->processing_instruction(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'processing_instruction'} = sub { $handler->processing_instruction(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'processing_instruction'} = sub { };
        }
    }

}

sub attribute_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'attribute_decl'}) {
        $self->{Methods}->{'attribute_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DeclHandler'} and $method = $callbacks->{'DeclHandler'}->can('attribute_decl') ) {
            my $handler = $callbacks->{'DeclHandler'};
            $self->{Methods}->{'attribute_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('attribute_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'attribute_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DeclHandler'} 
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DeclHandler'}->attribute_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DeclHandler'};
                $self->{Methods}->{'attribute_decl'} = sub { $handler->attribute_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->attribute_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'attribute_decl'} = sub { $handler->attribute_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'attribute_decl'} = sub { };
        }
    }

}

sub fatal_error {
    my $self = shift;
    if (defined $self->{Methods}->{'fatal_error'}) {
        $self->{Methods}->{'fatal_error'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ErrorHandler'} and $method = $callbacks->{'ErrorHandler'}->can('fatal_error') ) {
            my $handler = $callbacks->{'ErrorHandler'};
            $self->{Methods}->{'fatal_error'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('fatal_error') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'fatal_error'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ErrorHandler'} 
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ErrorHandler'}->fatal_error(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ErrorHandler'};
                $self->{Methods}->{'fatal_error'} = sub { $handler->fatal_error(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->fatal_error(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'fatal_error'} = sub { $handler->fatal_error(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'fatal_error'} = sub { };
        }
    }

}

sub end_cdata {
    my $self = shift;
    if (defined $self->{Methods}->{'end_cdata'}) {
        $self->{Methods}->{'end_cdata'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('end_cdata') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'end_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('end_cdata') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'end_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_cdata') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->end_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'end_cdata'} = sub { $handler->end_cdata(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->end_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'end_cdata'} = sub { $handler->end_cdata(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_cdata'} = sub { $handler->end_cdata(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_cdata'} = sub { };
        }
    }

}

sub start_entity {
    my $self = shift;
    if (defined $self->{Methods}->{'start_entity'}) {
        $self->{Methods}->{'start_entity'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('start_entity') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'start_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_entity') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->start_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'start_entity'} = sub { $handler->start_entity(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_entity'} = sub { $handler->start_entity(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_entity'} = sub { };
        }
    }

}

sub start_prefix_mapping {
    my $self = shift;
    if (defined $self->{Methods}->{'start_prefix_mapping'}) {
        $self->{Methods}->{'start_prefix_mapping'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('start_prefix_mapping') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'start_prefix_mapping'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_prefix_mapping') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_prefix_mapping'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->start_prefix_mapping(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'start_prefix_mapping'} = sub { $handler->start_prefix_mapping(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_prefix_mapping(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_prefix_mapping'} = sub { $handler->start_prefix_mapping(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_prefix_mapping'} = sub { };
        }
    }

}

sub error {
    my $self = shift;
    if (defined $self->{Methods}->{'error'}) {
        $self->{Methods}->{'error'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ErrorHandler'} and $method = $callbacks->{'ErrorHandler'}->can('error') ) {
            my $handler = $callbacks->{'ErrorHandler'};
            $self->{Methods}->{'error'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('error') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'error'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ErrorHandler'} 
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ErrorHandler'}->error(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ErrorHandler'};
                $self->{Methods}->{'error'} = sub { $handler->error(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->error(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'error'} = sub { $handler->error(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'error'} = sub { };
        }
    }

}

sub start_document {
    my $self = shift;
    if (defined $self->{Methods}->{'start_document'}) {
        $self->{Methods}->{'start_document'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('start_document') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'start_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('start_document') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'start_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_document') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->start_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'start_document'} = sub { $handler->start_document(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->start_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'start_document'} = sub { $handler->start_document(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_document'} = sub { $handler->start_document(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_document'} = sub { };
        }
    }

}

sub ignorable_whitespace {
    my $self = shift;
    if (defined $self->{Methods}->{'ignorable_whitespace'}) {
        $self->{Methods}->{'ignorable_whitespace'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('ignorable_whitespace') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'ignorable_whitespace'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('ignorable_whitespace') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'ignorable_whitespace'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('ignorable_whitespace') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'ignorable_whitespace'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->ignorable_whitespace(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'ignorable_whitespace'} = sub { $handler->ignorable_whitespace(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->ignorable_whitespace(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'ignorable_whitespace'} = sub { $handler->ignorable_whitespace(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->ignorable_whitespace(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'ignorable_whitespace'} = sub { $handler->ignorable_whitespace(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'ignorable_whitespace'} = sub { };
        }
    }

}

sub end_document {
    my $self = shift;
    if (defined $self->{Methods}->{'end_document'}) {
        $self->{Methods}->{'end_document'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('end_document') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'end_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('end_document') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'end_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_document') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_document'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->end_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'end_document'} = sub { $handler->end_document(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->end_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'end_document'} = sub { $handler->end_document(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_document(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_document'} = sub { $handler->end_document(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_document'} = sub { };
        }
    }

}

sub start_cdata {
    my $self = shift;
    if (defined $self->{Methods}->{'start_cdata'}) {
        $self->{Methods}->{'start_cdata'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('start_cdata') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'start_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('start_cdata') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'start_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_cdata') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_cdata'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->start_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'start_cdata'} = sub { $handler->start_cdata(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->start_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'start_cdata'} = sub { $handler->start_cdata(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_cdata(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_cdata'} = sub { $handler->start_cdata(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_cdata'} = sub { };
        }
    }

}

sub set_document_locator {
    my $self = shift;
    if (defined $self->{Methods}->{'set_document_locator'}) {
        $self->{Methods}->{'set_document_locator'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('set_document_locator') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'set_document_locator'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('set_document_locator') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'set_document_locator'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('set_document_locator') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'set_document_locator'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->set_document_locator(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'set_document_locator'} = sub { $handler->set_document_locator(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->set_document_locator(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'set_document_locator'} = sub { $handler->set_document_locator(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->set_document_locator(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'set_document_locator'} = sub { $handler->set_document_locator(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'set_document_locator'} = sub { };
        }
    }

}

sub attlist_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'attlist_decl'}) {
        $self->{Methods}->{'attlist_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('attlist_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'attlist_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('attlist_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'attlist_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->attlist_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'attlist_decl'} = sub { $handler->attlist_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->attlist_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'attlist_decl'} = sub { $handler->attlist_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'attlist_decl'} = sub { };
        }
    }

}

sub start_dtd {
    my $self = shift;
    if (defined $self->{Methods}->{'start_dtd'}) {
        $self->{Methods}->{'start_dtd'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('start_dtd') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'start_dtd'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('start_dtd') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'start_dtd'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->start_dtd(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'start_dtd'} = sub { $handler->start_dtd(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->start_dtd(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'start_dtd'} = sub { $handler->start_dtd(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'start_dtd'} = sub { };
        }
    }

}

sub resolve_entity {
    my $self = shift;
    if (defined $self->{Methods}->{'resolve_entity'}) {
        $self->{Methods}->{'resolve_entity'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'EntityResolver'} and $method = $callbacks->{'EntityResolver'}->can('resolve_entity') ) {
            my $handler = $callbacks->{'EntityResolver'};
            $self->{Methods}->{'resolve_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('resolve_entity') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'resolve_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'EntityResolver'} 
        	and $callbacks->{'EntityResolver'}->can('AUTOLOAD')
        	and $callbacks->{'EntityResolver'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'EntityResolver'}->resolve_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'EntityResolver'};
                $self->{Methods}->{'resolve_entity'} = sub { $handler->resolve_entity(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->resolve_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'resolve_entity'} = sub { $handler->resolve_entity(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'resolve_entity'} = sub { };
        }
    }

}

sub entity_reference {
    my $self = shift;
    if (defined $self->{Methods}->{'entity_reference'}) {
        $self->{Methods}->{'entity_reference'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('entity_reference') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'entity_reference'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('entity_reference') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'entity_reference'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->entity_reference(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'entity_reference'} = sub { $handler->entity_reference(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->entity_reference(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'entity_reference'} = sub { $handler->entity_reference(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'entity_reference'} = sub { };
        }
    }

}

sub element_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'element_decl'}) {
        $self->{Methods}->{'element_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DeclHandler'} and $method = $callbacks->{'DeclHandler'}->can('element_decl') ) {
            my $handler = $callbacks->{'DeclHandler'};
            $self->{Methods}->{'element_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('element_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'element_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DeclHandler'} 
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DeclHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DeclHandler'}->element_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DeclHandler'};
                $self->{Methods}->{'element_decl'} = sub { $handler->element_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->element_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'element_decl'} = sub { $handler->element_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'element_decl'} = sub { };
        }
    }

}

sub notation_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'notation_decl'}) {
        $self->{Methods}->{'notation_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('notation_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'notation_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('notation_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'notation_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->notation_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'notation_decl'} = sub { $handler->notation_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->notation_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'notation_decl'} = sub { $handler->notation_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'notation_decl'} = sub { };
        }
    }

}

sub skipped_entity {
    my $self = shift;
    if (defined $self->{Methods}->{'skipped_entity'}) {
        $self->{Methods}->{'skipped_entity'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('skipped_entity') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'skipped_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('skipped_entity') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'skipped_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->skipped_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'skipped_entity'} = sub { $handler->skipped_entity(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->skipped_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'skipped_entity'} = sub { $handler->skipped_entity(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'skipped_entity'} = sub { };
        }
    }

}

sub end_element {
    my $self = shift;
    if (defined $self->{Methods}->{'end_element'}) {
        $self->{Methods}->{'end_element'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ContentHandler'} and $method = $callbacks->{'ContentHandler'}->can('end_element') ) {
            my $handler = $callbacks->{'ContentHandler'};
            $self->{Methods}->{'end_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('end_element') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'end_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_element') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_element'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ContentHandler'} 
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ContentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ContentHandler'}->end_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ContentHandler'};
                $self->{Methods}->{'end_element'} = sub { $handler->end_element(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->end_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'end_element'} = sub { $handler->end_element(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_element(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_element'} = sub { $handler->end_element(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_element'} = sub { };
        }
    }

}

sub doctype_decl {
    my $self = shift;
    if (defined $self->{Methods}->{'doctype_decl'}) {
        $self->{Methods}->{'doctype_decl'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DTDHandler'} and $method = $callbacks->{'DTDHandler'}->can('doctype_decl') ) {
            my $handler = $callbacks->{'DTDHandler'};
            $self->{Methods}->{'doctype_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('doctype_decl') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'doctype_decl'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DTDHandler'} 
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DTDHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DTDHandler'}->doctype_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DTDHandler'};
                $self->{Methods}->{'doctype_decl'} = sub { $handler->doctype_decl(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->doctype_decl(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'doctype_decl'} = sub { $handler->doctype_decl(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'doctype_decl'} = sub { };
        }
    }

}

sub comment {
    my $self = shift;
    if (defined $self->{Methods}->{'comment'}) {
        $self->{Methods}->{'comment'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'DocumentHandler'} and $method = $callbacks->{'DocumentHandler'}->can('comment') ) {
            my $handler = $callbacks->{'DocumentHandler'};
            $self->{Methods}->{'comment'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('comment') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'comment'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('comment') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'comment'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'DocumentHandler'} 
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD')
        	and $callbacks->{'DocumentHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'DocumentHandler'}->comment(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'DocumentHandler'};
                $self->{Methods}->{'comment'} = sub { $handler->comment(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->comment(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'comment'} = sub { $handler->comment(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->comment(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'comment'} = sub { $handler->comment(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'comment'} = sub { };
        }
    }

}

sub end_entity {
    my $self = shift;
    if (defined $self->{Methods}->{'end_entity'}) {
        $self->{Methods}->{'end_entity'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'LexicalHandler'} and $method = $callbacks->{'LexicalHandler'}->can('end_entity') ) {
            my $handler = $callbacks->{'LexicalHandler'};
            $self->{Methods}->{'end_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('end_entity') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'end_entity'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'LexicalHandler'} 
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD')
        	and $callbacks->{'LexicalHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'LexicalHandler'}->end_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'LexicalHandler'};
                $self->{Methods}->{'end_entity'} = sub { $handler->end_entity(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->end_entity(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'end_entity'} = sub { $handler->end_entity(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'end_entity'} = sub { };
        }
    }

}

sub warning {
    my $self = shift;
    if (defined $self->{Methods}->{'warning'}) {
        $self->{Methods}->{'warning'}->(@_);
    }
    else {
        my $method;
        my $callbacks;
        if (exists $self->{ParseOptions}) {
            $callbacks = $self->{ParseOptions};
        }
        else {
            $callbacks = $self;
        }
        if (0) { # dummy to make elsif's below compile
        }
        elsif (defined $callbacks->{'ErrorHandler'} and $method = $callbacks->{'ErrorHandler'}->can('warning') ) {
            my $handler = $callbacks->{'ErrorHandler'};
            $self->{Methods}->{'warning'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'Handler'} and $method = $callbacks->{'Handler'}->can('warning') ) {
            my $handler = $callbacks->{'Handler'};
            $self->{Methods}->{'warning'} = sub { $method->($handler, @_) };
            return $method->($handler, @_);
        }
        elsif (defined $callbacks->{'ErrorHandler'} 
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD')
        	and $callbacks->{'ErrorHandler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'ErrorHandler'}->warning(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'ErrorHandler'};
                $self->{Methods}->{'warning'} = sub { $handler->warning(@_) };
            }
            return $res;
        }
        elsif (defined $callbacks->{'Handler'} 
        	and $callbacks->{'Handler'}->can('AUTOLOAD')
        	and $callbacks->{'Handler'}->can('AUTOLOAD') ne (UNIVERSAL->can('AUTOLOAD') || '')
        	)
        {
            my $res = eval { $callbacks->{'Handler'}->warning(@_) };
            if ($@) {
                die $@;
            }
            else {
                # I think there's a buggette here...
                # if the first call throws an exception, we don't set it up right.
                # Not fatal, but we might want to address it.
                my $handler = $callbacks->{'Handler'};
                $self->{Methods}->{'warning'} = sub { $handler->warning(@_) };
            }
            return $res;
        }
        else {
            $self->{Methods}->{'warning'} = sub { };
        }
    }

}

#-------------------------------------------------------------------#
# Class->new(%options)
#-------------------------------------------------------------------#
sub new {
    my $proto = shift;
    my $class = ref($proto) || $proto;
    my $options = ($#_ == 0) ? shift : { @_ };

    unless ( defined( $options->{Handler} )         or
             defined( $options->{ContentHandler} )  or
             defined( $options->{DTDHandler} )      or
             defined( $options->{DocumentHandler} ) or
             defined( $options->{LexicalHandler} )  or
             defined( $options->{ErrorHandler} )    or
             defined( $options->{DeclHandler} ) ) {
            
             $options->{Handler} = XML::SAX::Base::NoHandler->new;
    }

    my $self = bless $options, $class;
    # turn NS processing on by default
    $self->set_feature('http://xml.org/sax/features/namespaces', 1);
    return $self;
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# $p->parse(%options)
#-------------------------------------------------------------------#
sub parse {
    my $self = shift;
    my $parse_options = $self->get_options(@_);
    local $self->{ParseOptions} = $parse_options;
    if ($self->{Parent}) { # calling parse on a filter for some reason
        return $self->{Parent}->parse($parse_options);
    }
    else {
        my $method;
        if (defined $parse_options->{Source}{CharacterStream} and $method = $self->can('_parse_characterstream')) {
            warn("parse charstream???\n");
            return $method->($self, $parse_options->{Source}{CharacterStream});
        }
        elsif (defined $parse_options->{Source}{ByteStream} and $method = $self->can('_parse_bytestream')) {
            return $method->($self, $parse_options->{Source}{ByteStream});
        }
        elsif (defined $parse_options->{Source}{String} and $method = $self->can('_parse_string')) {
            return $method->($self, $parse_options->{Source}{String});
        }
        elsif (defined $parse_options->{Source}{SystemId} and $method = $self->can('_parse_systemid')) {
            return $method->($self, $parse_options->{Source}{SystemId});
        }
        else {
            die "No _parse_* routine defined on this driver (If it is a filter, remember to set the Parent property. If you call the parse() method, make sure to set a Source. You may want to call parse_uri, parse_string or parse_file instead.) [$self]";
        }
    }
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# $p->parse_file(%options)
#-------------------------------------------------------------------#
sub parse_file {
    my $self = shift;
    my $file = shift;
    return $self->parse_uri($file, @_) if ref(\$file) eq 'SCALAR';
    my $parse_options = $self->get_options(@_);
    $parse_options->{Source}{ByteStream} = $file;
    return $self->parse($parse_options);
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# $p->parse_uri(%options)
#-------------------------------------------------------------------#
sub parse_uri {
    my $self = shift;
    my $file = shift;
    my $parse_options = $self->get_options(@_);
    $parse_options->{Source}{SystemId} = $file;
    return $self->parse($parse_options);
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# $p->parse_string(%options)
#-------------------------------------------------------------------#
sub parse_string {
    my $self = shift;
    my $string = shift;
    my $parse_options = $self->get_options(@_);
    $parse_options->{Source}{String} = $string;
    return $self->parse($parse_options);
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# get_options
#-------------------------------------------------------------------#
sub get_options {
    my $self = shift;

    if (@_ == 1) {
        return { %$self, %{$_[0]} };
    } else {
        return { %$self, @_ };
    }
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# get_features
#-------------------------------------------------------------------#
sub get_features {
   return (
    'http://xml.org/sax/features/external-general-entities'     => undef,
    'http://xml.org/sax/features/external-parameter-entities'   => undef,
    'http://xml.org/sax/features/is-standalone'                 => undef,
    'http://xml.org/sax/features/lexical-handler'               => undef,
    'http://xml.org/sax/features/parameter-entities'            => undef,
    'http://xml.org/sax/features/namespaces'                    => 1,
    'http://xml.org/sax/features/namespace-prefixes'            => 0,
    'http://xml.org/sax/features/string-interning'              => undef,
    'http://xml.org/sax/features/use-attributes2'               => undef,
    'http://xml.org/sax/features/use-locator2'                  => undef,
    'http://xml.org/sax/features/validation'                    => undef,

    'http://xml.org/sax/properties/dom-node'                    => undef,
    'http://xml.org/sax/properties/xml-string'                  => undef,
               );
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# get_feature
#-------------------------------------------------------------------#
sub get_feature {
    my $self = shift;
    my $feat = shift;

    # check %FEATURES to see if it's there, and return it if so
    # throw XML::SAX::Exception::NotRecognized if it's not there
    # throw XML::SAX::Exception::NotSupported if it's there but we
    # don't support it
    
    my %features = $self->get_features();
    if (exists $features{$feat}) {
        my %supported = map { $_ => 1 } $self->supported_features();
        if ($supported{$feat}) {
            return $self->{__PACKAGE__ . "::Features"}{$feat};
        }
        throw XML::SAX::Exception::NotSupported(
            Message => "The feature '$feat' is not supported by " . ref($self),
            Exception => undef,
            );
    }
    throw XML::SAX::Exception::NotRecognized(
        Message => "The feature '$feat' is not recognized by " . ref($self),
        Exception => undef,
        );
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# set_feature
#-------------------------------------------------------------------#
sub set_feature {
    my $self = shift;
    my $feat = shift;
    my $value = shift;
    # check %FEATURES to see if it's there, and set it if so
    # throw XML::SAX::Exception::NotRecognized if it's not there
    # throw XML::SAX::Exception::NotSupported if it's there but we
    # don't support it
    
    my %features = $self->get_features();
    if (exists $features{$feat}) {
        my %supported = map { $_ => 1 } $self->supported_features();
        if ($supported{$feat}) {
            return $self->{__PACKAGE__ . "::Features"}{$feat} = $value;
        }
        throw XML::SAX::Exception::NotSupported(
            Message => "The feature '$feat' is not supported by " . ref($self),
            Exception => undef,
            );
    }
    throw XML::SAX::Exception::NotRecognized(
        Message => "The feature '$feat' is not recognized by " . ref($self),
        Exception => undef,
        );
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# get_handler and friends
#-------------------------------------------------------------------#
sub get_handler {
    my $self = shift;
    my $handler_type = shift;
    $handler_type ||= 'Handler';
    return  defined( $self->{$handler_type} ) ? $self->{$handler_type} : undef;
}

sub get_document_handler {
    my $self = shift;
    return $self->get_handler('DocumentHandler', @_);
}

sub get_content_handler {
    my $self = shift;
    return $self->get_handler('ContentHandler', @_);
}

sub get_dtd_handler {
    my $self = shift;
    return $self->get_handler('DTDHandler', @_);
}

sub get_lexical_handler {
    my $self = shift;
    return $self->get_handler('LexicalHandler', @_);
}

sub get_decl_handler {
    my $self = shift;
    return $self->get_handler('DeclHandler', @_);
}

sub get_error_handler {
    my $self = shift;
    return $self->get_handler('ErrorHandler', @_);
}

sub get_entity_resolver {
    my $self = shift;
    return $self->get_handler('EntityResolver', @_);
}
#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# set_handler and friends
#-------------------------------------------------------------------#
sub set_handler {
    my $self = shift;
    my ($new_handler, $handler_type) = reverse @_;
    $handler_type ||= 'Handler';
    $self->{Methods} = {} if $self->{Methods};
    $self->{$handler_type} = $new_handler;
    $self->{ParseOptions}->{$handler_type} = $new_handler;
    return 1;
}

sub set_document_handler {
    my $self = shift;
    return $self->set_handler('DocumentHandler', @_);
}

sub set_content_handler {
    my $self = shift;
    return $self->set_handler('ContentHandler', @_);
}
sub set_dtd_handler {
    my $self = shift;
    return $self->set_handler('DTDHandler', @_);
}
sub set_lexical_handler {
    my $self = shift;
    return $self->set_handler('LexicalHandler', @_);
}
sub set_decl_handler {
    my $self = shift;
    return $self->set_handler('DeclHandler', @_);
}
sub set_error_handler {
    my $self = shift;
    return $self->set_handler('ErrorHandler', @_);
}
sub set_entity_resolver {
    my $self = shift;
    return $self->set_handler('EntityResolver', @_);
}

#-------------------------------------------------------------------#

#-------------------------------------------------------------------#
# supported_features
#-------------------------------------------------------------------#
sub supported_features {
    my $self = shift;
    # Only namespaces are required by all parsers
    return (
        'http://xml.org/sax/features/namespaces',
    );
}
#-------------------------------------------------------------------#

sub no_op {
    # this space intentionally blank
}


package XML::SAX::Base::NoHandler;

# we need a fake handler that doesn't implement anything, this
# simplifies the code a lot (though given the recent changes,
# it may be better to do without)
sub new {
    #warn "no handler called\n";
    return bless {};
}

1;

__END__

=head1 NAME

XML::SAX::Base - Base class SAX Drivers and Filters

=head1 SYNOPSIS

  package MyFilter;
  use XML::SAX::Base;
  @ISA = ('XML::SAX::Base');

=head1 DESCRIPTION

This module has a very simple task - to be a base class for PerlSAX
drivers and filters. It's default behaviour is to pass the input directly
to the output unchanged. It can be useful to use this module as a base class
so you don't have to, for example, implement the characters() callback.

The main advantages that it provides are easy dispatching of events the right
way (ie it takes care for you of checking that the handler has implemented
that method, or has defined an AUTOLOAD), and the guarantee that filters
will pass along events that they aren't implementing to handlers downstream
that might nevertheless be interested in them.

=head1 WRITING SAX DRIVERS AND FILTERS

Writing SAX Filters is tremendously easy: all you need to do is
inherit from this module, and define the events you want to handle. A
more detailed explanation can be found at
http://www.xml.com/pub/a/2001/10/10/sax-filters.html.

Writing Drivers is equally simple. The one thing you need to pay
attention to is B<NOT> to call events yourself (this applies to Filters
as well). For instance:

  package MyFilter;
  use base qw(XML::SAX::Base);

  sub start_element {
    my $self = shift;
    my $data = shift;
    # do something
    $self->{Handler}->start_element($data); # BAD
  }

The above example works well as precisely that: an example. But it has
several faults: 1) it doesn't test to see whether the handler defines
start_element. Perhaps it doesn't want to see that event, in which
case you shouldn't throw it (otherwise it'll die). 2) it doesn't check
ContentHandler and then Handler (ie it doesn't look to see that the
user hasn't requested events on a specific handler, and if not on the
default one), 3) if it did check all that, not only would the code be
cumbersome (see this module's source to get an idea) but it would also
probably have to check for a DocumentHandler (in case this were SAX1)
and for AUTOLOADs potentially defined in all these packages. As you can
tell, that would be fairly painful. Instead of going through that,
simply remember to use code similar to the following instead:

  package MyFilter;
  use base qw(XML::SAX::Base);

  sub start_element {
    my $self = shift;
    my $data = shift;
    # do something to filter
    $self->SUPER::start_element($data); # GOOD (and easy) !
  }

This way, once you've done your job you hand the ball back to
XML::SAX::Base and it takes care of all those problems for you!

Note that the above example doesn't apply to filters only, drivers
will benefit from the exact same feature.

=head1 METHODS

A number of methods are defined within this class for the purpose of
inheritance. Some probably don't need to be overridden (eg parse_file)
but some clearly should be (eg parse). Options for these methods are
described in the PerlSAX2 specification available from
http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/~checkout~/perl-xml/libxml-perl/doc/sax-2.0.html?rev=HEAD&content-type=text/html.

=over 4

=item * parse

The parse method is the main entry point to parsing documents. Internally
the parse method will detect what type of "thing" you are parsing, and
call the appropriate method in your implementation class. Here is the
mapping table of what is in the Source options (see the Perl SAX 2.0
specification for the meaning of these values):

  Source Contains           parse() calls
  ===============           =============
  CharacterStream (*)       _parse_characterstream($stream, $options)
  ByteStream                _parse_bytestream($stream, $options)
  String                    _parse_string($string, $options)
  SystemId                  _parse_systemid($string, $options)

However note that these methods may not be sensible if your driver class 
is not for parsing XML. An example might be a DBI driver that generates
XML/SAX from a database table. If that is the case, you likely want to
write your own parse() method.

Also note that the Source may contain both a PublicId entry, and an
Encoding entry. To get at these, examine $options->{Source} as passed
to your method.

(*) A CharacterStream is a filehandle that does not need any encoding
translation done on it. This is implemented as a regular filehandle
and only works under Perl 5.7.2 or higher using PerlIO. To get a single
character, or number of characters from it, use the perl core read()
function. To get a single byte from it (or number of bytes), you can 
use sysread(). The encoding of the stream should be in the Encoding
entry for the Source.

=item * parse_file, parse_uri, parse_string

These are all convenience variations on parse(), and in fact simply
set up the options before calling it. You probably don't need to
override these.

=item * get_options

This is a convenience method to get options in SAX2 style, or more
generically either as hashes or as hashrefs (it returns a hashref).
You will probably want to use this method in your own implementations
of parse() and of new().

=item * get_feature, set_feature

These simply get and set features, and throw the
appropriate exceptions defined in the specification if need be.

If your subclass defines features not defined in this one,
then you should override these methods in such a way that they check for
your features first, and then call the base class's methods
for features not defined by your class. An example would be:

  sub get_feature {
      my $self = shift;
      my $feat = shift;
      if (exists $MY_FEATURES{$feat}) {
          # handle the feature in various ways
      }
      else {
          return $self->SUPER::get_feature($feat);
      }
  }

Currently this part is unimplemented.


=item * set_handler

This method takes a handler type (Handler, ContentHandler, etc.) and a
handler object as arguments, and changes the current handler for that
handler type, while taking care of resetting the internal state that 
needs to be reset. This allows one to change a handler during parse
without running into problems (changing it on the parser object 
directly will most likely cause trouble).

=item * set_document_handler, set_content_handler, set_dtd_handler, set_lexical_handler, set_decl_handler, set_error_handler, set_entity_resolver

These are just simple wrappers around the former method, and take a
handler object as their argument. Internally they simply call
set_handler with the correct arguments.

=item * get_handler

The inverse of set_handler, this method takes a an optional string containing a handler type (DTDHandler, 
ContentHandler, etc. 'Handler' is used if no type is passed). It returns a reference to the object that implements
that that class, or undef if that handler type is not set for the current driver/filter. 

=item * get_document_handler, get_content_handler, get_dtd_handler, get_lexical_handler, get_decl_handler, 
get_error_handler, get_entity_resolver

These are just simple wrappers around the get_handler() method, and take no arguments. Internally 
they simply call get_handler with the correct handler type name.

=back

It would be rather useless to describe all the methods that this
module implements here. They are all the methods supported in SAX1 and
SAX2. In case your memory is a little short, here is a list. The
apparent duplicates are there so that both versions of SAX can be
supported.

=over 4

=item * start_document

=item * end_document

=item * start_element

=item * start_document

=item * end_document

=item * start_element

=item * end_element

=item * characters

=item * processing_instruction

=item * ignorable_whitespace

=item * set_document_locator

=item * start_prefix_mapping

=item * end_prefix_mapping

=item * skipped_entity

=item * start_cdata

=item * end_cdata

=item * comment

=item * entity_reference

=item * notation_decl

=item * unparsed_entity_decl

=item * element_decl

=item * attlist_decl

=item * doctype_decl

=item * xml_decl

=item * entity_decl

=item * attribute_decl

=item * internal_entity_decl

=item * external_entity_decl

=item * resolve_entity

=item * start_dtd

=item * end_dtd

=item * start_entity

=item * end_entity

=item * warning

=item * error

=item * fatal_error

=back

=head1 TODO

  - more tests
  - conform to the "SAX Filters" and "Java and DOM compatibility"
    sections of the SAX2 document.

=head1 AUTHOR

Kip Hampton (khampton@totalcinema.com) did most of the work, after porting
it from XML::Filter::Base.

Robin Berjon (robin@knowscape.com) pitched in with patches to make it 
usable as a base for drivers as well as filters, along with other patches.

Matt Sergeant (matt@sergeant.org) wrote the original XML::Filter::Base,
and patched a few things here and there, and imported it into
the XML::SAX distribution.

=head1 SEE ALSO

L<XML::SAX>

=cut

