<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>each - retrieve the next key/value pair from a hash</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:mingw-dvlpr@lists.sourceforge.net" />
</head>

<body style="background-color: white">
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;each - retrieve the next key/value pair from a hash</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>each - retrieve the next key/value pair from a hash</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>each HASH
 </p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>When called in list context, returns a 2-element list consisting of the
key and value for the next element of a hash, so that you can iterate over
it.  When called in scalar context, returns only the key for the next
element in the hash.</p>
<p>Entries are returned in an apparently random order.  The actual random
order is subject to change in future versions of perl, but it is
guaranteed to be in the same order as either the <code>keys</code> or <code>values</code>
function would produce on the same (unmodified) hash.  Since Perl
5.8.1 the ordering is different even between different runs of Perl
for security reasons (see <a href="/usr/lib/perl5/5.8/html/./pod/perlsec.html#algorithmic_complexity_attacks">Algorithmic Complexity Attacks in the perlsec manpage</a>).</p>
<p>When the hash is entirely read, a null array is returned in list context
(which when assigned produces a false (<code>0</code>) value), and <code>undef</code> in
scalar context.  The next call to <code>each</code> after that will start iterating
again.  There is a single iterator for each hash, shared by all <code>each</code>,
<code>keys</code>, and <code>values</code> function calls in the program; it can be reset by
reading all the elements from the hash, or by evaluating <code>keys HASH</code> or
<code>values HASH</code>.  If you add or delete elements of a hash while you're
iterating over it, you may get entries skipped or duplicated, so
don't.  Exception: It is always safe to delete the item most recently
returned by <code>each()</code>, which means that the following code will work:</p>
<pre>
        while (($key, $value) = each %hash) {
          print $key, &quot;\n&quot;;
          delete $hash{$key};   # This is safe
        }</pre>
<p>The following prints out your environment like the <code>printenv(1)</code> program,
only in a different order:</p>
<pre>
    while (($key,$value) = each %ENV) {
        print &quot;$key=$value\n&quot;;
    }</pre>
<p>See also <code>keys</code>, <code>values</code> and <code>sort</code>.</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;each - retrieve the next key/value pair from a hash</span></strong></big>
</td></tr>
</table>

</body>

</html>
