<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>fork - create a new process just like this one</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:mingw-dvlpr@lists.sourceforge.net" />
</head>

<body style="background-color: white">
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;fork - create a new process just like this one</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#name">NAME</a></li>
	<li><a href="#synopsis">SYNOPSIS</a></li>
	<li><a href="#description">DESCRIPTION</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="name">NAME</a></h1>
<p>fork - create a new process just like this one</p>
<p>
</p>
<hr />
<h1><a name="synopsis">SYNOPSIS</a></h1>
<p>fork
  </p>
<p>
</p>
<hr />
<h1><a name="description">DESCRIPTION</a></h1>
<p>Does a <code>fork(2)</code> system call to create a new process running the
same program at the same point.  It returns the child pid to the
parent process, <code>0</code> to the child process, or <code>undef</code> if the fork is
unsuccessful.  File descriptors (and sometimes locks on those descriptors)
are shared, while everything else is copied.  On most systems supporting
fork(), great care has gone into making it extremely efficient (for
example, using copy-on-write technology on data pages), making it the
dominant paradigm for multitasking over the last few decades.</p>
<p>Beginning with v5.6.0, Perl will attempt to flush all files opened for
output before forking the child process, but this may not be supported
on some platforms (see <a href="/usr/lib/perl5/5.8/html/./pod/perlport.html">the perlport manpage</a>).  To be safe, you may need to set
<a href="/usr/lib/perl5/5.8/html/./pod/perlvar.html#item___"><code>$|</code></a> ($AUTOFLUSH in English) or call the <a href="/usr/lib/perl5/5.8/html/./pod/perlvar.html#item_autoflush"><code>autoflush()</code></a> method of
<code>IO::Handle</code> on any open handles in order to avoid duplicate output.</p>
<p>If you <code>fork</code> without ever waiting on your children, you will
accumulate zombies.  On some systems, you can avoid this by setting
<code>$SIG{CHLD}</code> to <code>&quot;IGNORE&quot;</code>.  See also <a href="/usr/lib/perl5/5.8/html/./pod/perlipc.html">the perlipc manpage</a> for more examples of
forking and reaping moribund children.</p>
<p>Note that if your forked child inherits system file descriptors like
STDIN and STDOUT that are actually connected by a pipe or socket, even
if you exit, then the remote server (such as, say, a CGI script or a
backgrounded job launched from a remote shell) won't think you're done.
You should reopen those to <em>/dev/null</em> if it's any issue.</p>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;fork - create a new process just like this one</span></strong></big>
</td></tr>
</table>

</body>

</html>
