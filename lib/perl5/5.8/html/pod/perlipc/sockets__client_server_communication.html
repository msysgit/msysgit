<?xml version="1.0" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>Sockets: Client/Server Communication</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:mingw-dvlpr@lists.sourceforge.net" />
</head>

<body style="background-color: white">
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Sockets: Client/Server Communication</span></strong></big>
</td></tr>
</table>

<p><a name="__index__"></a></p>
<!-- INDEX BEGIN -->

<ul>

	<li><a href="#sockets__client_server_communication">Sockets: Client/Server Communication</a></li>
</ul>
<!-- INDEX END -->

<hr />
<p>
</p>
<h1><a name="sockets__client_server_communication">Sockets: Client/Server Communication</a></h1>
<p>While not limited to Unix-derived operating systems (e.g., WinSock on PCs
provides socket support, as do some VMS libraries), you may not have
sockets on your system, in which case this section probably isn't going to do
you much good.  With sockets, you can do both virtual circuits (i.e., TCP
streams) and datagrams (i.e., UDP packets).  You may be able to do even more
depending on your system.</p>
<p>The Perl function calls for dealing with sockets have the same names as
the corresponding system calls in C, but their arguments tend to differ
for two reasons: first, Perl filehandles work differently than C file
descriptors.  Second, Perl already knows the length of its strings, so you
don't need to pass that information.</p>
<p>One of the major problems with old socket code in Perl was that it used
hard-coded values for some of the constants, which severely hurt
portability.  If you ever see code that does anything like explicitly
setting <code>$AF_INET = 2</code>, you know you're in for big trouble:  An
immeasurably superior approach is to use the <code>Socket</code> module, which more
reliably grants access to various constants and functions you'll need.</p>
<p>If you're not writing a server/client for an existing protocol like
NNTP or SMTP, you should give some thought to how your server will
know when the client has finished talking, and vice-versa.  Most
protocols are based on one-line messages and responses (so one party
knows the other has finished when a ``\n'' is received) or multi-line
messages and responses that end with a period on an empty line
(``\n.\n'' terminates a message/response).</p>
<ul>
<li>
<p>Back to <a href="/usr/lib/perl5/5.8/html/./pod/perlipc/bidirectional_communication_with_yourself.html">Bidirectional Communication with Yourself in the perlipc manpage</a></p>
</li>
<li>
<p>Forward to <a href="/usr/lib/perl5/5.8/html/./pod/perlipc/internet_line_terminators.html">Internet Line Terminators in the perlipc manpage</a></p>
</li>
<li>
<p>Up to <a href="/usr/lib/perl5/5.8/html/./pod/perlipc.html">the perlipc manpage</a></p>
</li>
</ul>
<table border="0" width="100%" cellspacing="0" cellpadding="3">
<tr><td class="block" style="background-color: #cccccc" valign="middle">
<big><strong><span class="block">&nbsp;Sockets: Client/Server Communication</span></strong></big>
</td></tr>
</table>

</body>

</html>
